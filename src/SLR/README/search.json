{
  "databases": null,
  "limit": null,
  "limit_per_database": null,
  "number_of_papers": 592,
  "number_of_papers_by_database": {
    "ACM": 93,
    "IEEE": 134,
    "PubMed": 4,
    "Scopus": 492,
    "arXiv": 64
  },
  "papers": [
    {
      "abstract": "Decompiler is a system for recovering the original code from bytecode. A critical challenge in decompilers is that the decompiled code contains differences from the original code. These differences not only reduce the readability of the source code but may also...",
      "authors": [
        "Kaichi, Ryunosuke",
        "Matsumoto, Shinsuke",
        "Kusumoto, Shinji"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.1007/978-3-031-49266-2_18",
      "keywords": [
        "grammatical error correction",
        "deep learning",
        "decompiler",
        "quirk",
        "fine-tuning"
      ],
      "number_of_pages": 8,
      "pages": "259-266",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "978-3-031-49265-5",
        "issn": "1611-3349",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Product-Focused Software Process Improvement: 24th International Conference, PROFES 2023, Dornbirn, Austria, December 10\u201313, 2023, Proceedings, Part I"
      },
      "publication_date": "2023-12-11",
      "selected": null,
      "title": "Automatic Fixation of\u00a0Decompilation Quirks Using Pre-trained Language Model",
      "urls": [
        "https://dl.acm.org/doi/10.1007/978-3-031-49266-2_18",
        "https://link.springer.com/content/pdf/10.1007/978-3-031-49266-2_18.pdf"
      ]
    },
    {
      "abstract": "Large language models (LLMs) have undergone rapid evolution and achieved remarkable results in recent times. OpenAI's ChatGPT, backed by GPT-3.5 or GPT-4, has gained instant popularity due to its strong capability across a wide range of tasks, including natural language tasks, coding, mathematics, and engaging conversations. However, the impacts and limits of such LLMs in system security domain are less explored. In this paper, we delve into the limits of LLMs (i.e., ChatGPT) in seven software security applications including vulnerability detection/repair, debugging, debloating, decompilation, patching, root cause analysis, symbolic execution, and fuzzing. Our exploration reveals that ChatGPT not only excels at generating code, which is the conventional application of language models, but also demonstrates strong capability in understanding user-provided commands in natural languages, reasoning about control and data flows within programs, generating complex data structures, and even decompiling assembly code. Notably, GPT-4 showcases significant improvements over GPT-3.5 in most security tasks. Also, certain limitations of ChatGPT in security-related tasks are identified, such as its constrained ability to process long code contexts.",
      "authors": [
        "Wu, Fangzhou",
        "Zhang, Qingzhao",
        "Bajaj, Ati Priya",
        "Bao, Tiffany",
        "Zhang, Ning",
        "Wang, Ruoyu \"Fish\"",
        "Xiao, Chaowei"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-12-08",
      "selected": null,
      "title": "Exploring the Limits of ChatGPT in Software Security Applications",
      "urls": [
        "http://arxiv.org/pdf/2312.05275.pdf",
        "http://arxiv.org/pdf/2312.05275v1",
        "http://arxiv.org/abs/2312.05275v1"
      ]
    },
    {
      "abstract": "Binary and source matching is vital for vulnerability detection or program comprehension. Most existing works focus on library matching (coarse-grained) by utilizing some simple features. However, they are so coarse-grained that high false positives occur since...",
      "authors": [
        "Wang, Xiaowei",
        "Yuan, Zimu",
        "Xiao, Yang",
        "Wang, Liyan",
        "Yao, Yican",
        "Chen, Haiming",
        "Huo, Wei"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/978-3-031-45933-7_15",
      "keywords": [
        "Binary-Source Function Matching",
        "Function Matching",
        "Deep Learning"
      ],
      "number_of_pages": 17,
      "pages": "244-260",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "978-3-031-45932-0",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2023-11-21",
      "selected": null,
      "title": "Decompilation Based Deep Binary-Source Function Matching",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85178515461&origin=inward",
        "https://dl.acm.org/doi/10.1007/978-3-031-45933-7_15",
        "https://link.springer.com/content/pdf/10.1007/978-3-031-45933-7_15.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sharma T."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1142/S0219467823500523",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 1.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "02194678",
        "publisher": "World Scientific",
        "sjr": 0.244,
        "snip": 0.498,
        "subject_areas": [
          "Computer Vision and Pattern Recognition",
          "Computer Science Applications",
          "Computer Graphics and Computer-Aided Design"
        ],
        "title": "International Journal of Image and Graphics"
      },
      "publication_date": "2023-11-01",
      "selected": null,
      "title": "Visualizing Android Malicious Applications Using Texture Features",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85137404601&origin=inward"
      ]
    },
    {
      "abstract": "A C decompiler converts an executable into source code. The recovered C source code, once re-compiled, is expected to produce an executable with the same functionality as the original executable. With over twenty years of development, C decompilers have been widely used in production to support reverse engineering applications. Despite the prosperous development of C decompilers, it is widely acknowledged that decompiler outputs are mainly used for human consumption, and are not suitable for automatic recompilation. Often, a substantial amount of manual effort is required to fix the decompiler outputs before they can be recompiled and executed properly. This paper is motived by the recent success of large language models (LLMs) in comprehending dense corpus of natural language. To alleviate the tedious, costly and often error-prone manual effort in fixing decompiler outputs, we investigate the feasibility of using LLMs to augment decompiler outputs, thus delivering recompilable decompilation. Note that different from previous efforts that focus on augmenting decompiler outputs with higher readability (e.g., recovering type/variable names), we focus on augmenting decompiler outputs with recompilability, meaning to generate code that can be recompiled into an executable with the same functionality as the original executable. We conduct a pilot study to characterize the obstacles in recompiling the outputs of the de facto commercial C decompiler -- IDA-Pro. We then propose a two-step, hybrid approach to augmenting decompiler outputs with LLMs. We evaluate our approach on a set of popular C test cases, and show that our approach can deliver a high recompilation success rate to over 75% with moderate effort, whereas none of the IDA-Pro's original outputs can be recompiled. We conclude with a discussion on the limitations of our approach and promising future research directions.",
      "authors": [
        "Wong, Wai Kin",
        "Wang, Huaijin",
        "Li, Zongjie",
        "Liu, Zhibo",
        "Wang, Shuai",
        "Tang, Qiyi",
        "Nie, Sen",
        "Wu, Shi"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-10-10",
      "selected": null,
      "title": "Refining Decompiled C Code with Large Language Models",
      "urls": [
        "http://arxiv.org/abs/2310.06530v2",
        "http://arxiv.org/pdf/2310.06530.pdf",
        "http://arxiv.org/pdf/2310.06530v2"
      ]
    },
    {
      "abstract": "Android is now one of the most popular operating systems in the world because of its open source character, so the threshold for hackers to make malware has also become lower, and more and more malware has started to threaten people\u2019s lives. Graphs are used to represent the program\u2019s syntactic and semantic structure, and can naturally represent malicious behavior, so we propose a malware detection method named SFCGDroid, which based on sensitive function call graph, so we propose a malware detection method named SFCGDroid, which based on sensitive function call graph. We first decompile the Android application to generate a function call graph (FCG), and extract the sensitive function call graph (SFCG) on the FCG. Secondly, we extract two class features (1) use the Skip-gram model to obtain function embeddings, and (2) treat the SFCG as a social network and extract the triads attribute of the sensitive API. The two types of features are combined as a feature representation of the SFCG and fed into a graph convolutional network (GCN) for malware detection. For experiments on 26,939 Android software datasets, SFCGDroid in this paper can achieve 98.22% accuracy and 98.20% F1 score.",
      "authors": [
        "Shi, Sibo",
        "Tian, Shengwei",
        "Wang, Bo",
        "Zhou, Tiejun",
        "Chen, Guanxin"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s10207-023-00679-x",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "1115-1124",
      "publication": {
        "category": "Journal",
        "cite_score": 5.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16155262",
        "publisher": "Springer Verlag",
        "sjr": 0.855,
        "snip": 1.407,
        "subject_areas": [
          "Computer Networks and Communications",
          "Safety, Risk, Reliability and Quality",
          "Information Systems",
          "Software"
        ],
        "title": "International Journal of Information Security"
      },
      "publication_date": "2023-10-01",
      "selected": null,
      "title": "SFCGDroid: android malware detection based on sensitive function call graph",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/s10207-023-00679-x.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85154597218&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Papantonis, Ioannis",
        "Belle, Vaishak"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3233/FAIA230470",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "1827-1834",
      "publication": {
        "category": "Book",
        "cite_score": 1.2,
        "is_potentially_predatory": false,
        "isbn": "9781643684369",
        "issn": "09226389",
        "publisher": "IOS Press BV",
        "sjr": 0.252,
        "snip": 0.413,
        "subject_areas": [
          "Artificial Intelligence"
        ],
        "title": "Frontiers in Artificial Intelligence and Applications"
      },
      "publication_date": "2023-09-28",
      "selected": null,
      "title": "Transparency in Sum-Product Network Decompilation",
      "urls": [
        "https://ebooks.iospress.nl/pdf/doi/10.3233/FAIA230470",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85175828784&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is a widely used process for reverse engineers to significantly enhance code readability by lifting assembly code to a higher-level C-like language, pseudo-code. Nevertheless, the process of compilation and stripping irreversibly discards high-level semantic information that is crucial to code comprehension, such as comments, identifier names, and types. Existing approaches typically recover only one type of information, making them suboptimal for semantic inference. In this paper, we treat pseudo-code as a special programming language, then present a unified pre-trained model, HexT5, that is trained on vast amounts of natural language comments, source identifiers, and pseudo-code using novel pseudo-code-based pre-training objectives. We fine-tune HexT5 on various downstream tasks, including code summarization, variable name recovery, function name recovery, and similarity detection. Comprehensive experiments show that HexT5 achieves state-of-the-art performance on four downstream tasks, and it demonstrates the robust effectiveness and generalizability of HexT5 for binary-related tasks.",
      "authors": [
        "Jiaqi Xiong",
        "Guoqiang Chen",
        "Kejiang Chen",
        "Han Gao",
        "Shaoyin Cheng",
        "Weiming Zhang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ASE56229.2023.00099",
      "keywords": [
        "Programming Language Model",
        "Information Inference",
        "Deep Learning",
        "Reverse Engineering",
        "Binary Diffing"
      ],
      "number_of_pages": 13,
      "pages": "774-786",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-2509-1",
        "issn": "1938-4300",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2023 38th IEEE/ACM International Conference on Automated Software Engineering, ASE 2023"
      },
      "publication_date": "2023-09-11",
      "selected": null,
      "title": "HexT5: Unified Pre-Training for Stripped Binary Code Information Inference",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10298504",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85178996262&origin=inward"
      ]
    },
    {
      "abstract": "Malware detection is an important task in software maintenance. It can effectively protect user information from the attack of malicious developers. Existing studies mainly focus on leveraging permission information and API call information to identify malware. However, many studies pay attention to the API call without considering the role of API call sequences. In this study, we propose a new method by combining both the permission information and the API call sequence information to distinguish malicious applications from benign applications. First, we extract features of permission and API call sequence with a decompiling tool. Then, one-hot encoding and Word2Vec are adopted to represent the permission feature and the API call sequence feature for each application, respectively. Based on this, we leverage Random Forest (RF) and Convolutional Neural Networks (CNN) to train a permission-based classifier and an API call sequence-based classifier, respectively. Finally, we design a linear strategy to combine the outputs of these two classifiers to predict the labels of newly arrived applications. By an evaluation with 15,198 malicious applications and 15,129 benign applications, our approach achieves 98.84% in terms of precision, 98.17% in terms of recall, 98.50% in terms of F1-score, and 98.52% in terms of accuracy on average, and outperforms the state-of-art method Malscan by 2.12%, 0.27%, 1.20%, and 1.24%, respectively. In addition, we demonstrate that the method combining two features achieves better performance than the methods based on a single feature.",
      "authors": [
        "Chen, Xin",
        "Yu, Haihua",
        "Yu, Dongjin",
        "Chen, Jie",
        "Sun, Xiaoxiao"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s11219-022-09602-4",
      "keywords": [],
      "number_of_pages": 31,
      "pages": "655-685",
      "publication": {
        "category": "Journal",
        "cite_score": 5.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09639314",
        "publisher": "Springer New York",
        "sjr": 0.538,
        "snip": 1.134,
        "subject_areas": [
          "Safety, Risk, Reliability and Quality",
          "Software"
        ],
        "title": "Software Quality Journal"
      },
      "publication_date": "2023-09-01",
      "selected": null,
      "title": "Predicting Android malware combining permissions and API call sequences",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85142240233&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/s11219-022-09602-4.pdf"
      ]
    },
    {
      "abstract": "Building a model to reassign descriptive names for binary functions is considerable assistance for reverse engineering. Existing methods proposed for this issue are based on the low-level representation of binary code (e.g., assembly code), and especially the recent approaches employed neural-based models on instruction sequences. However, their performance is still unsatisfactory. Meanwhile, modern decompilers provide lifted representations of binary code, and their effectiveness has not been adequately studied. This paper further explores the issue of function name reassignment from the perspective of binary code representation. Specifically, we present a general and flexible NEural-based function name Reassignment framework NER, which leverages a decompiler to obtain a specific representation and applies the corresponding serialization strategy on it. NER then uses an alternative neural network to make predictions. Three levels of representation are investigated, including assembly code, Intermediate Representation (IR), and pseudo-code. We observe the binary code representations are significant for the final performance. It demonstrates that the pseudo-code is the most effective one. Based on these findings, we leverage the framework to implement a reassignment model NER-pc, which has 25% and 10% F1 score improvements against the state-of-the-art methods. Besides, more experiments are conducted to verify the design of NER and the effectiveness of NER-pc.",
      "authors": [
        "Guoqiang Chen",
        "Han Gao",
        "Jie Zhang",
        "Yanru He",
        "Shaoyin Cheng",
        "Weiming Zhang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/PST58708.2023.10320193",
      "keywords": [
        "Function name prediction",
        "Binary analysis",
        "Reverse engineering",
        "Binary code representation",
        "Neural networks"
      ],
      "number_of_pages": 11,
      "pages": "1-11",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-1388-8",
        "issn": "2574-139X",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2023 20th Annual International Conference on Privacy, Security and Trust, PST 2023"
      },
      "publication_date": "2023-08-21",
      "selected": null,
      "title": "Investigating Neural-based Function Name Reassignment from the Perspective of Binary Code Representation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10320193",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85179546561&origin=inward"
      ]
    },
    {
      "abstract": "Tiny Machine Learning is a new approach that is being used for data-driven prediction classification and regression on microcontrollers using local sensor data. The models are typically learned off-line and sent to the microcontroller for use as binary objects or frozen and converted static data. This approach is not universal or flexible. The REXA VM, which can virtualize embedded systems and sensor nodes and includes a general machine learning framework that supports arbitrary dynamic artificial neural network and decision tree models, is introduced in this study. The models are delivered as text files with highly compressed program code that are enclosed in code frames with embedded data (model parameters). The VM offers fundamental computations for ANN and DT models (Microservices). Using a decompiler, models can be updated (retrained) and sent to other nodes (mobile models). It can be demonstrated that virtualization using a bytecode machine and just-in-time compiler is still appropriate and effective for extremely low-resource processors.",
      "authors": [
        "Stefan Bosse",
        "Christoph Polle"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/FiCloud58648.2023.00026",
      "keywords": [
        "Sensor Networks",
        "Tiny ML",
        "Virtual Machines",
        "Virtualization",
        "Microservices",
        "Embedded Systems"
      ],
      "number_of_pages": 8,
      "pages": "122-129",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-1636-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2023 10th International Conference on Future Internet of Things and Cloud (FiCloud)"
      },
      "publication_date": "2023-08-14",
      "selected": null,
      "title": "Tiny Machine Learning Virtualization for IoT and Edge Computing using the REXA VM",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10410676"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yuan D."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.jss.2023.111699",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 9.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01641212",
        "publisher": "Elsevier Inc.",
        "sjr": 1.126,
        "snip": 2.032,
        "subject_areas": [
          "Hardware and Architecture",
          "Information Systems",
          "Software"
        ],
        "title": "Journal of Systems and Software"
      },
      "publication_date": "2023-08-01",
      "selected": null,
      "title": "Optimizing smart contract vulnerability detection via multi-modality code and entropy embedding",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85152224005&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Greg\u00f3rio N."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.cola.2023.101220",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 5.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "26659182",
        "publisher": "Elsevier Ltd.",
        "sjr": 0.525,
        "snip": 1.173,
        "subject_areas": [
          "Human-Computer Interaction",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Journal of Computer Languages"
      },
      "publication_date": "2023-08-01",
      "selected": null,
      "title": "E-APK: Energy pattern detection in decompiled android applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85162880130&origin=inward"
      ]
    },
    {
      "abstract": "We introduce a novel approach to automatically synthesize a mathematical representation of the control algorithms implemented in industrial cyber-physical systems (CPS), given the embedded system binary. The output model can be used by subject matter experts to assess the system's compliance with the expected behavior and for a variety of forensic applications. Our approach first performs static analysis on decompiled binary files of the controller to create a sketch of the mathematical representation. Then, we perform an evolutionary-based search to find the correct semantic for the created representation, i.e., the control law. We demonstrate the effectiveness of the introduced approach in practice via three case studies conducted on two real-life industrial CPS.",
      "authors": [
        "Shokri, Ali",
        "Perez, Alexandre",
        "Chowdhury, Souma",
        "Zeng, Chen",
        "Kaloor, Gerald",
        "Matei, Ion",
        "Schneider, Peter-Patel",
        "Gunasekaran, Akshith",
        "Rane, Shantanu"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-08-01",
      "selected": null,
      "title": "CONSTRUCT: A Program Synthesis Approach for Reconstructing Control Algorithms from Embedded System Binaries in Cyber-Physical Systems",
      "urls": [
        "http://arxiv.org/pdf/2308.00250v1",
        "http://arxiv.org/abs/2308.00250v1",
        "http://arxiv.org/pdf/2308.00250.pdf"
      ]
    },
    {
      "abstract": "We present BIRD: A Binary Intermediate Representation for formally verified Decompilation of x86-64\u00a0binaries. BIRD is a generic language capable of representing a binary program at various stages of decompilation. Decompilation can consist of various small...",
      "authors": [
        "Engel, Daniel",
        "Verbeek, Freek",
        "Ravindran, Binoy"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/978-3-031-38828-6_1",
      "keywords": [
        "Static Analysis",
        "Formal Methods",
        "Decompilation"
      ],
      "number_of_pages": 18,
      "pages": "3-20",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "978-3-031-38827-9",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2023-07-20",
      "selected": null,
      "title": "BIRD: A Binary Intermediate Representation for\u00a0Formally Verified Decompilation of\u00a0X86-64 Binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85172415099&origin=inward",
        "https://dl.acm.org/doi/10.1007/978-3-031-38828-6_1",
        "https://link.springer.com/content/pdf/10.1007/978-3-031-38828-6_1.pdf"
      ]
    },
    {
      "abstract": "Conducting binary function naming helps reverse engineers understand the internal workings of the code and perform malicious code analysis without accessing the source code. However, the loss of debugging information poses the challenge of insufficient high-level semantic information description for stripping binary code function naming. Meanwhile, the existing binary function naming scheme has one function label for only one sample. The long-tail effect of function labels for a single sample makes the machine learning-based prediction models face the challenge. To obtain a function correlation label and improve the propensity score of uncommon tail labels, we propose a multi-label learning-based binary function naming model BContext2Name. This model automatically generates relevant labels for binary function naming by function context information with the help of PfastreXML model. The experimental results show that BContext2Name can enrich function labels and alleviate the long-tail effect that exists for a single sample class. To obtain high-level semantics of binary functions, we align pseudocode and basic blocks based on disassembly and decompilation, identify concrete or abstract values of API parameters by variable tracking, and construct API-enhanced control flow graphs. Finally, a seq2seq neural network translation model with attention mechanism is constructed between function multi-label learning and enhanced control flow graphs. Experiments on the dataset reveal that the F1 values of the BContext2Name model improve by 3.55% and 15.23% over the state-of-the-art XFL and Nero, respectively. This indicates that function multi-label learning can provide accurate labels for binary functions and can help reverse analysts understand the inner working mechanism of binary code. Code and data for this evaluation are available at https://github.com/CSecurityZhongYuan/BContext2Name.",
      "authors": [
        "Bing Xia",
        "Yunxiang Ge",
        "Ruinan Yang",
        "Jiabin Yin",
        "Jianmin Pang",
        "Chongjun Tang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CSCloud-EdgeCom58631.2023.00037",
      "keywords": [
        "Binary code",
        "Program analysis",
        "Software reverse engineering",
        "Multi-Label learning",
        "Neural network translation"
      ],
      "number_of_pages": 6,
      "pages": "167-172",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-1247-8",
        "issn": "2693-8952",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2023 IEEE 10th International Conference on Cyber Security and Cloud Computing and 2023 IEEE 9th International Conference on Edge Computing and Scalable Cloud, CSCloud-EdgeCom 2023"
      },
      "publication_date": "2023-07-01",
      "selected": null,
      "title": "BContext2Name: Naming Functions in Stripped Binaries with Multi-Label Learning and Neural Networks",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10195624",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85168242181&origin=inward"
      ]
    },
    {
      "abstract": "The Google Play Store has over 3 million Android apps available for download, making it the largest app store in the world. With such a vast number of apps available, there is a growing need for security and analysis, which has led to an increase in the use of reverse engineering tools and techniques. In this paper we provide an overview of the main tools used in Android reverse engineering, which are used for various activities including decompiling apk files, converting Java into Intermediate Languages (IL), and inspecting an application's Java code. The study's finding shows App Cloner and Mt manager tools have the highest precision and capabilities in optimizing and analyzing the security of the applications. This paper concludes with a discussion of the most effective reverse engineering tools and the future prospects of improvements possible for these tools.",
      "authors": [
        "Hrushik Raj S",
        "Thejaswini P",
        "Sukumar Nandi"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/GCON58516.2023.10183629",
      "keywords": [
        "android application",
        "reverse engineering tools",
        "code obfuscation"
      ],
      "number_of_pages": 6,
      "pages": "1-6",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-3779-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2023 IEEE Guwahati Subsection Conference, GCON 2023"
      },
      "publication_date": "2023-06-23",
      "selected": null,
      "title": "Reverse Engineering techniques for Android systems: A Systematic approach",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10183629",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85167368284&origin=inward"
      ]
    },
    {
      "abstract": "Solving program induction problems requires searching through an enormous space of possibilities. DreamCoder is an inductive program synthesis system that, whilst solving problems, learns to simplify search in an iterative wake-sleep procedure. The cost of search is amortised by training a neural search policy, reducing search breadth and effectively \"compiling\" useful information to compose program solutions across tasks. Additionally, a library of program components is learnt to express discovered solutions in fewer components, reducing search depth. In DreamCoder, the neural search policy has only an indirect effect on the library learnt through the program solutions it helps discover. We present an approach for library learning that directly leverages the neural search policy, effectively \"decompiling\" its amortised knowledge to extract relevant program components. This provides stronger amortised inference: the amortised knowledge learnt to reduce search breadth is now also used to reduce search depth. We integrate our approach with DreamCoder and demonstrate faster domain proficiency with improved generalisation on a range of domains, particularly when fewer example solutions are available.",
      "authors": [
        "Palmarini, Alessandro B.",
        "Lucas, Christopher G.",
        "Siddharth, N."
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-06-13",
      "selected": null,
      "title": "DreamDecompiler: Bayesian Program Learning by Decompiling Amortised Knowledge",
      "urls": [
        "http://arxiv.org/abs/2306.07856v2",
        "http://arxiv.org/pdf/2306.07856.pdf",
        "http://arxiv.org/pdf/2306.07856v2"
      ]
    },
    {
      "abstract": "We introduce the new problem of hardware decompilation. Analogous to software decompilation, hardware decompilation is about analyzing a low-level artifact\u00e2\u0080\u0094in this case a netlist, i.e., a graph of wires and logical gates representing a digital circuit\u00e2\u0080\u0094in order to recover higher-level programming abstractions, and using those abstractions to generate code written in a hardware description language (HDL). The overall problem of hardware decompilation requires a number of pieces. In this paper we focus on one specific piece of the puzzle: a technique we call hardware loop rerolling. Hardware loop rerolling leverages clone detection and program synthesis techniques to identify repeated logic in netlists (such as would be synthesized from loops in the original HDL code) and reroll them into syntactic loops in the recovered HDL code. We evaluate hardware loop rerolling for hardware decompilation over a set of hardware design benchmarks written in the PyRTL HDL and industry standard SystemVerilog. Our implementation identifies and rerolls loops in 52 out of 53 of the netlists in our benchmark suite, and we show three examples of how hardware decompilation can provide concrete benefits: transpilation between HDLs, faster simulation times over netlists (with mean speedup of 6x), and artifact compaction (39% smaller on average).",
      "authors": [
        "Zachary D. Sisco",
        "Jonathan Balkind",
        "Timothy Sherwood",
        "Ben Hardekopf"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3591237",
      "keywords": [
        "program synthesis",
        "hardware decompilation",
        "loop rerolling"
      ],
      "number_of_pages": 23,
      "pages": "420-442",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM on Programming Languages"
      },
      "publication_date": "2023-06-06",
      "selected": null,
      "title": "Loop Rerolling for Hardware Decompilation",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3591237",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85162050431&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation aims to recover the source code form of a binary executable. It has many applications in security and software engineering such as malware analysis, vulnerability detection and code reuse. A prominent challenge in decompilation is to recover variable names. We propose a novel method that leverages the synergy of large language model (LLM) and program analysis. Language models encode rich multi-modal knowledge, but its limited input size prevents providing sufficient global context for name recovery. We propose to divide the task to many LLM queries and use program analysis to correlate and propagate the query results, which in turn improves the performance of LLM by providing additional contextual information. Our results show that 75% of the recovered names are considered good by users and our technique outperforms the state-of-the-art technique by 16.5% and 20.23% in precision and recall, respectively.",
      "authors": [
        "Xu, Xiangzhe",
        "Zhang, Zhuo",
        "Feng, Shiwei",
        "Ye, Yapeng",
        "Su, Zian",
        "Jiang, Nan",
        "Cheng, Siyuan",
        "Tan, Lin",
        "Zhang, Xiangyu"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-06-05",
      "selected": null,
      "title": "LmPa: Improving Decompilation by Synergy of Large Language Model and Program Analysis",
      "urls": [
        "http://arxiv.org/pdf/2306.02546v1",
        "http://arxiv.org/abs/2306.02546v1",
        "http://arxiv.org/pdf/2306.02546.pdf"
      ]
    },
    {
      "abstract": "From logical reasoning to mental simulation, biological and artificial neural systems possess an incredible capacity for computation. Such neural computers offer a fundamentally novel computing paradigm by representing data continuously and processing information in a natively parallel and distributed manner. To harness this computation, prior work has developed extensive training techniques to understand existing neural networks. However, the lack of a concrete and low-level machine code for neural networks precludes us from taking full advantage of a neural computing framework. Here we provide such a machine code along with a programming framework by using a recurrent neural network\u2014a reservoir computer\u2014to decompile, code and compile analogue computations. By decompiling the reservoir\u2019s internal representation and dynamics into an analytic basis of its inputs, we define a low-level neural machine code that we use to program the reservoir to solve complex equations and store chaotic dynamical systems as random-access memory. We further provide a fully distributed neural implementation of software virtualization and logical circuits, and even program a playable game of pong inside of a reservoir computer. Importantly, all of these functions are programmed without requiring any example data or sampling of state space. Finally, we demonstrate that we can accurately decompile the analytic, internal representations of a full-rank reservoir computer that has been conventionally trained using data. Taken together, we define an implementation of neural computation that can both decompile computations from existing neural connectivity and compile distributed programs as new connections. Recurrent neural networks are flexible architectures that can perform a variety of complex, time-dependent computations. Kim and Bassett introduce an alternative, \u2018programming\u2019-like computational framework to determine the appropriate network parameters for a specific task without the need for supervised training.",
      "authors": [
        "Kim, Jason Z.",
        "Bassett, Dani S."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1038/s42256-023-00668-8",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "622-630",
      "publication": {
        "category": "Journal",
        "cite_score": 32.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2522-5839",
        "publisher": "Springer International Publishing",
        "sjr": 6.21,
        "snip": 6.723,
        "subject_areas": [
          "Artificial Intelligence",
          "Human-Computer Interaction",
          "Computer Networks and Communications",
          "Computer Vision and Pattern Recognition",
          "Software"
        ],
        "title": "Nature Machine Intelligence"
      },
      "publication_date": "2023-06-01",
      "selected": null,
      "title": "A neural machine code and programming framework for the reservoir computer",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85162598029&origin=inward",
        "https://www.nature.com/articles/s42256-023-00668-8.pdf"
      ]
    },
    {
      "abstract": "Microcode provides an abstraction layer over the instruction set to decompose complex instructions into simpler micro-operations that can be more easily implemented in hardware. It is an essential optimization to simplify the design of x86 processors. However, introducing an additional layer of software beneath the instruction set poses security and reliability concerns. The microcode details are confidential to the manufacturers, preventing independent auditing or customization of the microcode. Moreover, microcode patches are signed and encrypted to prevent unauthorized patching and reverse engineering. However, recent research has recovered decrypted microcode and reverse-engineered read/write debug mechanisms on Intel Goldmont (Atom), making analysis and customization of microcode possible on a modern Intel microarchitecture. In this work, we present the first framework for static and dynamic analysis of Intel microcode. Building upon prior research, we reverse-engineer Goldmont microcode semantics and reconstruct the patching primitives for microcode customization. For static analysis, we implement a Ghidra processor module for decompilation and analysis of decrypted microcode. For dynamic analysis, we create a UEFI application that can trace and patch microcode to provide complete microcode control on Goldmont systems. Leveraging our framework, we reverse-engineer the confidential Intel microcode update algorithm and perform the first security analysis of its design and implementation. In three further case studies, we illustrate the potential security and performance benefits of microcode customization. We provide the first x86 Pointer Authentication Code (PAC) microcode implementation and its security evaluation, design and implement fast software breakpoints that are more than 1000x faster than standard breakpoints, and present constant-time microcode division, illustrating the potential security and performance benefits of microcode customization.",
      "authors": [
        "Pietro Borrello",
        "Catherine Easdon",
        "Martin Schwarzl",
        "Roland Czerny",
        "Michael Schwarz"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SPW59333.2023.00031",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "285-297",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-1237-9",
        "issn": "2639-7862",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceeding - 44th IEEE Symposium on Security and Privacy Workshops, SPW 2023"
      },
      "publication_date": "2023-05-25",
      "selected": null,
      "title": "CustomProcessingUnit: Reverse Engineering and Customization of Intel Microcode",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85168758028&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10188657"
      ]
    },
    {
      "abstract": "Neural machine translation (NMT) methods developed for natural language processing have been shown to be highly successful in automating translation from one natural language to another. Recently, these NMT methods have been adapted to the generation of program code. In NMT for code generation, the task is to generate output source code that satisfies constraints expressed in the input. In the literature, a variety of different input scenarios have been explored, including generating code based on natural language description, lower-level representations such as binary or assembly (neural decompilation), partial representations of source code (code completion and repair), and source code in another language (code translation). In this paper we survey the NMT for code generation literature, cataloging the variety of methods that have been explored according to input and output representations, model architectures, optimization techniques used, data sets, and evaluation methods. We discuss the limitations of existing methods and future research directions",
      "authors": [
        "KC, Dharma",
        "Morrison, Clayton T."
      ],
      "categories": null,
      "citations": null,
      "comments": "33 pages, 1 figure",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-05-22",
      "selected": null,
      "title": "Neural Machine Translation for Code Generation",
      "urls": [
        "http://arxiv.org/abs/2305.13504v1",
        "http://arxiv.org/pdf/2305.13504v1",
        "http://arxiv.org/pdf/2305.13504.pdf"
      ]
    },
    {
      "abstract": "Decompilation is a crucial capability in forensic analysis, facilitating analysis of unknown binaries. The recent rise of Python malware has brought attention to Python decompilers that aim to obtain source code representation from a Python binary. However, Python decompilers fail to handle various binaries, limiting their capabilities in forensic analysis.This paper proposes a novel solution that transforms a decompilation error-inducing Python binary into a decompilable binary. Our key intuition is that we can resolve the decompilation errors by transforming error-inducing code blocks in the input binary into another form. The core of our approach is the concept of Forensically Equivalent Transformation (FET) which allows non-semantic preserving transformation in the context of forensic analysis. We carefully define the FETs to minimize their undesirable consequences while fixing various error-inducing instructions that are difficult to solve when preserving the exact semantics. We evaluate the prototype of our approach with 17,117 real-world Python malware samples causing decompilation errors in five popular decompilers. It successfully identifies and fixes 77,022 errors. Our approach also handles anti-analysis techniques, including opcode remapping, and helps migrate Python 3.9 binaries to 3.8 binaries.",
      "authors": [
        "Ali Ahad",
        "Chijung Jung",
        "Ammar Askar",
        "Doowon Kim",
        "Taesoo Kim",
        "Yonghwi Kwon"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SP46215.2023.10179370",
      "keywords": [
        "Reverse-Engineering",
        "Python-Malware",
        "Binary-Transformation",
        "Decompilation"
      ],
      "number_of_pages": 18,
      "pages": "3296-3313",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-9337-6",
        "issn": "1081-6011",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - IEEE Symposium on Security and Privacy"
      },
      "publication_date": "2023-05-21",
      "selected": null,
      "title": "Pyfet: Forensically Equivalent Transformation for Python Binary Decompilation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10179370",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85166486924&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is a well-studied area with numerous high-quality tools available. These are frequently used for security tasks and to port legacy code. However, they regularly generate difficult-to-read programs and require a large amount of engineering effort to support new programming languages and ISAs. Recent interest in neural approaches has produced portable tools that generate readable code. However, to-date such techniques are usually restricted to synthetic programs without optimization, and no models have evaluated their portability. Furthermore, while the code generated may be more readable, it is usually incorrect. This paper presents SLaDe, a Small Language model Decompiler based on a sequence-to-sequence transformer trained over real-world code. We develop a novel tokenizer and exploit no-dropout training to produce high-quality code. We utilize type-inference to generate programs that are more readable and accurate than standard analytic and recent neural approaches. Unlike standard approaches, SLaDe can infer out-of-context types and unlike neural approaches, it generates correct code. We evaluate SLaDe on over 4,000 functions from AnghaBench on two ISAs and at two optimizations levels. SLaDe is up to 6 times more accurate than Ghidra, a state-of-the-art, industrial-strength decompiler and up to 4 times more accurate than the large language model ChatGPT and generates significantly more readable code than both.",
      "authors": [
        "Armengol-Estap\u00e9, Jordi",
        "Woodruff, Jackson",
        "Cummins, Chris",
        "O'Boyle, Michael F. P."
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-05-21",
      "selected": null,
      "title": "SLaDe: A Portable Small Language Model Decompiler for Optimized Assembly",
      "urls": [
        "http://arxiv.org/abs/2305.12520v2",
        "http://arxiv.org/pdf/2305.12520v2",
        "http://arxiv.org/pdf/2305.12520.pdf"
      ]
    },
    {
      "abstract": "Compiled binary executables are often the only available artifact in reverse engineering, malware analysis, and software systems maintenance. Unfortunately, the lack of semantic information like variable types makes comprehending binaries difficult. In efforts to improve the comprehensibility of binaries, researchers have recently used machine learning techniques to predict semantic information contained in the original source code. Chen et al. implemented DIRTY, a Transformer-based Encoder-Decoder architecture capable of augmenting decompiled code with variable names and types by leveraging decompiler output tokens and variable size information. Chen et al. were able to demonstrate a substantial increase in name and type extraction accuracy on Hex-Rays decompiler outputs compared to existing static analysis and AI-based techniques. We extend the original DIRTY results by re-training the DIRTY model on a dataset produced by the open-source Ghidra decompiler. Although Chen et al. concluded that Ghidra was not a suitable decompiler candidate due to its difficulty in parsing and incorporating DWARF symbols during analysis, we demonstrate that straightforward parsing of variable data generated by Ghidra results in similar retyping performance. We hope this work inspires further interest and adoption of the Ghidra decompiler for use in research projects.",
      "authors": [
        "Kevin Cao",
        "Kevin Leach"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICPC58990.2023.00042",
      "keywords": [
        "Ghidra",
        "Transformers",
        "Machine Learning",
        "Hex-Rays"
      ],
      "number_of_pages": 5,
      "pages": "275-279",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-3751-8",
        "issn": "2643-7147",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2023 IEEE/ACM 31st International Conference on Program Comprehension (ICPC)"
      },
      "publication_date": "2023-05-15",
      "selected": null,
      "title": "Revisiting Deep Learning for Variable Type Recovery",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10174218",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85166378824&origin=inward"
      ]
    },
    {
      "abstract": "Cybersecurity attacks against industrial control systems and cyber-physical systems can cause catastrophic real-world damage by infecting device binaries with malware. Mitigating such attacks can benefit from reverse engineering tools that recover sufficient semantic knowledge in terms of mathematical operations in the code. Conventional reverse engineering tools can decompile binaries to low-level code, but offer little semantic insight. This paper proposes REMaQE, an automated framework for reverse engineering of math equations from binary executables. REMaQE uses symbolic execution for dynamic analysis of the binary to extract the relevant semantic knowledge of the implemented algorithms. REMaQE provides an automatic parameter analysis pass which also leverages symbolic execution to identify input, output, and constant parameters of the implemented math equations. REMaQE automatically handles parameters accessed via registers, the stack, global memory, or pointers, and supports reverse engineering of object-oriented implementations such as C++ classes. REMaQE uses an algebraic simplification method which allows it to scale to complex conditional equations with ease. These features make REMaQE stand out over existing reverse engineering approaches for math equations. On a dataset of randomly generated math equations compiled to binaries from C and Simulink implementations, REMaQE accurately recovers a semantically matching equation for 97.53% of the models. For complex equations with more operations, accuracy stays consistently over 94%. REMaQE executes in 0.25 seconds on average and in 1.3 seconds for more complex equations. This real-time execution speed enables a smooth integration in an interactive mathematics-oriented reverse engineering workflow.",
      "authors": [
        "Udeshi, Meet",
        "Krishnamurthy, Prashanth",
        "Pearce, Hammond",
        "Karri, Ramesh",
        "Khorrami, Farshad"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-05-11",
      "selected": null,
      "title": "REMaQE -- Reverse Engineering Math Equations from Executables",
      "urls": [
        "http://arxiv.org/pdf/2305.06902.pdf",
        "http://arxiv.org/pdf/2305.06902v1",
        "http://arxiv.org/abs/2305.06902v1"
      ]
    },
    {
      "abstract": "JNI programs are widely used thanks to the combined benefits of C and Java programs. However, because understanding the interaction behaviors between two different programming languages is challenging, JNI program development is difficult to get right and vulnerable to security attacks. Thus, researchers have proposed static analysis of JNI program source code to detect bugs and security vulnerabilities in JNI programs. Unfortunately, such source code analysis is not applicable to compiled JNI programs that are not open-sourced or open-source JNI programs containing third-party binary libraries. While JN-SAF, the state-of-the-art analyzer for compiled JNI programs, can analyze binary code, it has several limitations due to its symbolic execution and summary-based bottom-up analysis. In this paper, we propose a novel approach to statically analyze compiled JNI programs without their source code using binary decompilation. Unlike JN-SAF that analyzes binaries directly, our approach decompiles binaries and analyzes JNI programs with the decompiled binaries using an existing JNI program analyzer for source code. To decompile binaries to compilable C source code with precise JNI-interoperation-related types, we improve an existing decompilation tool by leveraging the characteristics of JNI programs. Our evaluation shows that the approach is precise as almost the same as the state-of-the-art JNI program analyzer for source code, and more precise than JN-SAF.",
      "authors": [
        "Jihee Park",
        "Sungho Lee",
        "Jaemin Hong",
        "Sukyoung Ryu"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TSE.2023.3241639",
      "keywords": [
        "binary decompilation",
        "Java native interface",
        "static analysis"
      ],
      "number_of_pages": 17,
      "pages": "3089-3105",
      "publication": {
        "category": "Journal",
        "cite_score": 9.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0098-5589",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 1.713,
        "snip": 3.516,
        "subject_areas": [
          "Software"
        ],
        "title": "IEEE Transactions on Software Engineering"
      },
      "publication_date": "2023-05-01",
      "selected": null,
      "title": "Static Analysis of JNI Programs via Binary Decompilation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10035436",
        "https://dl.acm.org/doi/10.1109/TSE.2023.3241639",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85148475131&origin=inward"
      ]
    },
    {
      "abstract": "Traditional machine learning based malware detection methods often use decompiling techniques or dynamic monitoring techniques to extract the feature representation of malware. This procedure is time consuming and strongly depends on the skills of experts. In addition, malware can be packed or encrypted to evade the analysis of decompiling tools. To solve this issue, we propose a static detection method based on deep learning. We directly extract bytecode file from Android APK file, and convert the bytecode file into a two-dimensional bytecode matrix, then use the deep learning algorithm, convolution neural network (CNN), to train a detection model and apply it to classify malware. CNN can automatically learn features of bytecode file which can be used to recognize malware. The proposed detection model avoids the procedure for analyzing malware features and designing the feature representation of malware. The experimental results show the proposed method is effective to detect malware, especially malware encrypted using polymorphic techniques.",
      "authors": [
        "Ding, Yuxin",
        "Zhang, Xiao",
        "Hu, Jieke",
        "Xu, Wenting"
      ],
      "categories": null,
      "citations": 26,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s12652-020-02196-4",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "6401-6410",
      "publication": {
        "category": "Journal",
        "cite_score": 9.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "18685137",
        "publisher": "Springer Verlag",
        "sjr": 0.905,
        "snip": 1.384,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Journal of Ambient Intelligence and Humanized Computing"
      },
      "publication_date": "2023-05-01",
      "selected": null,
      "title": "Android malware detection method based on bytecode image",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85086366346&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/s12652-020-02196-4.pdf"
      ]
    },
    {
      "abstract": "This paper provides a systematic analysis of existing resource platforms, evaluating their advantages and drawbacks with respect to data privacy protection. To address the privacy and security risks associated with resource platform data, we propose a novel privacy protection algorithm based on chunking disorder. Our algorithm exchanges data within a specific range of chunk size for the position and combines the chunked data with the MD5 value in a differential way, thus ensuring data privacy. To ensure the security of the algorithm, we also discuss the importance of preventing client and server decompilation during its implementation. The findings of our experiments are as follows. Our proposed privacy-preserving algorithm is extremely secure and easy to implement. Our algorithm has a significant avalanche effect, maintaining values of 0.61\u20130.85, with information entropy being maintained at 4.5\u20134.9. This indicates that our algorithm is highly efficient without compromising data security. Furthermore, our algorithm has strong encryption and decryption time stability. The key length can be up to 594 bits, rendering it challenging to decrypt. Compared with the traditional DES algorithm, our algorithm has better security under the same conditions and approaches the levels of security offered by the AES and RC4 algorithms.",
      "authors": [
        "Zhang, Daike",
        "Chen, Junyang",
        "He, Yihui",
        "Lan, Xiaoqing",
        "Chen, Xian",
        "Dong, Chunlin",
        "Li, Jun"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/app13106017",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 4.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2076-3417",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.492,
        "snip": 0.974,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)",
          "Process Chemistry and Technology",
          "Instrumentation",
          "Computer Science Applications",
          "Fluid Flow and Transfer Processes"
        ],
        "title": "Applied Sciences (Switzerland)"
      },
      "publication_date": "2023-05-01",
      "selected": null,
      "title": "A Chunked and Disordered Data Privacy Protection Algorithm: Application to Resource Platform Systems",
      "urls": [
        "https://www.mdpi.com/2076-3417/13/10/6017/pdf?version=1684375939",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85160598422&origin=inward"
      ]
    },
    {
      "abstract": "Compiled binary executables are often the only available artifact in reverse engineering, malware analysis, and software systems maintenance. Unfortunately, the lack of semantic information like variable types makes comprehending binaries difficult. In efforts to improve the comprehensibility of binaries, researchers have recently used machine learning techniques to predict semantic information contained in the original source code. Chen et al. implemented DIRTY, a Transformer-based Encoder-Decoder architecture capable of augmenting decompiled code with variable names and types by leveraging decompiler output tokens and variable size information. Chen et al. were able to demonstrate a substantial increase in name and type extraction accuracy on Hex-Rays decompiler outputs compared to existing static analysis and AI-based techniques. We extend the original DIRTY results by re-training the DIRTY model on a dataset produced by the open-source Ghidra decompiler. Although Chen et al. concluded that Ghidra was not a suitable decompiler candidate due to its difficulty in parsing and incorporating DWARF symbols during analysis, we demonstrate that straightforward parsing of variable data generated by Ghidra results in similar retyping performance. We hope this work inspires further interest and adoption of the Ghidra decompiler for use in research projects.",
      "authors": [
        "Cao, Kevin",
        "Leach, Kevin"
      ],
      "categories": null,
      "citations": null,
      "comments": "In The 31st International Conference on Program Comprehension(ICPC\n  2023 RENE)",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-04-07",
      "selected": null,
      "title": "Revisiting Deep Learning for Variable Type Recovery",
      "urls": [
        "http://arxiv.org/pdf/2304.03854.pdf",
        "http://arxiv.org/pdf/2304.03854v1",
        "http://arxiv.org/abs/2304.03854v1"
      ]
    },
    {
      "abstract": "Malware detection on binary executables provides a high availability to even binaries which are not disassembled or decompiled. However, a binary-level approach could cause ambiguity problems. In this paper, we propose a new feature engineering technique that use minimal knowledge about the internal layout on a binary. The proposed feature avoids the ambiguity problems by integrating the information about the layout with structural entropy. The experimental results show that our feature improves accuracy and F1-score by 3.3% and 0.07, respectively, on a CNN based malware detector with realistic benign and malicious samples.",
      "authors": [
        "Kim, Jeongwoo",
        "Cho, Eun-Sun",
        "Paik, Joon-Young"
      ],
      "categories": null,
      "citations": null,
      "comments": "2pages, no figures, This manuscript was presented in the poster\n  session of The Annual Computer Security Applications Conference (ACSAC) 2020",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-04-05",
      "selected": null,
      "title": "Feature Engineering Using File Layout for Malware Detection",
      "urls": [
        "http://arxiv.org/abs/2304.02260v1",
        "http://arxiv.org/pdf/2304.02260v1",
        "http://arxiv.org/pdf/2304.02260.pdf"
      ]
    },
    {
      "abstract": "The decompiler is one of the most common tools for examining executable binaries without the corresponding source code. It transforms binaries into high-level code, reversing the compilation process. Unfortunately, decompiler output is far from readable because the decompilation process is often incomplete. State-of-the-art techniques use machine learning to predict missing information like variable names. While these approaches are often able to suggest good variable names in context, no existing work examines how the selection of training data influences these machine learning models. We investigate how data provenance and the quality of training data affect performance, and how well, if at all, trained models generalize across software domains. We focus on the variable renaming problem using one such machine learning model, DIRE. We first describe DIRE in detail and the accompanying technique used to generate training data from raw code. We also evaluate DIRE\u2019s overall performance without respect to data quality. Next, we show how training on more popular, possibly higher quality code (measured using GitHub stars) leads to a more generalizable model because popular code tends to have more diverse variable names. Finally, we evaluate how well DIRE predicts domain-specific identifiers, propose a modification to incorporate domain information, and show that it can predict identifiers in domain-specific scenarios 23% more frequently than the original DIRE model.",
      "authors": [
        "Luke Dramko",
        "Jeremy Lacomis",
        "Pengcheng Yin",
        "Ed Schwartz",
        "Miltiadis Allamanis",
        "Graham Neubig",
        "Bogdan Vasilescu",
        "Claire Le Goues"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3546946",
      "keywords": [
        "Machine learning",
        "data provenance",
        "decompilation"
      ],
      "number_of_pages": 34,
      "pages": "1-34",
      "publication": {
        "category": "Journal",
        "cite_score": 7.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1049-331X",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 1.198,
        "snip": 2.199,
        "subject_areas": [
          "Software"
        ],
        "title": "ACM Transactions on Software Engineering and Methodology"
      },
      "publication_date": "2023-03-29",
      "selected": null,
      "title": "DIRE and its Data: Neural Decompiled Variable Renamings with Respect to Software Class",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3546946",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85153786327&origin=inward"
      ]
    },
    {
      "abstract": "Manually writing parallel programs is difficult and error-prone.  \nAutomatic parallelization could address this issue, but profitability can be limited by not having facts known only to the programmer.  \nA parallelizing compiler that collaborates with the programmer can increase the coverage and performance of parallelization while reducing the errors and overhead associated with manual parallelization.  \nUnlike collaboration involving analysis tools that report program properties or make parallelization suggestions to the programmer, decompiler-based collaboration could leverage the strength of existing parallelizing compilers to provide programmers with a natural compiler-parallelized starting point for further parallelization or refinement.  \nDespite this potential, existing decompilers fail to do this because they do not generate portable parallel source code compatible with any compiler of the source language.  \nThis paper presents SPLENDID, an LLVM-IR to C/OpenMP decompiler that enables collaborative parallelization by producing standard parallel OpenMP code.  \nUsing published manual parallelization of the PolyBench benchmark suite as a reference, SPLENDID's collaborative approach produces programs twice as fast as either Polly-based automatic parallelization or manual parallelization alone.  \nSPLENDID's portable parallel code is also more natural than that from existing decompilers, obtaining a 39x higher average BLEU score.",
      "authors": [
        "Zujun Tan",
        "Yebin Chon",
        "Michael Kruse",
        "Johannes Doerfert",
        "Ziyang Xu",
        "Brian Homerding",
        "Simone Campanoni",
        "David I. August"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3582016.3582058",
      "keywords": [
        "collaborative parallelization",
        "decompilation"
      ],
      "number_of_pages": 15,
      "pages": "679-693",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450399180",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 3"
      },
      "publication_date": "2023-03-25",
      "selected": null,
      "title": "SPLENDID: Supporting Parallel LLVM-IR Enhanced Natural Decompilation for Interactive Development",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85159343044&origin=inward",
        "https://dl.acm.org/doi/10.1145/3582016.3582058"
      ]
    },
    {
      "abstract": "Smart contract decompilers, converting smart contract bytecode into smart contract source code, have been used extensively in many scenarios such as binary code analysis, reverse engineering, and security studies. However, existing studies, as well as industrial engineering practices, all assumed that smart contract decompilers are reliable and trustworthy, to generate correct and semantically equivalent source code from binaries. Unfortunately, whether such an assumption truly holds in practice is still unknown.In this paper, we conduct, to the best of our knowledge, the first and most comprehensive large-scale empirical study of smart contract decompilers, to gain an understanding of the reliability, limitations, and remaining research challenges of state-of-the-art smart contract decompilation tools. We first designed and implemented a software prototype SOLINSIGHT, then used it to study 5 state-of-the-art smart contract decompilers. We obtained important findings and insights from empirical results, such as: 1) we proposed 3 root causes leading to decompiler failures; 2) we revealed 2 reasons hurting performance; 3) we identified 3 root causes affecting decompilation effectiveness; 4) we proposed a measurement metric for completeness; and 5) we investigated the resilience of contract decompilers against program transformations. We suggest that: 1) decompiler builders should enhance decompilers in terms of effectiveness, performance, and completeness; and 2) security researchers should select appropriate decompilers based on the suggestions in this study. We believe these findings and suggestions will help decompiler builders, contract developers, and security researchers, by providing better guidelines for contract decompiler studies.",
      "authors": [
        "Xia Liu",
        "Baojian Hua",
        "Yang Wang",
        "Zhizhong Pan"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SANER56733.2023.00011",
      "keywords": [
        "Decompilation",
        "Empirical study",
        "Smart contracts"
      ],
      "number_of_pages": 12,
      "pages": "1-12",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-9631-2",
        "issn": "1534-5351",
        "publisher": "IEEE Computer Society",
        "sjr": 0.358,
        "snip": 1.904,
        "subject_areas": [
          "Software"
        ],
        "title": "Proceedings - 2023 IEEE International Conference on Software Analysis, Evolution and Reengineering, SANER 2023"
      },
      "publication_date": "2023-03-21",
      "selected": null,
      "title": "An Empirical Study of Smart Contract Decompilers",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10123564",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85160560622&origin=inward"
      ]
    },
    {
      "abstract": "With the development of blockchain technology, more and more attention has been paid to the intersection of blockchain and education, and various educational evaluation systems and E-learning systems are developed based on blockchain technology. Among them, Ethereum smart contract is favored by developers for its ``event-triggered\" mechanism for building education intelligent trading systems and intelligent learning platforms. However, due to the immutability of blockchain, published smart contracts cannot be modified, so problematic contracts cannot be fixed by modifying the code in the educational blockchain. In recent years, security incidents due to smart contract vulnerabilities have caused huge property losses, so the detection of smart contract vulnerabilities in educational blockchain has become a great challenge. To solve this problem, this paper proposes a graph neural network (GNN) based vulnerability detection for smart contracts in educational blockchains. Firstly, the bytecodes are decompiled to get the opcode. Secondly, the basic blocks are divided, and the edges between the basic blocks according to the opcode execution logic are added. Then, the control flow graphs (CFG) are built. Finally, we designed a GNN-based model for vulnerability detection. The experimental results show that the proposed method is effective for the vulnerability detection of smart contracts. Compared with the traditional approaches, it can get good results with fewer layers of the GCN model, which shows that the contract bytecode and GCN model are efficient in vulnerability detection.",
      "authors": [
        "Wang, Zhifeng",
        "Wu, Wanxuan",
        "Zeng, Chunyan",
        "Yao, Jialong",
        "Yang, Yang",
        "Xu, Hongmin"
      ],
      "categories": null,
      "citations": null,
      "comments": "8 pages, 8 figures",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-03-08",
      "selected": null,
      "title": "Graph Neural Networks Enhanced Smart Contract Vulnerability Detection of Educational Blockchain",
      "urls": [
        "http://arxiv.org/pdf/2303.04477v1",
        "http://arxiv.org/pdf/2303.04477.pdf",
        "http://arxiv.org/abs/2303.04477v1"
      ]
    },
    {
      "abstract": "Decompilers are indispensable tools in Android malware analysis and app security auditing. Numerous academic works also employ an Android decompiler as the first step in a program analysis pipeline. In such settings, decompilation is frequently regarded as a \u201csolved\u201d problem, in that it is simply expected that source code can be accurately recovered from an app. On the other hand, it is known that, e.g, obfuscation can negatively impact a decompiler\u2019s effectiveness. Therefore, in order to better understand potential failure modes of, e.g., automated analysis pipelines involving decompilation, it is important to characterize the performance of decompilers on both benign and malicious apps. To this end, we have performed what is, to the best of our knowledge, the first large-scale study of Android decompilation failure rates, using three sets of apps; namely, 3,018 open-source apps, 13,601 apps crawled from Google Play, and an existing collection of 24,553 malware samples. In addition to the state-of-the-art Dalvik bytecode decompiler Jadx, we also studied the performance of three popular Java decompilers. Furthermore, this paper also presents the findings from a follow-up study on 54,945 malware apps, where we additionally performed an analysis of the reasons for decompilation failures. Our study revealed that decompilers generally have very low failure rates, and that few failures on benign apps appear to be related to obfuscation. On malware, however, obfuscation appears to be a more prominent cause of failures, although the vast majority of malicious apps could still be fully decompiled by an ensemble of decompilers.",
      "authors": [
        "Karg\u00e9n, Ulf",
        "Mauthe, Noah",
        "Shahmehri, Nahid"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/s10664-022-10281-9",
      "keywords": [
        "Obfuscation",
        "Android",
        "Reverse engineering",
        "Mobile apps",
        "Decompilation",
        "Malware"
      ],
      "number_of_pages": 30,
      "pages": "",
      "publication": {
        "category": "Journal",
        "cite_score": 7.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1382-3256",
        "publisher": "Springer Netherlands",
        "sjr": 1.287,
        "snip": 2.382,
        "subject_areas": [
          "Software"
        ],
        "title": "Empirical Software Engineering"
      },
      "publication_date": "2023-02-20",
      "selected": null,
      "title": "Android decompiler performance on benign and malicious apps: an empirical study",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85148687192&origin=inward",
        "https://dl.acm.org/doi/10.1007/s10664-022-10281-9",
        "https://link.springer.com/content/pdf/10.1007/s10664-022-10281-9.pdf"
      ]
    },
    {
      "abstract": "Manual translation of the algorithms from sequential version to its parallel counterpart is time consuming and can be done only with the specific knowledge of hardware accelerator architecture, parallel programming or programming environment. The automation of this process makes porting the code much easier and faster. The key aspect in this case is how efficient the generated parallel code will be. The paper describes J-Parallelio, the framework for automatic analysis of the bytecode source codes and its parallelisation on multicore processors. The process consists of a few steps. First step is a process of decompilation of JVM and its translation to internal abstract syntax tree, the dependency extraction and memory analysis is performed. Finally, the mapping process is performed which consists of a set of rules responsible for translating the input virtual machine source code to its parallel version. The main novelty is that it can deal with pure Java virtual machine and can generate parallel code for multicore processors. This makes the system portable and it can work with different languages based on JVM after some small modifications. The efficiency of automatically translated source codes were compared with their manually written counterparts on chosen benchmarks.",
      "authors": [
        "Stuglik, Krzysztof",
        "Listkiewicz, Piotr",
        "Kulczyk, Mateusz",
        "Pietron, Marcin"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-02-07",
      "selected": null,
      "title": "J-Parallelio -- automatic parallelization framework for Java virtual machine code",
      "urls": [
        "http://arxiv.org/abs/2303.08746v1",
        "http://arxiv.org/pdf/2303.08746.pdf",
        "http://arxiv.org/pdf/2303.08746v1"
      ]
    },
    {
      "abstract": "Decompilation is currently a widely used tool in reverse engineering and exploit detection in binaries. Ghidra, developed by the National Security Agency, is one of the most popular decompilers. It decompiles binaries to high P-Code, from which the final...",
      "authors": [
        "Naus, Nico",
        "Verbeek, Freek",
        "Walker, Dale",
        "Ravindran, Binoy"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/978-3-031-25803-9_7",
      "keywords": [
        "P-Code",
        "Formal semantics",
        "Decompilation"
      ],
      "number_of_pages": 18,
      "pages": "111-128",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "978-3-031-25802-2",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Verified Software. Theories, Tools and Experiments.: 14th International Conference, VSTTE 2022, Trento, Italy, October 17\u201318, 2022, Revised Selected Papers"
      },
      "publication_date": "2023-02-01",
      "selected": null,
      "title": "A Formal Semantics for\u00a0P-Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85151045477&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-031-25803-9_7.pdf",
        "https://dl.acm.org/doi/10.1007/978-3-031-25803-9_7"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wang Y."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.cose.2022.103023",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 11.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01674048",
        "publisher": "Elsevier Ltd.",
        "sjr": 1.605,
        "snip": 2.232,
        "subject_areas": [
          "Computer Science (all)",
          "Law"
        ],
        "title": "Computers and Security"
      },
      "publication_date": "2023-02-01",
      "selected": null,
      "title": "BinVulDet: Detecting vulnerability in binary program via decompiled pseudo code and BiLSTM-attention",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85145581978&origin=inward"
      ]
    },
    {
      "abstract": "A reflection is a relationship between compiling and decompiling functions.  \nThis concept has been studied as a means to ensure correctness of compilers,  \nin particular, those for languages featuring control effects.  \nWe aim to develop a reflection for algebraic effects and handlers.  \nAs a first step towards this goal, we investigate what we obtain by following  \nthe existing recipe for control operators.  \nWe show that, if we use the simplest CPS translation as the compiling  \nfunction, we can prove most but not all theorems required of a reflection.  \nFrom this result, we identify two conditions of the CPS translation that  \nwould lead to a reflection for effect handlers.",
      "authors": [
        "Youyou Cong",
        "Kenichi Asai"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3571786.3573015",
      "keywords": [
        "CPS translation",
        "algebraic effects and handlers",
        "direct style translation",
        "reflection"
      ],
      "number_of_pages": 11,
      "pages": "55-65",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9798400700118",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "PEPM 2023 - Proceedings of the 2023 ACM SIGPLAN International Workshop on Partial Evaluation and Program Manipulation, co-located with POPL 2023"
      },
      "publication_date": "2023-01-15",
      "selected": null,
      "title": "Towards a Reflection for Effect Handlers",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85147004454&origin=inward",
        "https://dl.acm.org/doi/10.1145/3571786.3573015"
      ]
    },
    {
      "abstract": "Reverse engineering binaries is required to understand and analyse programs for which the source code is unavailable. Decompilers can transform the largely unreadable binaries into a more readable source code-like representation. However, reverse engineering is time-consuming, much of which is taken up by labelling the functions with semantic information. While the automated summarisation of decompiled code can help Reverse Engineers understand and analyse binaries, current work mainly focuses on summarising source code, and no suitable dataset exists for this task. In this work, we extend large pre-trained language models of source code to summarise decompiled binary functions. Furthermore, we investigate the impact of input and data properties on the performance of such models. Our approach consists of two main components; the data and the model. We first build CAPYBARA, a dataset of 214K decompiled function-documentation pairs across various compiler optimisations. We extend CAPYBARA further by generating synthetic datasets and deduplicating the data. Next, we fine-tune the CodeT5 base model with CAPYBARA to create BinT5. BinT5 achieves the state-of-the-art BLEU-4 score of 60.83, 58.82, and 44.21 for summarising source, decompiled, and synthetically stripped decompiled code, respectively. This indicates that these models can be extended to decompiled binaries successfully. Finally, we found that the performance of BinT5 is not heavily dependent on the dataset size and compiler optimisation level. We recommend future research to further investigate transferring knowledge when working with less expressive input formats such as stripped binaries.",
      "authors": [
        "Al-Kaswan, Ali",
        "Ahmed, Toufique",
        "Izadi, Maliheh",
        "Sawant, Anand Ashok",
        "Devanbu, Premkumar",
        "van Deursen, Arie"
      ],
      "categories": null,
      "citations": null,
      "comments": "SANER 2023 Technical Track Camera Ready",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2023-01-04",
      "selected": null,
      "title": "Extending Source Code Pre-Trained Language Models to Summarise Decompiled Binaries",
      "urls": [
        "http://arxiv.org/pdf/2301.01701v2",
        "http://arxiv.org/pdf/2301.01701.pdf",
        "http://arxiv.org/abs/2301.01701v2"
      ]
    },
    {
      "abstract": " Decompilation aims to transform a low-level program language (LPL) (eg., binary file) into its functionally-equivalent high-level program language (HPL) (e.g., C/C++). It is a core technology in software security, especially in vulnerability discovery and malware analysis. In recent years, with the successful application of neural machine translation (NMT) models in natural language processing (NLP), researchers have tried to build neural decompilers by borrowing the idea of NMT. They formulate the decompilation process as a translation problem between LPL and HPL, aiming to reduce the human cost required to develop decompilation tools and improve their generalizability. However, state-of-the-art learning-based decompilers do not cope well with compiler-optimized binaries. Since real-world binaries are mostly compiler-optimized, decompilers that do not consider optimized binaries have limited practical significance. In this paper, we propose a novel learning-based approach named NeurDP, that targets compiler-optimized binaries. NeurDP uses a graph neural network (GNN) model to convert LPL to an intermediate representation (IR), which bridges the gap between source code and optimized binary. We also design an Optimized Translation Unit (OTU) to split functions into smaller code fragments for better translation performance. Evaluation results on datasets containing various types of statements show that NeurDP can decompile optimized binaries with 45.21% higher accuracy than state-of-the-art neural decompilation frameworks.",
      "authors": [
        "Ying Cao",
        "Ruigang Liang",
        "Kai Chen",
        "Peiwei Hu"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "arXiv",
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3564625.3567998",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "508-518",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450397599",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 38th Annual Computer Security Applications Conference"
      },
      "publication_date": "2023-01-03",
      "selected": null,
      "title": "Boosting Neural Networks to Decompile Optimized Binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85144089223&origin=inward",
        "http://dx.doi.org/10.1145/3564625.3567998",
        "https://dl.acm.org/doi/10.1145/3564625.3567998",
        "http://arxiv.org/abs/2301.00969v1",
        "http://arxiv.org/pdf/2301.00969v1"
      ]
    },
    {
      "abstract": "Familiar analysis for malware plays an important role in comprehending the diversity of malicious behaviors and identifying the emerging security threats. Existing studies mainly focus on classifying malware into known families by supervised learning. However, these methods face two main challenges, 1) the lack of a large amount of labeled data and 2) the poor effectiveness in identifying unknown families of malware. To overcome these challenges, we propose a new method called multiple features (MulFC) based on unsupervised learning. In the method, we first leverage a decompiling tool to extract multiple features, including manifest features, application programming interface (API) features, and opcode features. Then, the opcode features are preprocessed to filter out the redundant ones to reduce the calculation cost. After that, we adopt the Jaccard index to calculate the similarities between malware and construct a malware network. Finally, InfoMap is applied to perform the clustering on the basis of the malware network. Overall, MulFC does not require the use of labeled data and can identify unknown families of malware. Experiments are conducted on two datasets for the performance evaluation of MulFC. The experimental results show that MulFC achieves 0.810\u00a0in terms of normalized mutual information, 0.576\u00a0in terms of adjusted rand index, 0.620\u00a0in terms of the Fowlkes\u2013Mallows index, and 0.805\u00a0in terms of V-measure on average, and outperforms the state-of-the-art baseline method by 0.060, 0.054, 0.038, and 0.065, respectively.",
      "authors": [
        "Xin Chen",
        "Dongjin Yu",
        "Xinxin Cai",
        "He Jiang",
        "Haihua Yu"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TR.2023.3332090",
      "keywords": [
        "malware family clustering",
        "multiple features",
        "InfoMap",
        "unsupervised learning",
        "Android malware"
      ],
      "number_of_pages": 14,
      "pages": "1-14",
      "publication": {
        "category": "Journal",
        "cite_score": 10.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1558-1721",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 1.296,
        "snip": 2.072,
        "subject_areas": [
          "Safety, Risk, Reliability and Quality",
          "Electrical and Electronic Engineering"
        ],
        "title": "IEEE Transactions on Reliability"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "Android Malware Family Clustering Based on Multiple Features",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85179059020&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10334519"
      ]
    },
    {
      "abstract": "Android has been a constant target of cybercriminals that try to attack one of the most used operating systems, commonly using malicious applications (denominated malware) that, once installed on a device, can harm users in several ways. Existing malware detection solutions are usually invasive as they obtain classification features by performing reverse engineering, decompilation, or disassembly of the analyzed application, which infringes licenses and terms of use of applications. In addition, these solutions often employ a single machine learning (ML) model to detect various types of malware, resulting in several false alarms. In this context, we propose an approach to detect Android malware consisting of a set of specific-type detectors in which each one performs a multi-stage analysis, based on rules and ML techniques, in different phases of the application cycle (before and after its installation). Our approach also differs from state-of-the-art solutions by being non-invasive, since it leverages a process to obtain application\u2019s features that does not infringe licenses and terms of use of applications. In addition, according to experiments performed on a real Android smartphone, our proposal presents the following additional advantages over state-of-the-art solutions: a more efficient process to classify applications that is three times faster and requires ten times less CPU usage in some cases (saving device energy); and a better detection performance, with higher balanced accuracy, nine times less false positive cases, and ten times less false negative cases.",
      "authors": [
        "Leonardo da Costa",
        "Vitor Moia"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ACCESS.2023.3296606",
      "keywords": [
        "machine learning",
        "non-invasive feature extraction",
        "malware detection",
        "Android",
        "multi-stage analysis"
      ],
      "number_of_pages": 18,
      "pages": "73127-73144",
      "publication": {
        "category": "Journal",
        "cite_score": 9.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2169-3536",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.926,
        "snip": 1.422,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)",
          "Computer Science (all)"
        ],
        "title": "IEEE Access"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "A Lightweight and Multi-Stage Approach for Android Malware Detection Using Non-Invasive Machine Learning Techniques",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10186242",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85165301083&origin=inward"
      ]
    },
    {
      "abstract": "In this paper, we propose a method of vulnerability mining using data association rules mining. This method first decompiles the target file, build an abstract syntax tree (AST) of the function on the basis of decompilation, design an algorithm to extract the reverse...",
      "authors": [
        "Jin, Xin",
        "Li, Hongyan",
        "Liu, Hengwang",
        "Wang, Wen",
        "Sun, Xin"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-99-1157-8_55",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "455-462",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "978-3-030-34080-3",
        "issn": "23674512",
        "publisher": "Springer International Publishing AG",
        "sjr": 0.125,
        "snip": 0.104,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Media Technology",
          "Information Systems",
          "Computer Networks and Communications",
          "Computer Science Applications"
        ],
        "title": "International Conference on Intelligent Data Communication Technologies and Internet of Things"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "Intelligent Vulnerability Association Algorithm Based on Association Rule Mining",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-981-99-1157-8_55.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85152045382&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Pulasthi Dhananjaya Gunawardhana L.K."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/I2CT57861.2023.10126169",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9798350334012",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2023 IEEE 8th International Conference for Convergence in Technology, I2CT 2023"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "Low Latency Requirement and Video Usage in Sri Lanka",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85161338452&origin=inward"
      ]
    },
    {
      "abstract": "The popularity of the Android platform has led to an explosion in malware. The current research on Android malware mainly focuses on malware detection or malware family classification. These studies need to extract a large number of features, which consumes a lot of manpower and material resources. Moreover, some malware use obfuscation to evade decompiler tools extracting features. To address these problems, we propose ImageDroid, a method based on the image format of Android applications that can not only detect and classify malware without prior knowledge but also detect the obfuscated malware. Furthermore, we utilize the Grad-CAM interpretable mechanism of the deep learning model to automatically label the image that play a key role in determining maliciousness in a visual way. We evaluate ImageDroid over 10,000 Android applications. Experimental results show that the accuracy of malicious detection and multifamily classification achieve 97.2&#x0025; and 95.1&#x0025;, respectively, and the detection accuracy of obfuscated malware achieves 94.6&#x0025;.",
      "authors": [
        "Liu, Pengfei",
        "Wang, Weiping",
        "Zhang, Shigeng",
        "Song, Hong"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "https://doi.org/10.1155/2023/5393890",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19390114",
        "publisher": "Hindawi Limited",
        "sjr": 0.494,
        "snip": 0.785,
        "subject_areas": [
          "Computer Networks and Communications",
          "Information Systems"
        ],
        "title": "Security and Communication Networks"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "ImageDroid: Using Deep Learning to Efficiently Detect Android Malware and Automatically Mark Malicious Features",
      "urls": [
        "https://downloads.hindawi.com/journals/scn/2023/5393890.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85153276075&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lebedev R.K."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.17223/20710410/61/6",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "104-120",
      "publication": {
        "category": "Journal",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "20710410",
        "publisher": "Tomsk State University",
        "sjr": 0.221,
        "snip": 0.505,
        "subject_areas": [
          "Signal Processing",
          "Computational Theory and Mathematics",
          "Discrete Mathematics and Combinatorics",
          "Theoretical Computer Science",
          "Applied Mathematics"
        ],
        "title": "Prikladnaya Diskretnaya Matematika"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "USING X86 MODE SWITCHING FOR PROGRAM CODE PROTECTION",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85179049819&origin=inward"
      ]
    },
    {
      "abstract": "Manual translation of the algorithms from sequential version to its parallel counterpart is time consuming and can be done only with the specific knowledge of hardware accelerator architecture, parallel programming or programming environment. The automation of this...",
      "authors": [
        "Listkiewicz, Piotr",
        "Stuglik, Krzysztof",
        "Kulczyk, Mateusz",
        "Pietron, Marcin"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-031-37963-5_22",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "307-320",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "9783031379628",
        "issn": "23673370",
        "publisher": "Springer International Publishing AG",
        "sjr": 0.151,
        "snip": 0.19,
        "subject_areas": [
          "Signal Processing",
          "Computer Networks and Communications",
          "Control and Systems Engineering"
        ],
        "title": "International Conference on Ubiquitous Computing and Ambient Intelligence"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "J-Parallelio: Automatic Parallelization Framework for\u00a0Java Virtual Machine",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85172178261&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-031-37963-5_22.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Al-Kaswan A."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/SANER56733.2023.00033",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "260-271",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781665452786",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2023 IEEE International Conference on Software Analysis, Evolution and Reengineering, SANER 2023"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "Extending Source Code Pre-Trained Language Models to Summarise Decompiled Binarie",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85149458183&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Liu Z."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 18,
      "pages": "7357-7374",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781713879497",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "32nd USENIX Security Symposium, USENIX Security 2023"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "Decompiling x86 Deep Neural Network Executables",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85176376734&origin=inward"
      ]
    },
    {
      "abstract": "Despite the large number of approaches proposed for detecting malicious applications targeting platforms such as Android, malware continuously evolves in order to avoid its detection and reach the users. Likewise, malware detection engines are continuously improved,...",
      "authors": [
        "Garc\u00eda-Soto, Eva",
        "Mart\u00edn, Alejandro",
        "Huertas-Tato, Javier",
        "Camacho, David"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-031-21333-5_105",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "1055-1060",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "9783031379628",
        "issn": "23673370",
        "publisher": "Springer International Publishing AG",
        "sjr": 0.151,
        "snip": 0.19,
        "subject_areas": [
          "Signal Processing",
          "Computer Networks and Communications",
          "Control and Systems Engineering"
        ],
        "title": "International Conference on Ubiquitous Computing and Ambient Intelligence"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "Android Malware Detection Through a\u00a0Pre-trained Model for\u00a0Code Understanding",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-031-21333-5_105.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85145083410&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "5th International Conference on Science of Cyber Security, SciSec 2023",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85178515813&origin=inward"
      ]
    },
    {
      "abstract": "Digital Library",
      "authors": [
        "Jace Kline",
        "Prasad Kulkarni"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.5220/0011872600003405",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "228-239",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9789897586248",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "9th International Conference on Information Systems Security and Privacy"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "A Framework for Assessing Decompiler Inference Accuracy of Source-Level Program Constructs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85176364248&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Horny\u00e1k O."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.22503/inftars.XXIII.2023.1.6",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "100-116",
      "publication": {
        "category": "Journal",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "15878694",
        "publisher": "Gondolat Kiado",
        "sjr": 0.202,
        "snip": 0.166,
        "subject_areas": [
          "Communication"
        ],
        "title": "Informacios Tarsadalom"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "A case study for detecting software similarity",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85163991073&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Borrello P."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781713883999",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "17th IEEE Workshop on Offensive Technologies, WOOT 2023, co-located with IEEE S and P 2023"
      },
      "publication_date": "2023-01-01",
      "selected": null,
      "title": "CustomProcessingUnit: Reverse Engineering and Customization of Intel Microcode",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85180743127&origin=inward"
      ]
    },
    {
      "abstract": "The problem of reversing the compilation process, decompilation, is an\nimportant tool in reverse engineering of computer software. Recently,\nresearchers have proposed using techniques from neural machine translation to\nautomate the process in decompilation. Although such techniques hold the\npromise of targeting a wider range of source and assembly languages, to date\nthey have primarily targeted C code. In this paper we argue that existing\nneural decompilers have achieved higher accuracy at the cost of requiring\nlanguage-specific domain knowledge such as tokenizers and parsers to build an\nabstract syntax tree (AST) for the source language, which increases the\noverhead of supporting new languages. We explore a different tradeoff that, to\nthe extent possible, treats the assembly and source languages as plain text,\nand show that this allows us to build a decompiler that is easily retargetable\nto new languages. We evaluate our prototype decompiler, Beyond The C (BTC), on\nGo, Fortran, OCaml, and C, and examine the impact of parameters such as\ntokenization and training data selection on the quality of decompilation,\nfinding that it achieves comparable decompilation results to prior work in\nneural decompilation with significantly less domain knowledge. We will release\nour training data, trained decompilation models, and code to help encourage\nfuture research into language-agnostic decompilation.",
      "authors": [
        "Iman Hosseini",
        "Brendan Dolan-Gavitt"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": "10.14722/bar.2022.23009",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2022-12-17",
      "selected": null,
      "title": "Beyond the C: Retargetable Decompilation using Neural Machine Translation",
      "urls": [
        "http://dx.doi.org/10.14722/bar.2022.23009",
        "http://arxiv.org/abs/2212.08950v1",
        "http://arxiv.org/pdf/2212.08950v1"
      ]
    },
    {
      "abstract": "Ethereum smart contracts face serious security problems, which not only cause huge economic losses, but also destroy the Ethereum credit system. To solve this problem, code obfuscation techniques are applied to smart contracts to improve their complexity and security. However, the current source code obfuscation methods have insufficient anti-decompilation ability. Therefore, we propose a novel bytecode obfuscation approach called BOSC based on four kinds of bytecode obfuscation techniques, which is directed at solidity. The experimental results show that, after the bytecode obfuscation, the failure rate of decompilation tools is over 99% and only a small amount of gas is consumed.",
      "authors": [
        "Qifan Yu",
        "Pengcheng Zhang",
        "Hai Dong",
        "Yan Xiao",
        "Shunhui Ji"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/APSEC57359.2022.00083",
      "keywords": [
        "Ethereum",
        "Bytecode Obfusca-tion",
        "Smart Contract"
      ],
      "number_of_pages": 2,
      "pages": "566-567",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-5538-1",
        "issn": "1530-1362",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Asia-Pacific Software Engineering Conference, APSEC"
      },
      "publication_date": "2022-12-06",
      "selected": null,
      "title": "Bytecode Obfuscation for Smart Contracts",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10043270",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85149172959&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wang Z."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1142/S0218126622502978",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "02181266",
        "publisher": "World Scientific",
        "sjr": 0.308,
        "snip": 0.635,
        "subject_areas": [
          "Hardware and Architecture",
          "Electrical and Electronic Engineering"
        ],
        "title": "Journal of Circuits, Systems and Computers"
      },
      "publication_date": "2022-11-30",
      "selected": null,
      "title": "Deep Learning-Based Multi-Classification for Malware Detection in IoT",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85142695714&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mittal R."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3550355.3552396",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "55-65",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450394666",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 25th ACM/IEEE International Conference on Model Driven Engineering Languages and Systems, MODELS 2022"
      },
      "publication_date": "2022-10-23",
      "selected": null,
      "title": "Solving the instance model-view update problem in AADL",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85141868797&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhao M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.14135/j.cnki.1006-3080.20210517005",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "677-684",
      "publication": {
        "category": "Journal",
        "cite_score": 0.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10063080",
        "publisher": "East China University of Science and Technology",
        "sjr": 0.118,
        "snip": 0.082,
        "subject_areas": [
          "Chemical Engineering (all)",
          "Materials Chemistry",
          "Engineering (all)"
        ],
        "title": "Huadong Ligong Daxue Xuebao/Journal of East China University of Science and Technology"
      },
      "publication_date": "2022-10-20",
      "selected": null,
      "title": "Malware Detection Method Based on LSTM-SVM Model",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85147105844&origin=inward"
      ]
    },
    {
      "abstract": "While further research is required to more assertively say if this type of static analysis is viable, our results point in a promising direction with 163 applications, approximately 69%, containing the same number of detected patterns in both source code and the release APK.",
      "authors": [
        "Nelson Greg\u00f3rio",
        "Jo\u00e3o Paulo Fernandes",
        "Jo\u00e3o Bispo",
        "S\u00e9rgio Medeiros"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3561320.3561328",
      "keywords": [
        "mobile",
        "decompiler",
        "compilers",
        "static analysis",
        "energy efficiency",
        "metaprogramming",
        "android",
        "code patterns"
      ],
      "number_of_pages": 9,
      "pages": "50-58",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450397445",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the XXVI Brazilian Symposium on Programming Languages"
      },
      "publication_date": "2022-10-06",
      "selected": null,
      "title": "E-APK: Energy Pattern Detection in Decompiled Android Applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85139838867&origin=inward",
        "https://dl.acm.org/doi/10.1145/3561320.3561328"
      ]
    },
    {
      "abstract": "Due to their widespread use on heterogeneous hardware devices, deep learning (DL) models are compiled into executables by DL compilers to fully leverage low-level hardware primitives. This approach allows DL computations to be undertaken at low cost across a variety of computing platforms, including CPUs, GPUs, and various hardware accelerators. We present BTD (Bin to DNN), a decompiler for deep neural network (DNN) executables. BTD takes DNN executables and outputs full model specifications, including types of DNN operators, network topology, dimensions, and parameters that are (nearly) identical to those of the input models. BTD delivers a practical framework to process DNN executables compiled by different DL compilers and with full optimizations enabled on x86 platforms. It employs learning-based techniques to infer DNN operators, dynamic analysis to reveal network architectures, and symbolic execution to facilitate inferring dimensions and parameters of DNN operators. Our evaluation reveals that BTD enables accurate recovery of full specifications of complex DNNs with millions of parameters (e.g., ResNet). The recovered DNN specifications can be re-compiled into a new DNN executable exhibiting identical behavior to the input executable. We show that BTD can boost two representative attacks, adversarial example generation and knowledge stealing, against DNN executables. We also demonstrate cross-architecture legacy code reuse using BTD, and envision BTD being used for other critical downstream tasks like DNN security hardening and patching.",
      "authors": [
        "Liu, Zhibo",
        "Yuan, Yuanyuan",
        "Wang, Shuai",
        "Xie, Xiaofei",
        "Ma, Lei"
      ],
      "categories": null,
      "citations": null,
      "comments": "The extended version of a paper to appear in the Proceedings of the\n  32nd USENIX Security Symposium, 2023, (USENIX Security '23), 25 pages",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2022-10-03",
      "selected": null,
      "title": "Decompiling x86 Deep Neural Network Executables",
      "urls": [
        "http://arxiv.org/pdf/2210.01075v2",
        "http://arxiv.org/pdf/2210.01075.pdf",
        "http://arxiv.org/abs/2210.01075v2"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Liu Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.11959/j.issn.1000-436x.2022171",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "169-180",
      "publication": {
        "category": "Journal",
        "cite_score": 2.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1000436X",
        "publisher": "Posts &Telecom Press",
        "sjr": 0.239,
        "snip": 0.567,
        "subject_areas": [
          "Signal Processing",
          "Computer Networks and Communications",
          "Information Systems"
        ],
        "title": "Tongxin Xuebao/Journal on Communications"
      },
      "publication_date": "2022-09-25",
      "selected": null,
      "title": "Adversarial training driven malicious code detection enhancement method",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85140138877&origin=inward"
      ]
    },
    {
      "abstract": "Computer programs are executed continuously in a certain relatively fixed order of instructions. Replacing these instructions with another more complex order or with different instructions with the same meaning without changing the result of the program will change the logic of the original instructions without affecting the result of the operation, which is the core principle of code obfuscation. In the compilation process, before the compiler compiles the code into the target machine code, it will transform the code into a kind of intermediate code, and then generate the target code after Control Flow Flattening and string encryption obfuscation of the intermediate code, which will make the decompilation work more difficult, thus realizing a code obfuscation system, and through some test cases, the effectiveness and feasibility of the system is demonstrated.",
      "authors": [
        "Di Lv",
        "Liang Zhao",
        "Bin Chen"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IIoTBDSC57192.2022.00039",
      "keywords": [
        "Control Flow Flattening obfuscation",
        "encryption process",
        "String encryption",
        "code obfuscation",
        "code safety"
      ],
      "number_of_pages": 5,
      "pages": "163-167",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-5456-8",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2022 International Conference on Industrial IoT, Big Data and Supply Chain, IIoTBDSC 2022"
      },
      "publication_date": "2022-09-23",
      "selected": null,
      "title": "Research Based on LLVM Code Obfuscation Technology",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85151928723&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10077138"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Shanmugam P."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/cpe.7044",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 4.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "15320626",
        "publisher": "John Wiley and Sons Ltd",
        "sjr": 0.456,
        "snip": 0.789,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Theoretical Computer Science",
          "Computer Networks and Communications",
          "Computer Science Applications",
          "Software"
        ],
        "title": "Concurrency and Computation: Practice and Experience"
      },
      "publication_date": "2022-08-30",
      "selected": null,
      "title": "Electro search optimization based long short-term memory network for mobile malware detection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85131083489&origin=inward"
      ]
    },
    {
      "abstract": "Malware detection is of great significance for maintaining the security of information systems. Malware obfuscation techniques and malware variants are increasingly emerging, but their samples and API (application programming interface) sequences are difficult to obtain. This poses difficulties for the development of malware variant detection models. To address this issue in this paper, we first generated a malware variant dataset using the obfuscation technique based on the disassembly and decompilation of malware. Then, an API call dataset of these malware variants was constructed through sandboxing. Compared to similar work, the malware variants and their obfuscated API call sequences generated in this paper were all runnable. After that, taking a public API call sequence dataset of obfuscation-free malware as input, a BERT (bidirectional encoder representation from transformers) pretrained model for malware detection was constructed. To enhance the ability of this pretrained model to handle obfuscation and variants, in this paper, we used adversarial training to improve the robustness and generalization of the detection model under obfuscation. As the experimental results show, the proposed scheme can improve the classification performance of malware variants under obfuscation. The accuracy of the malware variant classification was close to that of the unobfuscated case.",
      "authors": [
        "Lu, Faming",
        "Cai, Zhaoyang",
        "Lin, Zedong",
        "Bao, Yunxia",
        "Tang, Mengfan"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/app12157546",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 4.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2076-3417",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.492,
        "snip": 0.974,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)",
          "Process Chemistry and Technology",
          "Instrumentation",
          "Computer Science Applications",
          "Fluid Flow and Transfer Processes"
        ],
        "title": "Applied Sciences (Switzerland)"
      },
      "publication_date": "2022-08-01",
      "selected": null,
      "title": "Research on the Construction of Malware Variant Datasets and Their Detection Method",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85136956280&origin=inward",
        "https://www.mdpi.com/2076-3417/12/15/7546/pdf?version=1658923858"
      ]
    },
    {
      "abstract": "Industrial control systems (ICS) are essential for safe and efficient operations of critical infrastructures such as power grids, pipelines, and water treatment facilities. Attackers target ICS, mainly programmable logic controllers (PLC), to sabotage underlying infrastructure. A PLC controls a physical process through connected sensors and actuators. It runs a control-logic program that specifies monitoring and controlling a physical process and is a common target of cyberattacks. A vendor-provided proprietary engineering software is typically used to investigate the infected control logic. This paper shows that an attacker can use control-logic obfuscation as an anti-forensics technique to hinder the investigations and incident response. The control-logic obfuscation subverts the engineering software\u2019s decompilation function; therefore, we call it a denial-of-decompilation attack. The attack exploits a fundamental design principle of creating compiled control logic in engineering software, thereby affecting the engineering software of multiple vendors in the industry.",
      "authors": [
        "Nauman Zubair",
        "Adeen Ayub",
        "Hyunguk Yoo",
        "Irfan Ahmed"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CSR54599.2022.9850326",
      "keywords": [
        "digital forensics",
        "industrial control system (ICS)",
        "Control-logic attacks",
        "programmable logic controller (PLC)"
      ],
      "number_of_pages": 6,
      "pages": "227-232",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-9953-8",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2022 IEEE International Conference on Cyber Security and Resilience, CSR 2022"
      },
      "publication_date": "2022-07-27",
      "selected": null,
      "title": "Control Logic Obfuscation Attack in Industrial Control Systems",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85137341800&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9850326"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1093/grurint/ikac010",
      "keywords": [],
      "number_of_pages": 1,
      "pages": "672",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "26328623",
        "publisher": "Oxford University Press",
        "sjr": 0.456,
        "snip": 0.789,
        "subject_areas": [
          "Law"
        ],
        "title": "GRUR International"
      },
      "publication_date": "2022-07-01",
      "selected": null,
      "title": "Decompilation of a Computer Program in Order to Correct Errors Affecting Its Operation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85159790517&origin=inward"
      ]
    },
    {
      "abstract": "In this paper, we leverage low-level compiler intermediate representations (IR) to improve code translation. Traditional transpilers rely on syntactic information and handcrafted rules, which limits their applicability and produces unnatural-looking code. Applying neural machine translation (NMT) approaches to code has successfully broadened the set of programs on which one can get a natural-looking translation. However, they treat the code as sequences of text tokens, and still do not differentiate well enough between similar pieces of code which have different semantics in different languages. The consequence is low quality translation, reducing the practicality of NMT, and stressing the need for an approach significantly increasing its accuracy. Here we propose to augment code translation with IRs, specifically LLVM IR, with results on the C++, Java, Rust, and Go languages. Our method improves upon the state of the art for unsupervised code translation, increasing the number of correct translations by 11% on average, and up to 79% for the Java -> Rust pair with greedy decoding. We extend previous test sets for code translation, by adding hundreds of Go and Rust functions. Additionally, we train models with high performance on the problem of IR decompilation, generating programming source code from IR, and study using IRs as intermediary pivot for translation.",
      "authors": [
        "Szafraniec, Marc",
        "Roziere, Baptiste",
        "Leather, Hugh",
        "Charton, Francois",
        "Labatut, Patrick",
        "Synnaeve, Gabriel"
      ],
      "categories": null,
      "citations": null,
      "comments": "9 pages",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2022-06-30",
      "selected": null,
      "title": "Code Translation with Compiler Representations",
      "urls": [
        "http://arxiv.org/abs/2207.03578v5",
        "http://arxiv.org/pdf/2207.03578v5",
        "http://arxiv.org/pdf/2207.03578.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Kim T."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3498361.3538938",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "69-83",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450391856",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "MobiSys 2022 - Proceedings of the 2022 20th Annual International Conference on Mobile Systems, Applications and Services"
      },
      "publication_date": "2022-06-27",
      "selected": null,
      "title": "Reverse engineering and retrofitting robotic aerial vehicle control firmware using dispatch",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85134048240&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Verbeek F."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3519939.3523702",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "934-949",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450392655",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)"
      },
      "publication_date": "2022-06-09",
      "selected": null,
      "title": "Formally verified lifting of C-compiled x86-64 binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85132251848&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ullah F."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/ett.3791",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Transactions on Emerging Telecommunications Technologies"
      },
      "publication_date": "2022-06-01",
      "selected": null,
      "title": "Detection of clone scammers in Android markets using IoT-based edge computing",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85075075148&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mantovani A."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3488932.3497764",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "602-615",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450391405",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ASIA CCS 2022 - Proceedings of the 2022 ACM Asia Conference on Computer and Communications Security"
      },
      "publication_date": "2022-05-30",
      "selected": null,
      "title": "The Convergence of Source Code and Binary Vulnerability Discovery - A Case Study",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85133167123&origin=inward"
      ]
    },
    {
      "abstract": "Binary lifters convert executables into an intermediate representation (IR) of a compiler framework. The recovered IR code is generally deemed \u201canalysis friendly,\u201d bridging low-level code analysis with well-established compiler infrastructures. With years of development, binary lifters are becoming increasingly popular for use in various security, systems, and software (re)-engineering applications. Recent studies have also reported highly promising results that suggest binary lifters can generate LLVM IR code with correct functionality, even for complex cases.This paper conducts an in-depth study of binary lifters from an orthogonal and highly demanding perspective. We demystify the \u201cexpressiveness\u201d of binary lifters, and reveal how well the lifted LLVM IR code can support critical downstream applications in security analysis scenarios. To do so, we generate two pieces of LLVM IR code by compiling C/C++ programs or by lifting the corresponding executables. We then feed these two pieces of LLVM IR code to three keystone downstream applications (pointer analysis, discriminability analysis, and decompilation) and determine whether inconsistent analysis results are generated. We study four popular static and dynamic LLVM IR lifters that were developed by the industry or academia from a total of 252,063 executables generated by various compilers and optimizations and on different architectures. Our findings show that modern binary lifters afford IR code that is highly suitable for discriminability analysis and decompilation, and suggest that such binary lifters can be applied in common similarity- or code comprehension-based security analysis (e.g., binary diffing). However, the lifted IR code appears unsuited to rigorous static analysis (e.g., pointer analysis). To obtain a more comprehensive view of the utility of binary lifters, we also compare the performance of lifter-enabled approaches with that of binary-only tools in three security tasks, i.e., sanitization, binary diffing, and C decompilation. We summarize our findings and make suggestions for the correct use and further enhancement of binary lifters. We also explored practical ways to enhance the accuracy of pointer analysis using lifted IR code, by using and augmenting Debin, a tool for predicting debug information.",
      "authors": [
        "Zhibo Liu",
        "Yuanyuan Yuan",
        "Shuai Wang",
        "Yuyan Bao"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SP46214.2022.9833799",
      "keywords": [
        "reverse-engineering",
        "software-security"
      ],
      "number_of_pages": 20,
      "pages": "1100-1119",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-9337-6",
        "issn": "1081-6011",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - IEEE Symposium on Security and Privacy"
      },
      "publication_date": "2022-05-22",
      "selected": null,
      "title": "SoK: Demystifying Binary Lifters Through the Lens of Downstream Applications",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9833799",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85135909424&origin=inward"
      ]
    },
    {
      "abstract": "Analyzing third-party software such as malware or firmware is a crucial task\nfor security analysts. Although various approaches for automatic analysis exist\nand are the subject of ongoing research, analysts often have to resort to\nmanual static analysis to get a deep understanding of a given binary sample.\nSince the source code of encountered samples is rarely available, analysts\nregularly employ decompilers for easier and faster comprehension than analyzing\na binary's disassembly.\n  In this paper, we introduce our decompilation approach dewolf. We developed a\nvariety of improvements over the previous academic state-of-the-art decompiler\nand some novel algorithms to enhance readability and comprehension, focusing on\nmanual analysis. To evaluate our approach and to obtain a better insight into\nthe analysts' needs, we conducted three user surveys. The results indicate that\ndewolf is suitable for malware comprehension and that its output quality\nnoticeably exceeds Ghidra and Hex-Rays in certain aspects. Furthermore, our\nresults imply that decompilers aiming at manual analysis should be highly\nconfigurable to respect individual user preferences. Additionally, future\ndecompilers should not necessarily follow the unwritten rule to stick to the\ncode-structure dictated by the assembly in order to produce readable output. In\nfact, the few cases where dewolf already cracks this rule lead to its results\nconsiderably exceeding other decompilers. We publish a prototype implementation\nof dewolf and all survey results on GitHub.",
      "authors": [
        "Steffen Enders",
        "Eva-Maria C. Behner",
        "Niklas Bergmann",
        "Mariia Rybalka",
        "Elmar Padilla",
        "Er Xue Hui",
        "Henry Low",
        "Nicholas Sim"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": "10.14722/bar.2023.23001",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2022-05-13",
      "selected": null,
      "title": "dewolf: Improving Decompilation by leveraging User Surveys",
      "urls": [
        "http://arxiv.org/abs/2205.06719v1",
        "http://arxiv.org/pdf/2205.06719v1",
        "http://dx.doi.org/10.14722/bar.2023.23001"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ullah F."
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3418206",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 8.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "15335399",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 1.21,
        "snip": 1.298,
        "subject_areas": [
          "Computer Networks and Communications"
        ],
        "title": "ACM Transactions on Internet Technology"
      },
      "publication_date": "2022-05-01",
      "selected": null,
      "title": "IoT-based Cloud Service for Secured Android Markets using PDG-based Deep Learning Classification",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85130317059&origin=inward"
      ]
    },
    {
      "abstract": "Elipmoc improves over all notable past decompilers, including its predecessor, Gigahorse, and the state-of-the-art industrial tool, Panoramix, integrated into the primary Ethereum blockchain explorer, Etherscan. Elipmoc produces decompiled contracts with fully resolved operands at a rate of 99.5% (compared to 62.8% for Gigahorse), and achieves much higher completeness in code decompilation than Panoramix\u2014e.g., up to 67% more coverage of external call statements\u2014while being over 5x faster. Elipmoc has been the enabler for recent (independent) discoveries of several exploitable vulnerabilities on popular protocols, over funds in the many millions of dollars.",
      "authors": [
        "Neville Grech",
        "Sifis Lagouvardos",
        "Ilias Tsatiris",
        "Yannis Smaragdakis"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3527321",
      "keywords": [
        "Smart Contracts",
        "Program Analysis",
        "Datalog",
        "Ethereum",
        "Security",
        "Decompilation",
        "Blockchain"
      ],
      "number_of_pages": 27,
      "pages": "1-27",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM on Programming Languages"
      },
      "publication_date": "2022-04-29",
      "selected": null,
      "title": "Elipmoc: advanced decompilation of Ethereum smart contracts",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85129727844&origin=inward",
        "https://dl.acm.org/doi/10.1145/3527321"
      ]
    },
    {
      "abstract": "Path sums are a convenient symbolic formalism for quantum operations with applications to the simulation, optimization, and verification of quantum protocols. Unlike quantum circuits, path sums are not limited to unitary operations, but can express arbitrary linear ones. Two problems, therefore, naturally arise in the study of path sums: the unitarity problem and the extraction problem. The former is the problem of deciding whether a given path sum represents a unitary operator. The latter is the problem of constructing a quantum circuit, given a path sum promised to represent a unitary operator. In this paper, we show that the unitarity problem is co-NP-hard in general, but that it is in P when restricted to Clifford path sums. We then provide an algorithm to synthesize a Clifford circuit from a unitary Clifford path sum. The circuits produced by our extraction algorithm are of the form C1-H-C2, where C1 and C2 are Hadamard-free circuits and H is a layer of Hadamard gates. We also provide a heuristic generalization of our extraction algorithm to arbitrary path sums. While this algorithm is not guaranteed to succeed, it often succeeds and typically produces natural looking circuits. Alongside applications to the optimization and decompilation of quantum circuits, we demonstrate the capability of our algorithm by synthesizing the standard quantum Fourier transform directly from a path sum.",
      "authors": [
        "Amy, Matthew",
        "Bennett-Gibbs, Owen",
        "Ross, Neil J."
      ],
      "categories": null,
      "citations": 0,
      "comments": "In Proceedings QPL 2022, arXiv:2311.08375",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": "10.4204/EPTCS.394.17",
      "keywords": [],
      "number_of_pages": 20,
      "pages": "343-362",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "20752180",
        "publisher": "Open Publishing Association",
        "sjr": 0.349,
        "snip": 0.556,
        "subject_areas": [
          "Quantum Physics",
          "Software"
        ],
        "title": "Electronic Proceedings in Theoretical Computer Science, EPTCS"
      },
      "publication_date": "2022-04-29",
      "selected": null,
      "title": "Symbolic Synthesis of Clifford Circuits and Beyond",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85178636961&origin=inward",
        "http://arxiv.org/pdf/2204.14205.pdf",
        "http://arxiv.org/abs/2204.14205v2",
        "http://arxiv.org/pdf/2204.14205v2",
        "http://dx.doi.org/10.4204/EPTCS.394.17"
      ]
    },
    {
      "abstract": "The high complexity of software and the diversity of security vulnerabilities have brought severe challenges to the research of software security vulnerabilities Traditional vulnerability mining methods are inefficient and have problems such as high false positives and high false negatives, which can not meet the growing needs of software security. To solve the above problems, this paper proposes a binary vulnerability mining technology based on neural network feature fusion. Firstly, this method constructs binary vulnerability data sets containing multiple vulnerability types, then decompile them to the pcode intermediate language level, and then extracts relevant feature vectors from binary vulnerability data sets according to Bert fine tuning model and bilstm model respectively. In order to fully obtain the semantic information of vulnerabilities, this method standardized the two, fused them, and carried out relevant experiments. The experimental results show that the accuracy of vulnerability detection on SARD data set is 96.92%, which is higher than other binary vulnerability detection methods based on neural network.",
      "authors": [
        "Wenjie Han",
        "Jianmin Pang",
        "Xin Zhou",
        "Di Zhu"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/AEMCSE55572.2022.00058",
      "keywords": [
        "Deep learning",
        "Decompilation Technology",
        "Vulnerability mining",
        "Neural network"
      ],
      "number_of_pages": 5,
      "pages": "257-261",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-8475-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2022 5th International Conference on Advanced Electronic Materials, Computers and Software Engineering, AEMCSE 2022"
      },
      "publication_date": "2022-04-22",
      "selected": null,
      "title": "Binary vulnerability mining technology based on neural network feature fusion",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9948365",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85143159397&origin=inward"
      ]
    },
    {
      "abstract": "Cyberattacks are increasing in both number and severity for private, corporate, and governmental bodies. To prevent these attacks, many intrusion detection systems and intrusion prevention systems provide computer security by monitoring network packets and auditing system records. However, most of these systems only monitor network packets rather than the computer itself, so physical intrusion is also an important security issue. Furthermore, with the rapid progress of the Internet of Things (IoT) technology, security problems of IoT devices are also increasing. Many IoT devices can be disassembled for decompilation, resulting in the theft of sensitive data. To prevent this, physical intrusion detection systems of the IoT should be considered. We here propose a physical security system that can protect data from unauthorized access when the computer chassis is opened or tampered with. Sensor switches monitor the chassis status at all times and upload event logs to a cloud server for remote monitoring. If the system finds that the computer has an abnormal condition, it takes protective measures and notifies the administrator. This system can be extended to IoT devices to protect their data from theft.",
      "authors": [
        "Qi-Xian Huang",
        "Ming-Chang Lu",
        "Min-Yi Chiu",
        "Yuan-Chia Tsai",
        "Hung-Min Sun"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "PubMed"
      ],
      "doi": null,
      "keywords": [
        "N physical security system",
        "N computer intrusion",
        "N cyber-attack"
      ],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 6.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1424-8220",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.764,
        "snip": 1.317,
        "subject_areas": [
          "Atomic and Molecular Physics, and Optics",
          "Electrical and Electronic Engineering",
          "Instrumentation",
          "Biochemistry",
          "Information Systems",
          "Analytical Chemistry"
        ],
        "title": "Sensors (Basel, Switzerland)"
      },
      "publication_date": "2022-02-28",
      "selected": null,
      "title": "PSPS: A Step toward Tamper Resistance against Physical Computer Intrusion.",
      "urls": []
    },
    {
      "abstract": "Cyberattacks are increasing in both number and severity for private, corporate, and governmental bodies. To prevent these attacks, many intrusion detection systems and intrusion prevention systems provide computer security by monitoring network packets and auditing system records. However, most of these systems only monitor network packets rather than the computer itself, so physical intrusion is also an important security issue. Furthermore, with the rapid progress of the Internet of Things (IoT) technology, security problems of IoT devices are also increasing. Many IoT devices can be disassembled for decompilation, resulting in the theft of sensitive data. To prevent this, physical intrusion detection systems of the IoT should be considered. We here propose a physical security system that can protect data from unauthorized access when the computer chassis is opened or tampered with. Sensor switches monitor the chassis status at all times and upload event logs to a cloud server for remote monitoring. If the system finds that the computer has an abnormal condition, it takes protective measures and notifies the administrator. This system can be extended to IoT devices to protect their data from theft.",
      "authors": [
        "Lu, Ming-Chang",
        "Huang, Qi-Xian",
        "Chiu, Min-Yi",
        "Tsai, Yuan-Chia",
        "Sun, Hung-Min"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/s22051882",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 6.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1424-8220",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.764,
        "snip": 1.317,
        "subject_areas": [
          "Atomic and Molecular Physics, and Optics",
          "Electrical and Electronic Engineering",
          "Instrumentation",
          "Biochemistry",
          "Information Systems",
          "Analytical Chemistry"
        ],
        "title": "Sensors (Basel, Switzerland)"
      },
      "publication_date": "2022-02-28",
      "selected": null,
      "title": "PSPS: A Step toward Tamper Resistance against Physical Computer Intrusion",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85126490644&origin=inward",
        "https://www.mdpi.com/1424-8220/22/5/1882/pdf?version=1648200400"
      ]
    },
    {
      "abstract": "Vulnerabilities are challenging to locate and repair, especially when source code is unavailable and binary patching is required. Manual methods are time-consuming, require significant expertise, and do not scale to the rate at which new vulnerabilities are discovered. Automated methods are an attractive alternative, and we propose Partially Recompilable Decompilation (PRD). PRD lifts suspect binary functions to source, available for analysis, revision, or review, and creates a patched binary using source- and binary-level techniques. Although decompilation and recompilation do not typically work on an entire binary, our approach succeeds because it is limited to a few functions, like those identified by our binary fault localization. We evaluate these assumptions and find that, without any grammar or compilation restrictions, 70-89% of individual functions are successfully decompiled and recompiled with sufficient type recovery. In comparison, only 1.7% of the full C-binaries succeed. When decompilation succeeds, PRD produces test-equivalent binaries 92.9% of the time. In addition, we evaluate PRD in two contexts: a fully automated process incorporating source-level Automated Program Repair (APR) methods; human-edited source-level repairs. When evaluated on DARPA Cyber Grand Challenge (CGC) binaries, we find that PRD-enabled APR tools, operating only on binaries, performs as well as, and sometimes better than full-source tools, collectively mitigating 85 of the 148 scenarios, a success rate consistent with these same tools operating with access to the entire source code. PRD achieves similar success rates as the winning CGC entries, sometimes finding higher-quality mitigations than those produced by top CGC teams. For generality, our evaluation includes two independently developed APR tools and C++, Rode0day, and real-world binaries.",
      "authors": [
        "Reiter, Pemma",
        "Tay, Hui Jun",
        "Weimer, Westley",
        "Doup\u00e9, Adam",
        "Wang, Ruoyu",
        "Forrest, Stephanie"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2022-02-24",
      "selected": null,
      "title": "Automatically Mitigating Vulnerabilities in Binary Programs via Partially Recompilable Decompilation",
      "urls": [
        "http://arxiv.org/pdf/2202.12336.pdf",
        "http://arxiv.org/abs/2202.12336v2",
        "http://arxiv.org/pdf/2202.12336v2"
      ]
    },
    {
      "abstract": "Large language models (such as OpenAI's Codex) have demonstrated impressive zero-shot multi-task capabilities in the software domain, including code explanation. In this work, we examine if this ability can be used to help with reverse engineering. Specifically, we investigate prompting Codex to identify the purpose, capabilities, and important variable names or values from code, even when the code is produced through decompilation. Alongside an examination of the model's responses in answering open-ended questions, we devise a true/false quiz framework to characterize the performance of the language model. We present an extensive quantitative analysis of the measured performance of the language model on a set of program purpose identification and information extraction tasks: of the 136,260 questions we posed, it answered 72,754 correctly. A key takeaway is that while promising, LLMs are not yet ready for zero-shot reverse engineering.",
      "authors": [
        "Pearce, Hammond",
        "Tan, Benjamin",
        "Krishnamurthy, Prashanth",
        "Khorrami, Farshad",
        "Karri, Ramesh",
        "Dolan-Gavitt, Brendan"
      ],
      "categories": null,
      "citations": null,
      "comments": "18 pages, 19 figures. Linked dataset:\n  https://doi.org/10.5281/zenodo.5949075",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2022-02-02",
      "selected": null,
      "title": "Pop Quiz! Can a Large Language Model Help With Reverse Engineering?",
      "urls": [
        "http://arxiv.org/abs/2202.01142v1",
        "http://arxiv.org/pdf/2202.01142v1",
        "http://arxiv.org/pdf/2202.01142.pdf"
      ]
    },
    {
      "abstract": "Aiming at the problems of coupling between transformer input characteristics and low accuracy of transformer fault diagnosis, SSA-MDS and other soft technologies are used to analyze the key characteristics of transformer faults, so as to improve the accuracy of transformer fault diagnosis. The SSA algorithm cascade MDS algorithm to process the DGA data is proposed. Subsequently, the TSSA-RF model is introduced to classify the DGA data. The DGA data is first mapped to a high-dimensional space. Next, the optimal feature subset is encoded using the SSA algorithm to reduce irrelevant and redundant features. In this study, the correlation between the optimal feature dimension and the transformer fault diagnosis accuracy is investigated. the expression of the optimal feature subset is obtained by decompiling the SSA operator. The pre-processed data are classified using the RF model, and the TSSA -RF model for classifying the DGA data is found with the highest accuracy through the comparison of different optimization algorithms. After the RF model is optimized using the TSSA algorithm, its accuracy increases by 7.89%, and the accuracy of the TSSA -RF model is obtained as 92.11%. The example results show that compared with the original data, the proposed data processing algorithm improves the diagnostic accuracy of transformer by 11.97 % in the RF model. Compared with multiple preprocessing methods, SSA-MDS has the highest accuracy. Compared with the original data, the accuracy of TSSA-RF model increases by 11.64 %.",
      "authors": [
        "Mei Zhang",
        "Wanli Chen"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ACCESS.2022.3202982",
      "keywords": [
        "RF~model",
        "TSSA algorithm",
        "feature extraction",
        "Power transformer",
        "fault diagnosis"
      ],
      "number_of_pages": 11,
      "pages": "92505-92515",
      "publication": {
        "category": "Journal",
        "cite_score": 9.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2169-3536",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.926,
        "snip": 1.422,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)",
          "Computer Science (all)"
        ],
        "title": "IEEE Access"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "Fault Diagnosis of Power Transformer Based on SSA\u2014MDS Pretreatment",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9869841",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85137576778&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Burk K."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 18,
      "pages": "2765-2782",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781939133311",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 31st USENIX Security Symposium, Security 2022"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "DECOMPERSON: How Humans Decompile and What We Can Learn From It",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85140993939&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cobus Jooste"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.17159/sajs.2022/12124",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "South African Journal of Science"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "Driving openness \u2013 the myths about data and software access in the Data and Cloud Policy",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85124588141&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cerutti F."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.procs.2022.09.142",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "867-876",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Procedia Computer Science"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "Looking for Criminal Intents in JavaScript Obfuscated Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85143373928&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Deepserish B.K."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ICAC3N56670.2022.10074468",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "2473-2480",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781665474368",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2022 4th International Conference on Advances in Computing, Communication Control and Networking, ICAC3N 2022"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "PET-Droid: Android Malware Detection Using Static Analysis",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85152188430&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is the main process of software development, which is very important when a program tries to retrieve lost source codes. Although decompiling Java bytecode is easier than bytecode, many Java decompilers cannot recover originally lost sources, especially the selection statement, i.e., if statement. This deficiency affects directly decompilation performance. In this paper, we propose the methodology for guiding Java decompiler to deal with the aforementioned problem. In the framework, Java bytecode is transformed into two kinds of features called frame feature and latent semantic feature. The former is extracted directly from the bytecode. The latter is achieved by two-step transforming the Java bytecode to bigram and then term frequency-inverse document frequency (TFIDF). After that, both of them are fed to the genetic algorithm to reduce their dimensions. The proposed feature is achieved by converting the selected TFIDF to a latent semantic feature and concatenating it with the selected frame feature. Finally, KNN is used to classify the proposed feature. The experimental results show that the decompilation accuracy is 93.68 percent, which is obviously better than Java Decompiler.",
      "authors": [
        "Siwadol Sateanpattanakul",
        "Duangpen Jetpipattanapong",
        "Seksan Mathulaprangsan"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.13052/jmm1550-4646.1822",
      "keywords": [],
      "number_of_pages": 24,
      "pages": "179-202",
      "publication": {
        "category": "Journal",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "15504646",
        "publisher": "River Publishers",
        "sjr": 0.172,
        "snip": 0.331,
        "subject_areas": [
          "Industrial and Manufacturing Engineering",
          "Communication",
          "Media Technology"
        ],
        "title": "Journal of Mobile Multimedia"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "Java Bytecode Control Flow Classification: Framework for Guiding Java Decompilation",
      "urls": [
        "https://journals.riverpublishers.com/index.php/JMM/article/download/5523/9997",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85122737986&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wu R."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 18,
      "pages": "2135-2152",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781939133311",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 31st USENIX Security Symposium, Security 2022"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "DnD: A Cross-Architecture Deep Neural Network Decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85134011025&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Chen Q."
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 17,
      "pages": "4327-4343",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781939133311",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 31st USENIX Security Symposium, Security 2022"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "Augmenting Decompiler Output with Learned Variable Names and Types",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85140982317&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Li L."
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.aej.2021.04.076",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "91-99",
      "publication": {
        "category": "Journal",
        "cite_score": 9.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "11100168",
        "publisher": "Elsevier B.V.",
        "sjr": 0.933,
        "snip": 2.006,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Alexandria Engineering Journal"
      },
      "publication_date": "2022-01-01",
      "selected": null,
      "title": "Malware classification based on double byte feature encoding",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85108569438&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation transforms low-level program languages (PL) (e.g., binary code) into high-level PLs (e.g., C/C++). It has been widely used when analysts perform security analysis on software (systems) whose source code is unavailable, such as vulnerability search and malware analysis. However, current decompilation tools usually need lots of experts' efforts, even for years, to generate the rules for decompilation, which also requires long-term maintenance as the syntax of high-level PL or low-level PL changes. Also, an ideal decompiler should concisely generate high-level PL with similar functionality to the source low-level PL and semantic information (e.g., meaningful variable names), just like human-written code. Unfortunately, existing manually-defined rule-based decompilation techniques only functionally restore the low-level PL to a similar high-level PL and are still powerless to recover semantic information. In this paper, we propose a novel neural decompilation approach to translate low-level PL into accurate and user-friendly high-level PL, effectively improving its readability and understandability. Furthermore, we implement the proposed approaches called SEAM. Evaluations on four real-world applications show that SEAM has an average accuracy of 94.41%, which is much better than prior neural machine translation (NMT) models. Finally, we evaluate the effectiveness of semantic information recovery through a questionnaire survey, and the average accuracy is 92.64%, which is comparable or superior to the state-of-the-art compilers.",
      "authors": [
        "Liang, Ruigang",
        "Cao, Ying",
        "Hu, Peiwei",
        "He, Jinwen",
        "Chen, Kai"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2021-12-22",
      "selected": null,
      "title": "Semantics-Recovering Decompilation through Neural Machine Translation",
      "urls": [
        "http://arxiv.org/pdf/2112.15491v1",
        "http://arxiv.org/abs/2112.15491v1",
        "http://arxiv.org/pdf/2112.15491.pdf"
      ]
    },
    {
      "abstract": "Analysis of binary code is a building block of computer security. Especially in malware or firmware analysis where source code oftentimes is not available, techniques like decompilation are utilized to Figure out the functionality of binaries. During the optimization phase in modern compilers, human-readable expressions are often transformed into instruction sequences (compiler idioms or idioms) that may be more efficient in terms of speed or size than the direct translation. However, these transformations are often considerably worse in terms of readability for the analyst. Such compiler specific sequences are not only significantly longer than the apparent translation of the original high-level language operation but also have no trivial correlation to the original expression\u2019s semantics. Modern decompilers address this issue by reverting idioms using static, manually crafted rules. In this paper, we introduce a novel approach to find and annotate arithmetic idioms with their corresponding high-level language expressions to significantly simplify manual analysis. In contrast to previous approaches, our method does not require manual work to create the patterns for matching idioms and significantly less manual labour to derive the transformation rules to calculate the original constants. In our evaluation, we compared the results of PIdARCI against the current academic and commercial state-of-the-art Ghidra, RetDec, and Hex Rays / IDA Pro. We show that PIdARCI matches more than 99% of all considered idioms, exceeding the matching rate of the other approaches.",
      "authors": [
        "Steffen Enders",
        "Mariia Rybalka",
        "Elmar Padilla"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/PST52912.2021.9647781",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "1-7",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-0185-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2021 18th International Conference on Privacy, Security and Trust, PST 2021"
      },
      "publication_date": "2021-12-13",
      "selected": null,
      "title": "PIdARCI: Using Assembly Instruction Patterns to Identify, Annotate, and Revert Compiler Idioms",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85123457997&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9647781"
      ]
    },
    {
      "abstract": "Decompilation aims to analyze and transform low-level program language (PL) codes such as binary code or assembly code to obtain an equivalent high-level PL. Decompilation plays a vital role in the cyberspace security fields such as software vulnerability discovery and analysis, malicious code detection and analysis, and software engineering fields such as source code analysis, optimization, and cross-language cross-operating system migration. Unfortunately, the existing decompilers mainly rely on experts to write rules, which leads to bottlenecks such as low scalability, development difficulties, and long cycles. The generated high-level PL codes often violate the code writing specifications. Further, their readability is still relatively low. The problems mentioned above hinder the efficiency of advanced applications (e.g., vulnerability discovery) based on decompiled high-level PL codes.In this paper, we propose a decompilation approach based on the attention-based neural machine translation (NMT) mechanism, which converts low-level PL into high-level PL while acquiring legibility and keeping functionally similar. To compensate for the information asymmetry between the low-level and high-level PL, a translation method based on basic operations of low-level PL is designed. This method improves the generalization of the NMT model and captures the translation rules between PLs more accurately and efficiently. Besides, we implement a neural decompilation framework called Neutron. The evaluation of two practical applications shows that Neutron\u2019s average program accuracy is 96.96%, which is better than the traditional NMT model.",
      "authors": [
        "Liang, Ruigang",
        "Cao, Ying",
        "Hu, Peiwei",
        "Chen, Kai"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1186/s42400-021-00070-0",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 9.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "20964862",
        "publisher": "SpringerOpen",
        "sjr": 1.266,
        "snip": 2.071,
        "subject_areas": [
          "Computer Networks and Communications",
          "Artificial Intelligence",
          "Information Systems",
          "Software"
        ],
        "title": "Cybersecurity"
      },
      "publication_date": "2021-12-01",
      "selected": null,
      "title": "Neutron: an attention-based neural decompiler",
      "urls": [
        "https://cybersecurity.springeropen.com/counter/pdf/10.1186/s42400-021-00070-0",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85102030836&origin=inward"
      ]
    },
    {
      "abstract": "More and more Android application developers are adopting many different methods against reverse engineering, such as adding a shell, resulting in certain features that cannot be obtained through decompilation, which causes a serious sample imbalance in Android malware detection based on machine learning. Hence, the researchers have focused on how to solve class-imbalance to improve the performance of Android malware detection. However, the disadvantages of the existing class-imbalance learning are mainly the loss of valuable samples and the computational cost. In this paper, we propose a method of Class-Imbalance Learning (CIL), which first selects representative features, uses the clustering K-Means algorithm and under-sampling to retain the important samples of the majority class while reducing the number of samples of the majority class. After that, we use the Synthetic Minority Over-Sampling Technique (SMOTE) algorithm to generate minority class samples for data balance, and finally use the Random Forest (RF) algorithm to build a malware detection model. The result of experiments indicates that CIL effectively improves the performance of Android malware detection based on machine learning, especially for class imbalance. Compared with existing class-imbalance learning methods, CIL is also effective for the Machine Learning Repository from the University of California, Irvine (UCI) and has better performance in some data sets.",
      "authors": [
        "Guan, Jun",
        "Jiang, Xu",
        "Mao, Baolei"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/electronics10243124",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 4.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2079-9292",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.628,
        "snip": 1.045,
        "subject_areas": [
          "Signal Processing",
          "Electrical and Electronic Engineering",
          "Control and Systems Engineering",
          "Hardware and Architecture",
          "Computer Networks and Communications"
        ],
        "title": "Electronics (Switzerland)"
      },
      "publication_date": "2021-12-01",
      "selected": null,
      "title": "A Method for Class-Imbalance Learning in Android Malware Detection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85121032910&origin=inward",
        "https://www.mdpi.com/2079-9292/10/24/3124/pdf?version=1639624617"
      ]
    },
    {
      "abstract": "With the widespread use of the Android operating system, the number of applications on the platform is increasing, and malicious applications are also emerging. How to effectively identify android malware applications to prevent and protect the security of the mobile terminal is a crucial issue. This paper uses the feature fusion method and directly call the library function to extract the permissions and API features of the APK file, then decompile the APK file to obtain the opcode features and merge the three features with multiple features to generate a feature vector. Finally it use a multi-model neural network HYDRA to learn fusion feature vector, so that it can identify and detect malware. The work also compare it with other single-feature machine learning algorithms to verify its effect. Experimental results show that the accuracy of the multi-model neural network detection method based on feature fusion reaches 98.92%, which is better than other single-model feature methods.",
      "authors": [
        "Zhan Fang",
        "Jun Liu",
        "Ribian Huang",
        "Peng Chen",
        "Xin Li",
        "Xiao Chen"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/RCAE53607.2021.9638928",
      "keywords": [
        "android malicious applications",
        "decompile",
        "feature fusion",
        "neural network"
      ],
      "number_of_pages": 5,
      "pages": "147-151",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-2731-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2021 4th International Conference on Robotics, Control and Automation Engineering, RCAE 2021"
      },
      "publication_date": "2021-11-04",
      "selected": null,
      "title": "Research on Multi-model Android Malicious Application Detection Based on Feature Fusion",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85123783337&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9638928"
      ]
    },
    {
      "abstract": "The protection and privacy of the 5G-IoT framework is a major challenge due to the vast number of mobile devices. Specialized applications running these 5G-IoT systems may be vulnerable to clone attacks. Cloning applications can be achieved by stealing or distributing commercial Android apps to harm the advanced services of the 5G-IoT framework. Meanwhile, most Android app stores run and manage Android apps that developers have submitted separately without any central verification systems. Android scammers sell pirated versions of commercial software to other app stores under different names. Android applications are typically stored on cloud servers, while API access services may be used to detect and prevent cloned applications from being released. In this paper, we proposed a hybrid approach to the Control Flow Graph (CFG) and a deep learning model to secure the smart services of the 5G-IoT framework. First, the newly submitted APK file is extracted and the JDEX decompiler is used to retrieve Java source files from possibly original and cloned applications. Second, the source files are broken down into various android-based components. After generating Control-Flow Graphs (CFGs), the weighted features are stripped from each component. Finally, the Recurrent Neural Network (RNN) is designed to predict potential cloned applications by training features from different components of android applications. Experimental results have shown that the proposed approach can achieve an average accuracy of 96.24% for cloned applications selected from different android application stores.",
      "authors": [
        "Ullah, Farhan",
        "Naeem, Muhammad Rashid",
        "Mostarda, Leonardo",
        "Shah, Syed Aziz"
      ],
      "categories": null,
      "citations": 17,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s13042-020-01246-9",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "3115-3127",
      "publication": {
        "category": "Journal",
        "cite_score": 8.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "18688071",
        "publisher": "Springer Science + Business Media",
        "sjr": 1.002,
        "snip": 1.37,
        "subject_areas": [
          "Computer Vision and Pattern Recognition",
          "Artificial Intelligence",
          "Software"
        ],
        "title": "International Journal of Machine Learning and Cybernetics"
      },
      "publication_date": "2021-11-01",
      "selected": null,
      "title": "Clone detection in 5G-enabled social IoT system using graph semantics and deep learning model",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/s13042-020-01246-9.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85099303373&origin=inward"
      ]
    },
    {
      "abstract": "The relevance of the problem under study is due to the rapid development of the java programming language, a large number of commercial applications written in this programming language. The purpose of the article is to develop a methodology that allows you to determine the java-module of the information system, which does not contain a hidden digital watermark. It is necessary that the digital watermark is not damaged during the decompilation of the entire system in order to replace the java module, and that the class files and the entire information system function unchanged. Thus, at first, a digital watermark is hidden in all java-modules of the information system. Next, we check the resistance of the digital watermark to decompilation attacks with block substitution. The materials of the article can be useful in the implementation of hidden embedding of a digital watermark in the class files of a large java module.",
      "authors": [
        "Sharikov Pavel",
        "Krasov Andrey",
        "Gelfand Artem",
        "Birikh Ernest"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICUMT54235.2021.9631736",
      "keywords": [
        "digital watermark",
        "java-module",
        "intruder model",
        "bytecode",
        "java module substitution",
        "decompilation attack",
        "decompilation",
        "java"
      ],
      "number_of_pages": 5,
      "pages": "219-223",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-0220-0",
        "issn": "2157-0221",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2021 13th International Congress on Ultra Modern Telecommunications and Control Systems and Workshops (ICUMT)"
      },
      "publication_date": "2021-10-25",
      "selected": null,
      "title": "A Technique for Detecting the Substitution of a Java-Module of an Information System Prone to Pharming with Using a Hidden Embedding of a Digital Watermark Resistant to Decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85123413926&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9631736"
      ]
    },
    {
      "abstract": "In this paper, we discuss an approach which allows an attacker to modify the control logic program that runs in S7 PLCs in its high-level decompiled format. Our full attack-chain compromises the security measures of PLCs, retrieves the machine bytecode of the target device, and employs a decompiler to convert the stolen compiled bytecode (low-level) to its decompiled version (high-level) e.g. Ladder Diagram LAD. As the LAD code exposes the structure and semantics of the control logic, our attack also manipulates the LAD code based on the attacker\u2019s understanding to the physical process causing abnormal behaviors of the system that we target. Finally, it converts the infected LAD code to its executable version i.e. machine bytecode that can run on the PLC using a compiler before pushing the malicious code back to the PLC. For a real scenario, we implemented our full attack-chain on a small industrial setting using real S7-300 PLCs, and built the database (for our decompiler and compiler) using 108 different control logic programs of varying complexity, ranging from simple programs consisting of a few instructions to more complex ones including multi functions, sub-functions and data blocks. We tested and evaluated the accuracy of our decompiler and compiler on 5 random programs written for real industrial applications. Our experimental results showed that an external adversary is able to infect S7 PLCs successfully. We eventually suggest some potential mitigation approaches to secure systems against such a threat.",
      "authors": [
        "Wael Alsabbagh",
        "Peter Langend\u00f6rfer"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IECON48115.2021.9589721",
      "keywords": [
        "Decompiler",
        "Compiler",
        "Ladder Diagram",
        "Programmable Logic Controllers (PLCs)",
        "Control Injection Attack"
      ],
      "number_of_pages": 8,
      "pages": "1-8",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-0256-9",
        "issn": "1553-572X",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IECON 2021 \u2013 47th Annual Conference of the IEEE Industrial Electronics Society"
      },
      "publication_date": "2021-10-13",
      "selected": null,
      "title": "A Control Injection Attack against S7 PLCs -Manipulating the Decompiled Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85119473360&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9589721"
      ]
    },
    {
      "abstract": "As the mainstream of smart contract research, most Ethereum smart contracts do not open their source code, and the bytecode of smart contracts has attracted the attention of researchers. Based on the similarity measurement of smart contract bytecode, a series of tasks such as vulnerability mining, contract upgrading and malicious contract detection can be carried out. This paper proposes a method to measure the similarity of smart contract bytecode. Firstly, the key opcode combination of smart contract is summarized. When traversing the CFG(control flow graph) constructed by decompilation of smart contract bytecode, the opcodes in the basic block are pattern matched, and the features between the basic blocks are extracted according to the in-out degree, so as to enhance the similarity measurement effect of contract semantics in vector space. The experimental results show that the proposed method is greatly improved compared with the baseline.",
      "authors": [
        "Di Zhu",
        "Jianmin Pang",
        "Xin Zhou",
        "Wenjie Han"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CISAI54367.2021.00113",
      "keywords": [
        "bytecode similarity",
        "basic block",
        "feature extraction",
        "CFG"
      ],
      "number_of_pages": 5,
      "pages": "558-562",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-0693-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2021 International Conference on Computer Information Science and Artificial Intelligence, CISAI 2021"
      },
      "publication_date": "2021-09-17",
      "selected": null,
      "title": "Similarity Measure for Smart Contract Bytecode Based on CFG Feature Extraction",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85127412016&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9718856"
      ]
    },
    {
      "abstract": "The detection of malicious code and variants of advanced persistent threat(APT) attacks is the main way to deal with APT attacks at this stage. APT attack organizations usually use code deformation, shelling, obfuscation and other methods to avoid detection to bypass APT attack malicious code detection. Aiming at the status quo, this paper proposes an APT attack detection scheme based on DenseNet convolutional neural network. First, the binary sample of the malicious code of the APT attack are preprocessed with some operations such as decompression and decompilation. APT attack malicious code samples are running in a sandbox with anti-code escaping technology, and the acquired data are converted into grayscale images. Then, we perform feature extraction and family clustering operations on the pre-processed image. Finally, the DenseNet convolutional neural network model is trained and tested on the sample data of the APT attack malicious code of eight families. The experimental results show that the average accuracy of the proposed scheme for the detection of APT attack malicious code and its variants can reach 98.84%. While cutting off the APT attack chain, it has a high detection accuracy.",
      "authors": [
        "Xiang Han",
        "Chao Li",
        "Xin Li",
        "Tianliang Lu"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CISAI54367.2021.00091",
      "keywords": [
        "deep learning",
        "advanced persistent threat attack",
        "DenseNet convolutional neural network",
        "malicious code",
        "gray-scale image"
      ],
      "number_of_pages": 9,
      "pages": "440-448",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-0693-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2021 International Conference on Computer Information Science and Artificial Intelligence, CISAI 2021"
      },
      "publication_date": "2021-09-17",
      "selected": null,
      "title": "Research on APT Attack Detection Technology Based on DenseNet Convolutional Neural Network",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9719255",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85127437570&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Pei K."
      ],
      "categories": null,
      "citations": 13,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3468264.3468607",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "690-702",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450385626",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ESEC/FSE 2021 - Proceedings of the 29th ACM Joint Meeting European Software Engineering Conference and Symposium on the Foundations of Software Engineering"
      },
      "publication_date": "2021-08-20",
      "selected": null,
      "title": "StateFormer: Fine-grained type recovery from binaries using generative state modeling",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85116286319&origin=inward"
      ]
    },
    {
      "abstract": "Deep learning has had a significant impact on many fields. Recently, code-to-code neural models have been used in code translation, code refinement and decompilation. However, the question of whether these models can automate compilation has yet to be investigated. In this work, we explore neural compilation, building and evaluating Transformer models that learn how to produce x86 assembler from C code. Although preliminary results are relatively weak, we make our data, models and code publicly available to encourage further research in this area.",
      "authors": [
        "Armengol-Estap\u00e9, Jordi",
        "O'Boyle, Michael F. P."
      ],
      "categories": null,
      "citations": null,
      "comments": "Published in AIPLANS 2021",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Artificial Intelligence",
          "Programming Languages"
        ],
        "title": "Armengol-Estap\\'e, J. and O'Boyle, M. Learning C to x86\n  translation: An experiment in neural compilation. In Advances in Programming\n  Languages and Neurosymbolic Systems Workshop, 2021. URL\n  \\url{https://openreview.net/forum?id=444ug_EYXet}"
      },
      "publication_date": "2021-08-17",
      "selected": null,
      "title": "Learning C to x86 Translation: An Experiment in Neural Compilation",
      "urls": [
        "http://arxiv.org/pdf/2108.07639v2",
        "http://arxiv.org/abs/2108.07639v2",
        "http://arxiv.org/pdf/2108.07639.pdf"
      ]
    },
    {
      "abstract": "A common tool used by security professionals for reverse-engineering binaries found in the wild is the decompiler. A decompiler attempts to reverse compilation, transforming a binary to a higher-level language such as C. High-level languages ease reasoning about programs by providing useful abstractions such as loops, typed variables, and comments, but these abstractions are lost during compilation. Decompilers are able to deterministically reconstruct structural properties of code, but comments, variable names, and custom variable types are technically impossible to recover. In this paper we present DIRTY (DecompIled variable ReTYper), a novel technique for improving the quality of decompiler output that automatically generates meaningful variable names and types. Empirical evaluation on a novel dataset of C code mined from GitHub shows that DIRTY outperforms prior work approaches by a sizable margin, recovering the original names written by developers 66.4% of the time and the original types 75.8% of the time.",
      "authors": [
        "Chen, Qibin",
        "Lacomis, Jeremy",
        "Schwartz, Edward J.",
        "Goues, Claire Le",
        "Neubig, Graham",
        "Vasilescu, Bogdan"
      ],
      "categories": null,
      "citations": null,
      "comments": "17 pages to be published in USENIX Security '22",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2021-08-13",
      "selected": null,
      "title": "Augmenting Decompiler Output with Learned Variable Names and Types",
      "urls": [
        "http://arxiv.org/pdf/2108.06363v1",
        "http://arxiv.org/pdf/2108.06363.pdf",
        "http://arxiv.org/abs/2108.06363v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Dai F."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.16467/j.1008-3650.2021.0090",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "349-353",
      "publication": {
        "category": "Journal",
        "cite_score": 0.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10083650",
        "publisher": "Editorial Office of Forensic Science and Technology",
        "sjr": 0.2,
        "snip": 0.057,
        "subject_areas": [
          "Biochemistry, Genetics and Molecular Biology (miscellaneous)",
          "Law",
          "Pathology and Forensic Medicine",
          "Toxicology"
        ],
        "title": "Forensic Science and Technology"
      },
      "publication_date": "2021-08-01",
      "selected": null,
      "title": "Reverse analysis to undertake forensics into mobile phone-operated apk program",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85113304692&origin=inward"
      ]
    },
    {
      "abstract": "Introduction: Decompilers are useful tools for software analysis and support\nin the absence of source code. They are available for many hardware\narchitectures and programming languages. However, none of the existing\ndecompilers support modern AMD GPU architectures such as AMD GCN and RDNA.\nPurpose: We aim at developing the first assembly decompiler tool for a modern\nAMD GPU architecture that generates code in the OpenCL language, which is\nwidely used for programming GPGPUs. Results: We developed the algorithms for\nthe following operations: preprocessing assembly code, searching data accesses,\nextracting system values, decompiling arithmetic operations and recovering data\ntypes. We also developed templates for decompilation of branching operations.\nPractical relevance: We implemented the presented algorithms in Python as a\ntool called OpenCLDecompiler, which supports a large subset of AMD GCN\ninstructions. This tool automatically converts disassembled GPGPU code into the\nequivalent OpenCL code, which reduces the effort required to analyze assembly\ncode.",
      "authors": [
        "K. I. Mihajlenko",
        "M. A. Lukin",
        "A. S. Stankevich"
      ],
      "categories": null,
      "citations": 0,
      "comments": "10 pages, 5 figures",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": "10.31799/1684-8853-2021-2-33-42",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "33-42",
      "publication": {
        "category": "Journal",
        "cite_score": 1.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16848853",
        "publisher": "Saint Petersburg State University of Aerospace Instrumentation",
        "sjr": 0.213,
        "snip": 0.368,
        "subject_areas": [
          "Control and Systems Engineering",
          "Distributed, Parallel, and Cluster Computing",
          "Control and Optimization",
          "Information Systems",
          "Programming Languages",
          "Computer Science Applications"
        ],
        "title": "Information and Control Systems, 2021, no. 2, pp. 33-42"
      },
      "publication_date": "2021-07-16",
      "selected": null,
      "title": "A method for decompilation of AMD GCN kernels to OpenCL",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85108195583&origin=inward",
        "http://dx.doi.org/10.31799/1684-8853-2021-2-33-42",
        "http://arxiv.org/pdf/2107.07809v1",
        "http://arxiv.org/abs/2107.07809v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ortin F."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.softx.2021.100711",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "SoftwareX"
      },
      "publication_date": "2021-07-01",
      "selected": null,
      "title": "Cnerator: A Python application for the controlled stochastic generation of standard C source code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85107075116&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Albert E."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.jss.2021.110923",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 9.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01641212",
        "publisher": "Elsevier Inc.",
        "sjr": 1.126,
        "snip": 2.032,
        "subject_areas": [
          "Hardware and Architecture",
          "Information Systems",
          "Software"
        ],
        "title": "Journal of Systems and Software"
      },
      "publication_date": "2021-06-01",
      "selected": null,
      "title": "Don't run on fumes\u2014Parametric gas bounds for smart contracts",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85101900327&origin=inward"
      ]
    },
    {
      "abstract": "On-device deep learning models have shown growing popularity in mobile apps, which allows offline model inference while preserving user privacy. However, on-device deep learning models also introduce security challenges, i.e., the trained models can be easily stolen or even be tampered by attackers. Recent studies suggested that most of the on-device models are lacking of sufficient protection, i.e., can be stolen by decompiling the apps directly. In this work, we present MMGUARD, an automated framework for building mutual authentication between Android apps and deep neural network models, which can thus protect on-device models from being easily attacked (piracy and tampering). Unlike existing model protect methods, our approach does not require model re-training or any prior knowledge of the training data. The key idea of MMGUARD is to verify the deep learning model in the app before inference, i.e., feeding owner- and apprelated information to it, which can greatly increase the effort of model hacking. We evaluate MMGUARD on 5 popular image classification DNNs and 43 real world Android apps from Google Play. Experiment results suggest that MMGUARD introduces negligible latency on models and can be automatically applied to real world apps.",
      "authors": [
        "Jiayi Hua",
        "Yuanchun Li",
        "Haoyu Wang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SPW53761.2021.00019",
      "keywords": [
        "on-device model",
        "deep learning",
        "model attack.",
        "mobile app",
        "Model protection"
      ],
      "number_of_pages": 7,
      "pages": "71-77",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-3733-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2021 IEEE Symposium on Security and Privacy Workshops, SPW 2021"
      },
      "publication_date": "2021-05-27",
      "selected": null,
      "title": "MMGuard: Automatically Protecting On-Device Deep Learning Models in Android Apps",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85112824892&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9474328"
      ]
    },
    {
      "abstract": "Recovering variables and data structure information from stripped binary is a prominent challenge in binary program analysis. While various state-of-the-art techniques are effective in specific settings, such effectiveness may not generalize. This is mainly because the problem is inherently uncertain due to the information loss in compilation. Most existing techniques are deterministic and lack a systematic way of handling such uncertainty. We propose a novel probabilistic technique for variable and structure recovery. Random variables are introduced to denote the likelihood of an abstract memory location having various types and structural properties such as being a field of some data structure. These random variables are connected through probabilistic constraints derived through program analysis. Solving these constraints produces the posterior probabilities of the random variables, which essentially denote the recovery results. Our experiments show that our technique substantially outperforms a number of state-of-the-art systems, including IDA, Ghidra, Angr, and Howard. Our case studies demonstrate the recovered information improves binary code hardening and binary decompilation.",
      "authors": [
        "Zhuo Zhang",
        "Yapeng Ye",
        "Wei You",
        "Guanhong Tao",
        "Wen-chuan Lee",
        "Yonghwi Kwon",
        "Yousra Aafer",
        "Xiangyu Zhang"
      ],
      "categories": null,
      "citations": 12,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SP40001.2021.00051",
      "keywords": [
        "Reverse-Engineering",
        "Probabilistic-Analysis",
        "Type-Inference",
        "Binary-Analysis"
      ],
      "number_of_pages": 20,
      "pages": "813-832",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-9337-6",
        "issn": "1081-6011",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - IEEE Symposium on Security and Privacy"
      },
      "publication_date": "2021-05-24",
      "selected": null,
      "title": "OSPREY: Recovery of Variable and Data Structure via Probabilistic Analysis for Stripped Binary",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9519451",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85113833267&origin=inward"
      ]
    },
    {
      "abstract": "There is increasing interest in applying verification tools to programs that have bitvector operations (eg., binaries). SMT solvers, which serve as a foundation for these tools, have thus increased support for bitvector reasoning through bit-blasting and linear arithmetic approximations. In this paper we show that similar linear arithmetic approximation of bitvector operations can be done at the source level through transformations. Specifically, we introduce new paths that over-approximate bitvector operations with linear conditions/constraints, increasing branching but allowing us to better exploit the well-developed integer reasoning and interpolation of verification tools. We show that, for reachability of bitvector programs, increased branching incurs negligible overhead yet, when combined with integer interpolation optimizations, enables more programs to be verified. We further show this exploitation of integer interpolation in the common case also enables competitive termination verification of bitvector programs and leads to the first effective technique for LTL verification of bitvector programs. Finally, we provide an in-depth case study of decompiled (\"lifted\") binary programs, which emulate X86 execution through frequent use of bitvector operations. We present a new tool DarkSea, the first tool capable of verifying reachability, termination, and LTL of lifted binaries.",
      "authors": [
        "Liu, Yuandong Cyrus",
        "Pang, Chengbin",
        "Dietsch, Daniel",
        "Koskinen, Eric",
        "Le, Ton-Chanh",
        "Portokalidis, Georgios",
        "Xu, Jun"
      ],
      "categories": null,
      "citations": null,
      "comments": "39 pages(including Appendix), 10 tables, 4 Postscript figures,\n  accepted to APLAS 2021",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2021-05-11",
      "selected": null,
      "title": "Proving LTL Properties of Bitvector Programs and Decompiled Binaries (Extended)",
      "urls": [
        "http://arxiv.org/pdf/2105.05159v2",
        "http://arxiv.org/abs/2105.05159v2",
        "http://arxiv.org/pdf/2105.05159.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Liu R."
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3411764.3445535",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450380966",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Conference on Human Factors in Computing Systems - Proceedings"
      },
      "publication_date": "2021-05-06",
      "selected": null,
      "title": "Igscript: An interaction grammar for scientific data presentation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85105782636&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Hilbig A."
      ],
      "categories": null,
      "citations": 41,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3442381.3450138",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "2696-2708",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450383127",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "The Web Conference 2021 - Proceedings of the World Wide Web Conference, WWW 2021"
      },
      "publication_date": "2021-04-19",
      "selected": null,
      "title": "An empirical study of real-world webassembly binaries: Security, languages, use cases",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85107945691&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Huang L."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1108/DTA-01-2019-0013",
      "keywords": [],
      "number_of_pages": 24,
      "pages": "192-215",
      "publication": {
        "category": "Journal",
        "cite_score": 4.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "25149288",
        "publisher": "Emerald Group Publishing Ltd.",
        "sjr": 0.479,
        "snip": 0.907,
        "subject_areas": [
          "Library and Information Sciences",
          "Information Systems"
        ],
        "title": "Data Technologies and Applications"
      },
      "publication_date": "2021-04-09",
      "selected": null,
      "title": "Data access as a big competitive advantage: evidence from China's car-hailing platforms",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096022165&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is the procedure of transforming binary programs into a high-level representation, such as source code, for human analysts to examine. While modern decompilers can reconstruct and recover much information that is discarded during compilation, inferring variable names is still extremely difficult. Inspired by recent advances in natural language processing, we propose a novel solution to infer variable names in decompiled code based on Masked Language Modeling, Byte-Pair Encoding, and neural architectures such as Transformers and BERT. Our solution takes \\textit{raw} decompiler output, the less semantically meaningful code, as input, and enriches it using our proposed \\textit{finetuning} technique, Constrained Masked Language Modeling. Using Constrained Masked Language Modeling introduces the challenge of predicting the number of masked tokens for the original variable name. We address this \\textit{count of token prediction} challenge with our post-processing algorithm. Compared to the state-of-the-art approaches, our trained VarBERT model is simpler and of much better performance. We evaluated our model on an existing large-scale data set with 164,632 binaries and showed that it can predict variable names identical to the ones present in the original source code up to 84.15\\% of the time.",
      "authors": [
        "Banerjee, Pratyay",
        "Pal, Kuntal Kumar",
        "Wang, Fish",
        "Baral, Chitta"
      ],
      "categories": null,
      "citations": null,
      "comments": "Work In Progress",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2021-03-23",
      "selected": null,
      "title": "Variable Name Recovery in Decompiled Binary Code using Constrained Masked Language Modeling",
      "urls": [
        "http://arxiv.org/pdf/2103.12801.pdf",
        "http://arxiv.org/abs/2103.12801v1",
        "http://arxiv.org/pdf/2103.12801v1"
      ]
    },
    {
      "abstract": "Industrial control systems (ICSs) consist of programmable logic controllers (PLCs) which communicate with an engineering station on one side, and control a certain physical process on the other side. Siemens PLCs, particularly S7-300 controllers, are widely used in industrial systems, and modern critical infrastructures heavily rely on them. But unfortunately, security features are largely absent in such devices or ignored/disabled because security is often at odds with operations. As a consequence of the already reported vulnerabilities, it is possible to leverage PLCs and perhaps even the corporate IT network. In this paper we show that S7-300 PLCs are vulnerable and demonstrate that exploiting the execution process of the logic program running in a PLC is feasible. We discuss a replay attack that compromises the password protected PLCs, then we show how to retrieve the Bytecode from the target and decompile the Bytecode to STL source code. Afterwards we present how to conduct a typical injection attack showing that even a very tiny modification in the code is sufficient to harm the target system. Finally we combine the replay attack with the injection approach to achieve a stronger attack \u2013 the stealth program injection attack \u2013 which can hide the previous modification by engaging a fake PLC, impersonating the real infected device. For real scenarios, we implemented all our attacks on a real industrial setting using S7-300 PLC. We eventually suggest mitigation approaches to secure systems against such threats.",
      "authors": [
        "Wael Alsabbagh",
        "Peter Langend\u00f6rfer"
      ],
      "categories": null,
      "citations": 13,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICIT46573.2021.9453483",
      "keywords": [
        "S7-300 PLCs",
        "Replay Attack",
        "Fake PLC",
        "Injection Attack",
        "Stealthy Attack"
      ],
      "number_of_pages": 8,
      "pages": "986-993",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-5731-3",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the IEEE International Conference on Industrial Technology"
      },
      "publication_date": "2021-03-10",
      "selected": null,
      "title": "A Stealth Program Injection Attack against S7-300 PLCs",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9453483",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85112372283&origin=inward"
      ]
    },
    {
      "abstract": "Much software, whether beneficent or malevolent, is distributed only as binaries, sans source code. Absent source code, understanding binaries&#x2019; behavior can be quite challenging, especially when compiled under higher levels of compiler optimization. These optimizations can transform comprehensible, &#x201C;natural&#x201D; source constructions into something entirely unrecognizable. Reverse engineering binaries, especially those suspected of being malevolent or guilty of intellectual property theft, are important and time-consuming tasks. There is a great deal of interest in tools to &#x201C;decompile&#x201D; binaries back into more natural source code to aid reverse engineering. Decompilation involves several desirable steps, including recreating source-language constructions, variable names, and perhaps even comments. One central step in creating binaries is optimizing function calls, using steps such as inlining. Recovering these (possibly inlined) function calls from optimized binaries is an essential task that most state-of-the-art decompiler tools try to do but do not perform very well. In this paper, we evaluate a supervised learning approach to the problem of recovering optimized function calls. We leverage open-source software and develop an automated labeling scheme to generate a reasonably large dataset of binaries labeled with actual function usages. We augment this large but limited labeled dataset with a pre-training step, which learns the decompiled code statistics from a much larger unlabeled dataset. Thus augmented, our learned labeling model can be combined with an existing decompilation tool, Ghidra, to achieve substantially improved performance in function call recovery, especially at higher levels of optimization.",
      "authors": [
        "Toufique Ahmed",
        "Premkumar Devanbu",
        "Anand Ashok Sawant"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "arXiv",
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TSE.2021.3106572",
      "keywords": [
        "Reverse engineering",
        "software modeling",
        "deep learning"
      ],
      "number_of_pages": 15,
      "pages": "3862-3876",
      "publication": {
        "category": "Journal",
        "cite_score": 9.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0098-5589",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 1.713,
        "snip": 3.516,
        "subject_areas": [
          "Software Engineering",
          "Software"
        ],
        "title": "Transactions on Software Engineering (2021)"
      },
      "publication_date": "2021-03-09",
      "selected": null,
      "title": "Learning to Find Usages of Library Functions in Optimized Binaries",
      "urls": [
        "http://dx.doi.org/10.1109/TSE.2021.3106572",
        "https://dl.acm.org/doi/10.1109/TSE.2021.3106572",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85113305767&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9520296",
        "http://arxiv.org/abs/2103.05221v2",
        "http://arxiv.org/pdf/2103.05221v2"
      ]
    },
    {
      "abstract": "Decompilers are indispensable tools in Android malware analysis and app security auditing. Numerous academic works also employ an Android decompiler as the first step in a program analysis pipeline. In such settings, decompilation is frequently regarded as a \"solved\" problem, in that it is simply expected that source code can be accurately recovered from an app. While a large proportion of methods in an app can typically be decompiled successfully, it is common that at least some methods fail to decompile. In order to better understand the practical applicability of techniques in which decompilation is used as part of an automated analysis, it is important to know the actual expected failure rate of Android decompilation. To this end, we have performed what is, to the best of our knowledge, the first large-scale study of Android decompilation failure rates. We have used three sets of apps, consisting of, respectively, 3,018 open-source apps, 13,601 apps from a recent crawl of Google Play, and a collection of 24,553 malware samples. In addition to the state-of-the-art Dalvik bytecode decompiler jadx, we used three popular Java decompilers. While jadx achieves an impressively low failure rate of only 0.02% failed methods per app on average, we found that it manages to recover source code for all methods in only 21% of the Google Play apps.We have also sought to better understand the degree to which in-the-wild obfuscation techniques can prevent decompilation. Our empirical evaluation, complemented with an indepth manual analysis of a number of apps, indicate that code obfuscation is quite rarely encountered, even in malicious apps. Moreover, decompilation failures mostly appear to be caused by technical limitations in decompilers, rather than by deliberate attempts to thwart source-code recovery by obfuscation. This is an encouraging finding, as it indicates that near-perfect Android decompilation is, at least in theory, achievable, with implementation-level improvements to decompilation tools.",
      "authors": [
        "Noah Mauthe",
        "Ulf Karg&#x00E9;n",
        "Nahid Shahmehri"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SANER50967.2021.00044",
      "keywords": [
        "mobile apps",
        "reverse engineering",
        "Android",
        "malware",
        "decompilation",
        "obfuscation"
      ],
      "number_of_pages": 11,
      "pages": "400-410",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-9631-2",
        "issn": "1534-5351",
        "publisher": "IEEE Computer Society",
        "sjr": 0.358,
        "snip": 1.904,
        "subject_areas": [
          "Software"
        ],
        "title": "Proceedings - 2023 IEEE International Conference on Software Analysis, Evolution and Reengineering, SANER 2023"
      },
      "publication_date": "2021-03-09",
      "selected": null,
      "title": "A Large-Scale Empirical Study of Android App Decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85106642902&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9425937"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Fedorchenko E.V."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1088/1757-899X/1047/1/012074",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17578981",
        "publisher": "IOP Publishing Ltd.",
        "sjr": 0.249,
        "snip": 0.517,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)"
        ],
        "title": "IOP Conference Series: Materials Science and Engineering"
      },
      "publication_date": "2021-02-11",
      "selected": null,
      "title": "Semantic model of an exploit's source code for data protection in automation systems",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85101567702&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Hu T."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.aej.2020.11.013",
      "keywords": [],
      "number_of_pages": 25,
      "pages": "1601-1625",
      "publication": {
        "category": "Journal",
        "cite_score": 9.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "11100168",
        "publisher": "Elsevier B.V.",
        "sjr": 0.933,
        "snip": 2.006,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Alexandria Engineering Journal"
      },
      "publication_date": "2021-02-01",
      "selected": null,
      "title": "Design of ethnic patterns based on shape grammar and artificial neural network",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85097056947&origin=inward"
      ]
    },
    {
      "abstract": "In software reverse engineering, decompilation is the process of recovering source code from binary files. Decompilers are used when it is necessary to understand or analyze software for which the source code is not available. Although existing decompilers commonly obtain source code with the same behavior as the binaries, that source code is usually hard to interpret and certainly differs from the original code written by the programmer. Massive codebases could be used to build supervised machine learning models aimed at improving existing decompilers. In this article, we build different classification models capable of inferring the high-level type returned by functions, with significantly higher accuracy than existing decompilers. We automatically instrument C source code to allow the association of binary patterns with their corresponding high-level constructs. A dataset is created with a collection of real open-source applications plus a huge number of synthetic programs. Our system is able to predict function return types with a 79.1% F1-measure, whereas the best decompiler obtains a 30% F1-measure. Moreover, we document the binary patterns used by our classifier to allow their addition in the implementation of existing decompilers.",
      "authors": [
        "Escalada, Javier",
        "Scully, Ted",
        "Ortin, Francisco"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2021-01-19",
      "selected": null,
      "title": "Improving type information inferred by decompilers with supervised machine learning",
      "urls": [
        "http://arxiv.org/pdf/2101.08116.pdf",
        "http://arxiv.org/pdf/2101.08116v2",
        "http://arxiv.org/abs/2101.08116v2"
      ]
    },
    {
      "abstract": "At present, mobile applications are developing rapidly, and the methods of attacking mobile applications by reverse engineering to obtain the core logic of the program are becoming more and more intense. In the face of malicious tampering, permission bypassing or obtaining core intellectual property rights through reverse engineering of mobile application, this paper proposes a mobile application reinforcement method based on control flow and data flow confusion, and factors affecting the accuracy and complexity of program analysis extracted for mobile applications, analyze its own characteristics and the relationship between them, detailed analysis of the implementation principle and code of the variable target compiler, in the syntax analysis and semantic analysis stage, the corresponding code obfuscation algorithm is implemented. Through obfuscation, the compiled program is strengthened at the three levels of grammar, control flow, and data flow. Experiments show that even if the source code of mobile application reinforced by this method is obtained through decompilation, the internal logic of the application cannot be known, and the next attack cannot be initiated.",
      "authors": [
        "Lu Chen",
        "Yuanyuan Ma",
        "Zhipeng Shao",
        "Mu Chen"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICMTMA52658.2021.00080",
      "keywords": [
        "control flow",
        "data flow",
        "mobile application",
        "security reinforcement"
      ],
      "number_of_pages": 4,
      "pages": "345-348",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-4609-9",
        "issn": "2157-1473",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2021 13th International Conference on Measuring Technology and Mechatronics Automation, ICMTMA 2021"
      },
      "publication_date": "2021-01-16",
      "selected": null,
      "title": "Mobile application reinforcement method based on control flow and data flow confusion",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9410081",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85105393473&origin=inward"
      ]
    },
    {
      "abstract": "According to kids\u2019 learning process, an auto-encoder which can be split into two parts is designed. The two parts can work well separately. The top half is an abstract network which is trained by supervised learning and can be used to classify and regress. The...",
      "authors": [
        "Wei, Jinxin",
        "Ren, Qunying"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-63128-4_42",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "553-560",
      "publication": {
        "category": "Book",
        "cite_score": 0.9,
        "is_potentially_predatory": false,
        "isbn": "9783030631277",
        "issn": "21945357",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.215,
        "snip": 0.291,
        "subject_areas": [
          "Computer Science (all)",
          "Control and Systems Engineering"
        ],
        "title": "Proceedings of the Future Technologies Conference"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "A Functionally Separate Autoencoder",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096468168&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-030-63128-4_42.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Stevenson J."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-1-4842-6914-5",
      "keywords": [],
      "number_of_pages": 165,
      "pages": "1-165",
      "publication": {
        "category": "Book",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781484269145",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Android Software Internals Quick Reference: A Field Manual and Security Reference Guide to Java-based Android Components"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "Android Software Internals Quick Reference: A Field Manual and Security Reference Guide to Java-based Android Components",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85125411420&origin=inward"
      ]
    },
    {
      "abstract": "One of the leading and the most popular operating system for smartphones and tablets is an Android. Being an open-source platform has also become a prime target for the attackers as growing users. This paper focuses on the work done on the Android platform by...",
      "authors": [
        "Patil, Manisha",
        "Pramod, Dhanya"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-15-9647-6_95",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "1199-1207",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "978-3-030-34080-3",
        "issn": "23674512",
        "publisher": "Springer International Publishing AG",
        "sjr": 0.125,
        "snip": 0.104,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Media Technology",
          "Information Systems",
          "Computer Networks and Communications",
          "Computer Science Applications"
        ],
        "title": "International Conference on Intelligent Data Communication Technologies and Internet of Things"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "AndRev: Reverse Engineering Tool to Extract Permissions of Android Mobile Apps for Analysis",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-981-15-9647-6_95.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85107411012&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yao Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/QRS-C55045.2021.00106",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "708-711",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781665478366",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2021 21st International Conference on Software Quality, Reliability and Security Companion, QRS-C 2021"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "Android privacy protocol and permission consistency testing",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85140877747&origin=inward"
      ]
    },
    {
      "abstract": "The malicious APK (Android Application Package) makers use some techniques such as code obfuscation and code encryption to avoid existing detection methods, which poses new challenges for accurate virus detection and makes it more and more difficult to detect the malicious code. A report indicates that a new malicious app for Android is created every 10 seconds. To combat this serious malware activity, a scalable malware detection approach is needed, which can effectively and efficiently identify the malware apps. Common static detection methods often rely on Hash matching and analysis of viruses, which cannot quickly detect new malicious Android applications and their variants. In this paper, a malicious Android application detection method is proposed, which is implemented by the deep network fusion model. The hybrid model only needs to use the sample training model to achieve high accuracy in the identification of the malicious applications, which is more suitable for the detection of the new malicious Android applications than the existing methods. This method extracts the static features in the core code of the Android application by decompiling APK files, then performs code vectorization processing, and uses the deep learning network for classification and discrimination. Our experiments with a data set containing 10,170 apps show that the decisions from the hybrid model can increase the malware detection rate significantly on a real device, which verifies the superiority of this method in the detection of malicious codes.",
      "authors": [
        "Liu, Lin",
        "Ren, Wang",
        "Xie, Feng",
        "Yi, Shengwei",
        "Yi, Junkai",
        "Jia, Peng"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "https://doi.org/10.1155/2021/9964224",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19390114",
        "publisher": "Hindawi Limited",
        "sjr": 0.494,
        "snip": 0.785,
        "subject_areas": [
          "Computer Networks and Communications",
          "Information Systems"
        ],
        "title": "Security and Communication Networks"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "Learning-Based Detection for Malicious Android Application Using Code Vectorization",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85113953575&origin=inward",
        "https://downloads.hindawi.com/journals/scn/2021/9964224.pdf"
      ]
    },
    {
      "abstract": "Growing numbers of advanced malware-based attacks against governments and corporations, for political, financial and scientific gains, have taken security breaches to the next level. In response to such attacks, both academia and industry have investigated techniques...",
      "authors": [
        "Mirzaei, Omid",
        "Vasilenko, Roman",
        "Kirda, Engin",
        "Lu, Long",
        "Kharraz, Amin"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-80825-9_7",
      "keywords": [],
      "number_of_pages": 21,
      "pages": "130-150",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "SCRUTINIZER: Detecting Code Reuse in\u00a0Malware via Decompilation and\u00a0Machine Learning",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-030-80825-9_7.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85112261566&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Nitin V."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 10,
      "pages": "48-57",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781954085640",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "NLP4Prog 2021 - 1st Workshop on Natural Language Processing for Programming, Proceedings of the Workshop"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "DIRECT: A Transformer-based Model for Decompiled Variable Name Recovery",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85134881325&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Hu Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.16467/j.1008-3650.2021.0071",
      "keywords": [],
      "number_of_pages": 3,
      "pages": "328-330",
      "publication": {
        "category": "Journal",
        "cite_score": 0.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10083650",
        "publisher": "Editorial Office of Forensic Science and Technology",
        "sjr": 0.2,
        "snip": 0.057,
        "subject_areas": [
          "Biochemistry, Genetics and Molecular Biology (miscellaneous)",
          "Law",
          "Pathology and Forensic Medicine",
          "Toxicology"
        ],
        "title": "Forensic Science and Technology"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "Digital forensics into online lending platform involved with infringing citizens\u2019 personal information",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85108365571&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "18th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment, DIMVA 2021",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85112283525&origin=inward"
      ]
    },
    {
      "abstract": "With the boom of malware, the area of malware detection and the use of gadget assist to gain knowledge in research drastically with the aid of researchers. The conventional methods of malware detection are incompetent to detect new and generic malware. In this...",
      "authors": [
        "Agrawal, Prerna",
        "Trivedi, Bhushan"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-16-0965-7_4",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "35-41",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "978-3-030-34080-3",
        "issn": "23674512",
        "publisher": "Springer International Publishing AG",
        "sjr": 0.125,
        "snip": 0.104,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Media Technology",
          "Information Systems",
          "Computer Networks and Communications",
          "Computer Science Applications"
        ],
        "title": "International Conference on Intelligent Data Communication Technologies and Internet of Things"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "AndroHealthCheck: A Malware Detection System for Android Using Machine Learning",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-981-16-0965-7_4.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85114612572&origin=inward"
      ]
    },
    {
      "abstract": "In recent years, with the quiet popularity of mobile payment methods, mobile terminal equipment also have potential security problems while facilitating people\u2019s lives. Behavior-based Android malware detection is mostly based on permission analysis and API...",
      "authors": [
        "Yu, Junhui",
        "Zhao, Chunlei",
        "Zheng, Wenbai",
        "Li, Yunlong",
        "Zhang, Chunxiang",
        "Chen, Chao"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-73429-9_8",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "126-140",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "9783030734282",
        "issn": "18678211",
        "publisher": "Springer Verlag",
        "sjr": 0.159,
        "snip": 0.137,
        "subject_areas": [
          "Computer Networks and Communications"
        ],
        "title": "Lecture Notes of the Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering, LNICST"
      },
      "publication_date": "2021-01-01",
      "selected": null,
      "title": "Android Malware Detection Using Ensemble Learning on Sensitive APIs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85104799686&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-030-73429-9_8.pdf"
      ]
    },
    {
      "abstract": "More than eight million smart contracts have been deployed into Ethereum, which is the most popular blockchain that supports smart contract. However, less than 1% of deployed smart contracts are open-source, and it is difficult for users to understand the functionality and internal mechanism of those closed-source contracts. Although a few decompilers for smart contracts have been recently proposed, it is still not easy for users to grasp the semantic information of the contract, not to mention the potential misleading due to decompilation errors. In this paper, we propose the first system named Stan to generate descriptions for the bytecodes of smart contracts to help users comprehend them. In particular, for each interface in a smart contract, Stan can generate four categories of descriptions, including functionality description, usage description, behavior description, and payment description, by leveraging symbolic execution and NLP (Natural Language Processing) techniques. Extensive experiments show that Stan can generate adequate, accurate and readable descriptions for contract\u2019s bytecodes, which have practical value for users.",
      "authors": [
        "Xiaoqi Li",
        "Ting Chen",
        "Xiapu Luo",
        "Tao Zhang",
        "Le Yu",
        "Zhou Xu"
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/QRS51102.2020.00045",
      "keywords": [
        "Smart contract",
        "Ethereum",
        "Program comprehension"
      ],
      "number_of_pages": 12,
      "pages": "273-284",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-8914-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2020 IEEE 20th International Conference on Software Quality, Reliability, and Security, QRS 2020"
      },
      "publication_date": "2020-12-11",
      "selected": null,
      "title": "STAN: Towards Describing Bytecodes of Smart Contract",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9282282",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85097585973&origin=inward"
      ]
    },
    {
      "abstract": "In this paper, we present a combination of existing and new tools that together make it possible to apply formal verification methods to programs in the form of \u00d786_64 machine code. Our approach first uses a decompilation tool (remill) to extract low-level intermediate representation (LLVM) from the machine code. This step consists of instruction translation (i.e. recovery of operation semantics), control flow extraction and address identification.The main contribution of this paper is the second step, which builds on data flow analysis and refinement of indirect (i.e. data-dependent) control flow. This step makes the processed bitcode much more amenable to formal analysis.To demonstrate the viability of our approach, we have compiled a set of benchmark programs into native executables and analysed them using two LLVM-based tools: DIVINE, a software model checker and KLEE, a symbolic execution engine. We have compared the outcomes to direct analysis of the same programs.",
      "authors": [
        "Luk\u00e1\u0161 Koren\u010dik",
        "Petr Ro\u010dkai",
        "Henrich Lauko",
        "Ji\u0159\u00ed Barnat"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/QRS51102.2020.00044",
      "keywords": [
        "symbolic execution",
        "llvm",
        "binary analysis",
        "decompilation",
        "program analysis"
      ],
      "number_of_pages": 8,
      "pages": "265-272",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-8914-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2020 IEEE 20th International Conference on Software Quality, Reliability, and Security, QRS 2020"
      },
      "publication_date": "2020-12-11",
      "selected": null,
      "title": "On Symbolic Execution of Decompiled Programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85099298855&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9282790"
      ]
    },
    {
      "abstract": "The emergence of a large number of new malicious code poses a serious threat to network security, and most of them are derivative versions of existing malicious code. The classification of malicious code is helpful to analyze the evolutionary trend of malicious code families and trace the source of cybercrime. The existing methods of malware classification emphasize the depth of the neural network, which has the problems of a long training time and large computational cost. In this work, we propose the shallow neural network-based malware classifier (SNNMAC), a malware classification model based on shallow neural networks and static analysis. Our approach bridges the gap between precise but slow methods and fast but less precise methods in existing works. For each sample, we first generate n-grams from their opcode sequences of the binary file with a decompiler. An improved n-gram algorithm based on control transfer instructions is designed to reduce the n-gram dataset. Then, the SNNMAC exploits a shallow neural network, replacing the full connection layer and softmax with the average pooling layer and hierarchical softmax, to learn from the dataset and perform classification. We perform experiments on the Microsoft malware dataset. The evaluation result shows that the SNNMAC outperforms most of the related works with 99.21% classification precision and reduces the training time by more than half when compared with the methods using DNN (Deep Neural Networks).",
      "authors": [
        "Yang, Pin",
        "Zhou, Huiyu",
        "Zhu, Yue",
        "Liu, Liang",
        "Zhang, Lei"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/fi12120219",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "1-17",
      "publication": {
        "category": "Journal",
        "cite_score": 6.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1999-5903",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.773,
        "snip": 1.225,
        "subject_areas": [
          "Computer Networks and Communications"
        ],
        "title": "Future Internet"
      },
      "publication_date": "2020-12-01",
      "selected": null,
      "title": "Malware Classification Based on Shallow Neural Network",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85097020574&origin=inward",
        "https://www.mdpi.com/1999-5903/12/12/219/pdf?version=1606996997"
      ]
    },
    {
      "abstract": "This paper introduces Tezla, an intermediate representation of Michelson smart contracts that eases the design of static smart contract analysers. This intermediate representation uses a store and aims to preserve the semantics, flow and resource usage of the original smart contract. This enables properties like gas consumption to be statically verified. We provide an automated decompiler of Michelson smart contracts to Tezla. In order to support our claim about the adequacy of Tezla, we develop a static analyser that takes advantage of the Tezla representation of Michelson smart contracts to prove simple but non-trivial properties.",
      "authors": [
        "Santos Reis, Jo\u00e3o",
        "Crocker, Paul",
        "Melo de Sousa, Sim\u00e3o"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.4230/OASIcs.FMBC.2020.4",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9783959771696",
        "issn": "21906807",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2nd Workshop on Formal Methods for Blockchains (FMBC 2020)"
      },
      "publication_date": "2020-12-01",
      "selected": null,
      "title": "Tezla, an Intermediate Representation for Static Analysis of Michelson Smart Contracts",
      "urls": [
        "https://drops.dagstuhl.de/storage/01oasics/oasics-vol084-fmbc2020/OASIcs.FMBC.2020.4/OASIcs.FMBC.2020.4.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85114211546&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Connor C.W."
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1213/ANE.0000000000005220",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "1923-1933",
      "publication": {
        "category": "Journal",
        "cite_score": 8.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00032999",
        "publisher": "Lippincott Williams and Wilkins Ltd.",
        "sjr": 1.365,
        "snip": 1.78,
        "subject_areas": [
          "Anesthesiology and Pain Medicine"
        ],
        "title": "Anesthesia and Analgesia"
      },
      "publication_date": "2020-12-01",
      "selected": null,
      "title": "A Forensic Disassembly of the BIS Monitor",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096045866&origin=inward"
      ]
    },
    {
      "abstract": "BACKGROUND The bispectral index (BIS) monitor has been available for clinical use for >20 years and has had an immense impact on academic activity in Anesthesiology, with >3000 articles referencing the bispectral index. Despite attempts to infer its algorithms by external observation, its operation has nevertheless remained undescribed, in contrast to the algorithms of other less commercially successful monitors of electroencephalogram (EEG) activity under anesthesia. With the expiration of certain key patents, the time is therefore ripe to examine the operation of the monitor on its own terms through careful dismantling, followed by extraction and examination of its internal software.\nMETHODS An A-2000 BIS Monitor (gunmetal blue case, amber monochrome display) was purchased on the secondary market. After identifying the major data processing and storage components, a set of free or inexpensive tools was used to retrieve and disassemble the monitor's onboard software. The software executes primarily on an ARMv7 microprocessor (Sharp/NXP LH77790B) and a digital signal processor (Texas Instruments TMS320C32). The device software can be retrieved directly from the monitor's hardware by using debugging interfaces that have remained in place from its original development.\nRESULTS Critical numerical parameters such as the spectral edge frequency (SEF), total power, and BIS values were retraced from external delivery at the device's serial port back to the point of their calculation in the extracted software. In doing so, the locations of the critical algorithms were determined. To demonstrate the validity of the technique, the algorithms for SEF and total power were disassembled, comprehensively annotated and compared to their theoretically ideal behaviors. A bug was identified in the device's implementation of the SEF algorithm, which can be provoked by a perfectly isoelectric EEG.\nCONCLUSIONS This article demonstrates that the electronic design of the A-2000 BIS Monitor does not pose any insuperable obstacles to retrieving its device software in hexadecimal machine code form directly from the motherboard. This software can be reverse engineered through disassembly and decompilation to reveal the methods by which the BIS monitor implements its algorithms, which ultimately must form the definitive statement of its function. Without further revealing any algorithms that might be considered trade secrets, the manufacturer of the BIS monitor should be encouraged to release the device software in its original format to place BIS-related academic literature on a firm theoretical foundation and to promote further academic development of EEG monitoring algorithms.",
      "authors": [
        "Christopher W Connor"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "PubMed"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 11,
      "pages": "1923-1933",
      "publication": {
        "category": "Journal",
        "cite_score": 8.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1526-7598",
        "publisher": "Lippincott Williams and Wilkins Ltd.",
        "sjr": 1.365,
        "snip": 1.78,
        "subject_areas": [
          "Anesthesiology and Pain Medicine"
        ],
        "title": "Anesthesia and analgesia"
      },
      "publication_date": "2020-12-01",
      "selected": null,
      "title": "A Forensic Disassembly of the BIS Monitor.",
      "urls": []
    },
    {
      "abstract": null,
      "authors": [
        "Zhang L."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1088/1742-6596/1656/1/012031",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17426588",
        "publisher": "IOP Publishing Ltd.",
        "sjr": 0.183,
        "snip": 0.26,
        "subject_areas": [
          "Physics and Astronomy (all)"
        ],
        "title": "Journal of Physics: Conference Series"
      },
      "publication_date": "2020-11-07",
      "selected": null,
      "title": "Research and practice of software protection based on virtual shell technology",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096973401&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ullah F."
      ],
      "categories": null,
      "citations": 26,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.eti.2020.101091",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Environmental Technology and Innovation"
      },
      "publication_date": "2020-11-01",
      "selected": null,
      "title": "IoT-based green city architecture using secured and sustainable android services",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85089348015&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Erinfolami R.A."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3372297.3417251",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "133-148",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450370899",
        "issn": "15437221",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM Conference on Computer and Communications Security"
      },
      "publication_date": "2020-10-30",
      "selected": null,
      "title": "Devil is Virtual: Reversing Virtual Inheritance in C++ Binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096191598&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Guan J."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1088/1742-6596/1634/1/012027",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17426588",
        "publisher": "IOP Publishing Ltd.",
        "sjr": 0.183,
        "snip": 0.26,
        "subject_areas": [
          "Physics and Astronomy (all)"
        ],
        "title": "Journal of Physics: Conference Series"
      },
      "publication_date": "2020-10-13",
      "selected": null,
      "title": "The feature selection based on AndroidManifest.xml",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096427495&origin=inward"
      ]
    },
    {
      "abstract": "The article describes the author's source of interest in the BESM-6 computer, its software, and the history of development of simulators of the BESM-6 architecture, and provides comments and observations regarding decompilation of a Pascal compiler for the BESM-6 and of the strategy game Kalah.",
      "authors": [
        "Leonid A. Broukhis"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SORUCOM51654.2020.9464996",
      "keywords": [
        "BESM-6",
        "simulation",
        "DISPAK",
        "FORTRAN",
        "Dubna monitor system",
        "Pascal",
        "ALGOL-60"
      ],
      "number_of_pages": 5,
      "pages": "67-71",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-6654-3133-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Selected Papers 2020 5th International Conference on the History of Computers and Informatics in the Soviet Union, Russian Federation and in the Countries of Mutual Economic Assistance Council, SoRuCom 2020"
      },
      "publication_date": "2020-10-06",
      "selected": null,
      "title": "Notes on Simulating the BESM-6 and Decompiling Pascal Programs",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9464996",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85113877804&origin=inward"
      ]
    },
    {
      "abstract": "Decompilers are fundamental tools to perform security assessments of third-party software. The quality of decompiled code can be a game changer in order to reduce the time and effort required for analysis. This paper proposes a novel approach to restructure the control flow graph recovered from binary programs in a semantics-preserving fashion. The algorithm is designed from the ground up with the goal of producing C code that is both goto-free and drastically reducing the mental load required for an analyst to understand it. As a result, the code generated with this technique is well-structured, idiomatic, readable, easy to understand and fully exploits the expressiveness of C language. The algorithm has been implemented on top of the revng static binary analysis framework. The resulting decompiler, revngc, is compared on real-world binaries with state-of-the-art commercial and open source tools. The results show that our decompilation process introduces between 40% and 50% less extra cyclomatic complexity.",
      "authors": [
        "Andrea Gussoni",
        "Alessandro Di Federico",
        "Pietro Fezzardi",
        "Giovanni Agosta"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3320269.3384766",
      "keywords": [
        "reverse engineering",
        "goto",
        "decompilation",
        "control flow restructuring"
      ],
      "number_of_pages": 15,
      "pages": "637-651",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450367509",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 15th ACM Asia Conference on Computer and Communications Security, ASIA CCS 2020"
      },
      "publication_date": "2020-10-05",
      "selected": null,
      "title": "A Comb for Decompiled C Code",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3320269.3384766",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85096387310&origin=inward"
      ]
    },
    {
      "abstract": "We describe a new approach to automatically repairing broken proofs in the\nCoq proof assistant in response to changes in types. Our approach combines a\nconfigurable proof term transformation with a decompiler from proof terms to\ntactic scripts. The proof term transformation implements transport across\nequivalences in a way that removes references to the old version of the changed\ntype and does not rely on axioms beyond those Coq assumes.\n  We have implemented this approach in PUMPKIN Pi, an extension to the PUMPKIN\nPATCH Coq plugin suite for proof repair. We demonstrate PUMPKIN Pi's\nflexibility on eight case studies, including supporting a benchmark from a user\nstudy, easing development with dependent types, porting functions and proofs\nbetween unary and binary numbers, and supporting an industrial proof engineer\nto interoperate between Coq and other verification tools more easily.",
      "authors": [
        "Talia Ringer",
        "RanDair Porter",
        "Nathaniel Yazdani",
        "John Leo",
        "Dan Grossman"
      ],
      "categories": null,
      "citations": 9,
      "comments": "Tool repository with code guide:\n  https://github.com/uwplse/pumpkin-pi/blob/v2.0.0/GUIDE.md",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": "10.1145/3453483.3454033",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "112-127",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450383912",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)"
      },
      "publication_date": "2020-10-02",
      "selected": null,
      "title": "Proof Repair across Type Equivalences",
      "urls": [
        "http://arxiv.org/pdf/2010.00774v4",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85108917985&origin=inward",
        "http://arxiv.org/abs/2010.00774v4",
        "http://dx.doi.org/10.1145/3453483.3454033"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Grech N."
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3416262",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "87-95",
      "publication": {
        "category": "Journal",
        "cite_score": 9.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00010782",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 1.514,
        "snip": 3.392,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Communications of the ACM"
      },
      "publication_date": "2020-09-23",
      "selected": null,
      "title": "MadMax: Analyzing the Out-of-Gas World of Smart Contracts",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85086824944&origin=inward"
      ]
    },
    {
      "abstract": "We present FoxDec: an approach to C code decompilation that aims at producing sound and recompilable code. Formal methods are used during three phases of the decompilation process: control flow recovery, symbolic execution, and variable analysis. The use of formal...",
      "authors": [
        "Verbeek, Freek",
        "Olivier, Pierre",
        "Ravindran, Binoy"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-58768-0_14",
      "keywords": [],
      "number_of_pages": 18,
      "pages": "247-264",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "978-3-030-58767-3",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Software Engineering and Formal Methods: 18th International Conference, SEFM 2020, Amsterdam, The Netherlands, September 14\u201318, 2020, Proceedings"
      },
      "publication_date": "2020-09-14",
      "selected": null,
      "title": "Sound C Code Decompilation for a Subset of x86-64 Binaries",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-030-58768-0_14.pdf",
        "https://dl.acm.org/doi/10.1007/978-3-030-58768-0_14",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85091581837&origin=inward"
      ]
    },
    {
      "abstract": "Mapping programs from one architecture to another plays a key role in technologies such as binary translation, decompilation, emulation, virtualization, and application migration. Although multicore architectures are ubiquitous, the state-of-the-art translation tools do not handle concurrency primitives correctly. Doing so is rather challenging because of the subtle differences in the concurrency models between architectures. In response, we address various aspects of the challenge. First, we develop correct and efficient translations between the concurrency models of two mainstream architecture families: x86 and ARM (versions 7 and 8). We develop direct mappings between x86 and ARMv8 and ARMv7, and fence elimination algorithms to eliminate redundant fences after direct mapping. Although our mapping utilizes ARMv8 as an intermediate model for mapping between x86 and ARMv7, we argue that it should not be used as an intermediate model in a decompiler because it disallows common compiler transformations. Second, we propose and implement a technique for inserting memory fences for safely migrating programs between different architectures. Our technique checks robustness against x86 and ARM, and inserts fences upon robustness violations. Our experiments demonstrate that in most of the programs both our techniques introduce significantly fewer fences compared to naive schemes for porting applications across these architectures.",
      "authors": [
        "Chakraborty, Soham"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2020-09-08",
      "selected": null,
      "title": "On Architecture to Architecture Mapping for Concurrency",
      "urls": [
        "http://arxiv.org/pdf/2009.03846.pdf",
        "http://arxiv.org/pdf/2009.03846v1",
        "http://arxiv.org/abs/2009.03846v1"
      ]
    },
    {
      "abstract": "Deep learning methods are gaining popularity in different application domains, and especially in natural language processing. It is commonly believed that using a large enough dataset and an adequate network architecture, almost any processing problem can be solved. A frequent and widely used typology is the encoder-decoder architecture, where the input data is transformed into an intermediate code by means of an encoder, and then a decoder takes this code to produce its output. Different types of networks can be used in the encoder and the decoder, depending on the problem of interest, such as convolutional neural networks (CNN) or long-short term memories (LSTM). This paper uses for the encoder a method recently proposed, called Causal Feature Extractor (CFE). It is based on causal convolutions (i.e., convolutions that depend only on one direction of the input), dilatation (i.e., increasing the aperture size of the convolutions) and bidirectionality (i.e., independent networks in both directions). Some preliminary results are presented on three different tasks and compared with state-of-the-art methods: bilingual translation, LaTeX decompilation and audio transcription. The proposed method achieves promising results, showing its ubiquity to work with text, audio and images. Moreover, it has a shorter training time, requiring less time per iteration, and a good use of the attention mechanisms based on attention matrices.",
      "authors": [
        "Javaloy, Adri\u00e1n",
        "Garc\u00eda-Mateos, Gin\u00e9s"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/app10175772",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 4.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2076-3417",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.492,
        "snip": 0.974,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)",
          "Process Chemistry and Technology",
          "Instrumentation",
          "Computer Science Applications",
          "Fluid Flow and Transfer Processes"
        ],
        "title": "Applied Sciences (Switzerland)"
      },
      "publication_date": "2020-09-01",
      "selected": null,
      "title": "Preliminary Results on Different Text Processing Tasks Using Encoder-Decoder Networks and the Causal Feature Extractor",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85090238601&origin=inward",
        "https://www.mdpi.com/2076-3417/10/17/5772/pdf?version=1597922878"
      ]
    },
    {
      "abstract": "More than eight million smart contracts have been deployed into Ethereum, which is the most popular blockchain that supports smart contract. However, less than 1% of deployed smart contracts are open-source, and it is difficult for users to understand the functionality and internal mechanism of those closed-source contracts. Although a few decompilers for smart contracts have been recently proposed, it is still not easy for users to grasp the semantic information of the contract, not to mention the potential misleading due to decompilation errors. In this paper, we propose the first system named STAN to generate descriptions for the bytecodes of smart contracts to help users comprehend them. In particular, for each interface in a smart contract, STAN can generate four categories of descriptions, including functionality description, usage description, behavior description, and payment description, by leveraging symbolic execution and NLP (Natural Language Processing) techniques. Extensive experiments show that STAN can generate adequate, accurate, and readable descriptions for contract's bytecodes, which have practical value for users.",
      "authors": [
        "Li, Xiaoqi",
        "Chen, Ting",
        "Luo, Xiapu",
        "Zhang, Tao",
        "Yu, Le",
        "Xu, Zhou"
      ],
      "categories": null,
      "citations": null,
      "comments": "In Proc. of the 20th IEEE International Conference on Software\n  Quality, Reliability and Security (QRS), 2020",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Software Engineering",
          "Cryptography and Security"
        ],
        "title": "In Proc. of the 20th IEEE International Conference on Software\n  Quality, Reliability and Security (QRS), 2020"
      },
      "publication_date": "2020-07-19",
      "selected": null,
      "title": "STAN: Towards Describing Bytecodes of Smart Contract",
      "urls": [
        "http://arxiv.org/abs/2007.09696v1",
        "http://arxiv.org/pdf/2007.09696.pdf",
        "http://arxiv.org/pdf/2007.09696v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yan W."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3395363.3404365",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "553-556",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450380089",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ISSTA 2020 - Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis"
      },
      "publication_date": "2020-07-18",
      "selected": null,
      "title": "EShield: Protect smart contracts against reverse engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85088916111&origin=inward"
      ]
    },
    {
      "abstract": " In this work, we test decompilation correctness to present an up-to-date understanding regarding modern C decompilers. We detected a total of 1,423 inputs that can trigger decompilation errors from four popular decompilers, and with extensive manual effort, we identified 13 bugs in two open-source decompilers. Our findings show that the overly pessimistic view of decompilation correctness leads researchers to underestimate the potential of modern decompilers; the state-of-the-art decompilers certainly care about the functional correctness, and they are making promising progress. However, some tasks that have been studied for years in academia, such as type inference and optimization, still impede C decompilers from generating quality outputs more than is reflected in the literature. These issues rarely receive enough attention and can lead to great confusion that misleads users.",
      "authors": [
        "Zhibo Liu",
        "Shuai Wang"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3395363.3397370",
      "keywords": [
        "Software Testing",
        "Decompiler",
        "Reverse Engineering"
      ],
      "number_of_pages": 13,
      "pages": "475-487",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450380089",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ISSTA 2020 - Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis"
      },
      "publication_date": "2020-07-18",
      "selected": null,
      "title": "How far we have come: testing decompilation correctness of C decompilers",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85088923487&origin=inward",
        "https://dl.acm.org/doi/10.1145/3395363.3397370"
      ]
    },
    {
      "abstract": "Machine learning and deep learning in particular has been recently used to successfully address many tasks in the domain of code such as fnding and fxing bugs, code completion, decompilation, type inference and many others. However, the issue of adversarial robustness of models for code has gone largely unnoticed. In this work, we explore this issue by: (i) instantiating adversarial attacks for code (a domain with discrete and highly structured inputs), (ii) showing that, similar to other domains, neural models for code are vulnerable to adversarial attacks, and (iii) combining existing and novel techniques to improve robustness while preserving high accuracy.",
      "authors": [
        "Pavol Bielik",
        "Martin Vechev"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/3524938.3525022",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "896-907",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "JMLR.org",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 37th International Conference on Machine Learning"
      },
      "publication_date": "2020-07-13",
      "selected": null,
      "title": "Adversarial robustness for code",
      "urls": [
        "https://dl.acm.org/doi/10.5555/3524938.3525022"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhao Y."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.cose.2020.101821",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 11.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01674048",
        "publisher": "Elsevier Ltd.",
        "sjr": 1.605,
        "snip": 2.232,
        "subject_areas": [
          "Computer Science (all)",
          "Law"
        ],
        "title": "Computers and Security"
      },
      "publication_date": "2020-07-01",
      "selected": null,
      "title": "Compile-time code virtualization for android applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85083780935&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Qasim S.A."
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.fsidi.2020.301013",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 5.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "26662825",
        "publisher": "Elsevier Ltd.",
        "sjr": 0.772,
        "snip": 1.445,
        "subject_areas": [
          "Pathology and Forensic Medicine",
          "Information Systems",
          "Computer Science Applications",
          "Law",
          "Medical Laboratory Technology"
        ],
        "title": "Forensic Science International: Digital Investigation"
      },
      "publication_date": "2020-07-01",
      "selected": null,
      "title": "Control Logic Forensics Framework using Built-in Decompiler of Engineering Software in Industrial Control Systems",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85106616970&origin=inward"
      ]
    },
    {
      "abstract": "This paper introduces Tezla, an intermediate representation of Michelson smart contracts that eases the design of static smart contract analysers. This intermediate representation uses a store and preserves the semantics, ow and resource usage of the original smart contract. This enables properties like gas consumption to be statically verified. We provide an automated decompiler of Michelson smart contracts to Tezla. In order to support our claim about the adequacy of Tezla, we develop a static analyser that takes advantage of the Tezla representation of Michelson smart contracts to prove simple but non-trivial properties.",
      "authors": [
        "Reis, Jo\u00e3o Santos",
        "Crocker, Paul",
        "de Sousa, Sim\u00e3o Melo"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2020-05-24",
      "selected": null,
      "title": "Tezla, an Intermediate Representation for Static Analysis of Michelson Smart Contracts",
      "urls": [
        "http://arxiv.org/pdf/2005.11839v1",
        "http://arxiv.org/abs/2005.11839v1",
        "http://arxiv.org/pdf/2005.11839.pdf"
      ]
    },
    {
      "abstract": "During compilation from Java source code to bytecode, some information is\nirreversibly lost. In other words, compilation and decompilation of Java code\nis not symmetric. Consequently, decompilation, which aims at producing source\ncode from bytecode, relies on strategies to reconstruct the information that\nhas been lost. Different Java decompilers use distinct strategies to achieve\nproper decompilation. In this work, we hypothesize that the diverse ways in\nwhich bytecode can be decompiled has a direct impact on the quality of the\nsource code produced by decompilers. In this paper, we assess the strategies of\neight Java decompilers with respect to three quality indicators: syntactic\ncorrectness, syntactic distortion and semantic equivalence modulo inputs. Our\nresults show that no single modern decompiler is able to correctly handle the\nvariety of bytecode structures coming from real-world programs. The highest\nranking decompiler in this study produces syntactically correct, and\nsemantically equivalent code output for 84%, respectively 78%, of the classes\nin our dataset. Our results demonstrate that each decompiler correctly handles\na different set of bytecode classes. We propose a new decompiler called\nArlecchino that leverages the diversity of existing decompilers. To do so, we\nmerge partial decompilation into a new one based on compilation errors.\nArlecchino handles 37.6% of bytecode classes that were previously handled by no\ndecompiler. We publish the sources of this new bytecode decompiler.",
      "authors": [
        "Nicolas Harrand",
        "C\u00e9sar Soto-Valero",
        "Martin Monperrus",
        "Benoit Baudry"
      ],
      "categories": null,
      "citations": 9,
      "comments": "arXiv admin note: substantial text overlap with arXiv:1908.06895",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": "10.1016/j.jss.2020.110645",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 9.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01641212",
        "publisher": "Elsevier Inc.",
        "sjr": 1.126,
        "snip": 2.032,
        "subject_areas": [
          "Software Engineering",
          "Hardware and Architecture",
          "Information Systems",
          "Software"
        ],
        "title": "Journal of Systems and Software, 2020"
      },
      "publication_date": "2020-05-21",
      "selected": null,
      "title": "Java Decompiler Diversity and its Application to Meta-decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85085736599&origin=inward",
        "http://arxiv.org/abs/2005.11315v1",
        "http://arxiv.org/pdf/2005.11315v1",
        "http://dx.doi.org/10.1016/j.jss.2020.110645"
      ]
    },
    {
      "abstract": "With the continuous popularization of smart terminals, Android and IOS systems are the most mainstream mobile operating systems in the market, and their application types and application numbers are constantly increasing. As an open system, the security issues of Android application emerge in endlessly, such as the reverse decompilation of installation package, malicious code injection, application piracy, interface hijacking, SMS hijacking and input monitoring. These security issues will also appear on mobile applications in the power industry, which will not only result in the embezzlement of applied knowledge copyrights but also lead to serious leakage of users' information and even economic losses. It may even result in the remote malicious control of key facilities, which will cause serious social issues. Under the background of the development of smart grid information construction, also with the application and promotion of power services in mobile terminals, information security protection for mobile terminal applications and interactions with the internal system of the power grid has also become an important research direction. While analyzing the risks faced by mobile applications, this article also enumerates and analyzes the necessary measures for risk resolution.",
      "authors": [
        "Li Feng",
        "Chen Tao",
        "Wang Bin",
        "Zhang Jianye",
        "Qing Song"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IPEC49694.2020.9115191",
      "keywords": [
        "information security",
        "mobile application",
        "power industry",
        "security reinforcement"
      ],
      "number_of_pages": 4,
      "pages": "51-54",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-6068-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of 2020 Asia-Pacific Conference on Image Processing, Electronics and Computers, IPEC 2020"
      },
      "publication_date": "2020-04-14",
      "selected": null,
      "title": "Research on Information Security Technology of Mobile Application in Electric Power Industry",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85089852486&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9115191"
      ]
    },
    {
      "abstract": "Complexities that arise from implementation of object-oriented concepts in C++ such as virtual dispatch and dynamic type casting have attracted the attention of attackers and defenders alike. Binary-level defenses are dependent on full and precise recovery of class inheritance tree of a given program. While current solutions focus on recovering single and multiple inheritances from the binary, they are oblivious to virtual inheritance. Conventional wisdom among binary-level defenses is that virtual inheritance is uncommon and/or support for single and multiple inheritances provides implicit support for virtual inheritance. In this paper, we show neither to be true. Specifically, (1) we present an efficient technique to detect virtual inheritance in C++ binaries and show through a study that virtual inheritance can be found in non-negligible number (more than 10\\% on Linux and 12.5\\% on Windows) of real-world C++ programs including Mysql and libstdc++. (2) we show that failure to handle virtual inheritance introduces both false positives and false negatives in the hierarchy tree. These false positves and negatives either introduce attack surface when the hierarchy recovered is used to enforce CFI policies, or make the hierarchy difficult to understand when it is needed for program understanding (e.g., during decompilation). (3) We present a solution to recover virtual inheritance from COTS binaries. We recover a maximum of 95\\% and 95.5\\% (GCC -O0) and a minimum of 77.5\\% and 73.8\\% (Clang -O2) of virtual and intermediate bases respectively in the virtual inheritance tree.",
      "authors": [
        "Erinfolami, Rukayat Ayomide",
        "Prakash, Aravind"
      ],
      "categories": null,
      "citations": null,
      "comments": "Accepted at CCS20. This is a technical report version",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2020-03-10",
      "selected": null,
      "title": "Devil is Virtual: Reversing Virtual Inheritance in C++ Binaries",
      "urls": [
        "http://arxiv.org/abs/2003.05039v2",
        "http://arxiv.org/pdf/2003.05039v2",
        "http://arxiv.org/pdf/2003.05039.pdf"
      ]
    },
    {
      "abstract": "Malware analysis is key for cybersecurity overall improvement. Analysis tools have been evolving from complete static analyzers to decompilers. Malware decompilation allows for code inspection at higher abstraction levels, easing incident response. However, the decompilation procedure has many challenges, such as opaque constructions, irreversible mappings, semantic gap bridging, among others. In this paper, we propose a new approach that leverages the human analyst expertise to overcome decompilation challenges. We name this approach \"DoD---debug-oriented decompilation\", in which the analyst is able to reverse engineer the malware sample on his own and to instruct the decompiler to translate selected code portions (e.g., decision branches, fingerprinting functions, payloads etc.) into high level code. With DoD, the analyst might group all decompiled pieces into new code to be analyzed by other tool, or to develop a novel malware sample from previous pieces of code and thus exercise a Proof-of-Concept (PoC). To validate our approach, we propose RevEngE, the Reverse Engineering Engine for malware decompilation and reassembly, a set of GDB extensions that intercept and introspect into executed functions to build an Intermediate Representation (IR) in real-time, enabling any-time decompilation. We evaluate RevEngE with x86 ELF binaries collected from VirusShare, and show that a new malware sample created from the decompilation of independent functions of five known malware samples is considered \"clean\" by all VirusTotal's AVs.",
      "authors": [
        "Marcus Botacin",
        "Lucas Galante",
        "Paulo de Geus",
        "Andr\u00e9 Gr\u00e9gio"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.1145/3375894.3375895",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "1-12",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450377751",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 3rd Reversing and Offensive-oriented Trends Symposium"
      },
      "publication_date": "2020-02-18",
      "selected": null,
      "title": "RevEngE is a dish served cold: Debug-Oriented Malware Decompilation and Reassembly",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3375894.3375895"
      ]
    },
    {
      "abstract": "Machine learning and deep learning in particular has been recently used to successfully address many tasks in the domain of code such as finding and fixing bugs, code completion, decompilation, type inference and many others. However, the issue of adversarial robustness of models for code has gone largely unnoticed. In this work, we explore this issue by: (i) instantiating adversarial attacks for code (a domain with discrete and highly structured inputs), (ii) showing that, similar to other domains, neural models for code are vulnerable to adversarial attacks, and (iii) combining existing and novel techniques to improve robustness while preserving high accuracy.",
      "authors": [
        "Bielik, Pavol",
        "Vechev, Martin"
      ],
      "categories": null,
      "citations": 23,
      "comments": "Proceedings of the 37th International Conference on Machine Learning,\n  Online, PMLR 119, 2020",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 12,
      "pages": "873-884",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781713821120",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "37th International Conference on Machine Learning, ICML 2020"
      },
      "publication_date": "2020-02-11",
      "selected": null,
      "title": "Adversarial Robustness for Code",
      "urls": [
        "http://arxiv.org/pdf/2002.04694.pdf",
        "http://arxiv.org/pdf/2002.04694v2",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85104682672&origin=inward",
        "http://arxiv.org/abs/2002.04694v2"
      ]
    },
    {
      "abstract": "The decompiler is one of the most common tools for examining binaries without corresponding source code. It transforms binaries into high-level code, reversing the compilation process. Decompilers can reconstruct much of the information that is lost during the compilation process (e.g., structure and type information). Unfortunately, they do not reconstruct semantically meaningful variable names, which are known to increase code understandability. We propose the Decompiled Identifier Renaming Engine (DIRE), a novel probabilistic technique for variable name recovery that uses both lexical and structural information recovered by the decompiler. We also present a technique for generating corpora suitable for training and evaluating models of decompiled code renaming, which we use to create a corpus of 164,632 unique x86-64 binaries generated from C projects mined from GitHub.1 Our results show that on this corpus DIRE can predict variable names identical to the names in the original source code up to 74.3% of the time.",
      "authors": [
        "Jeremy Lacomis",
        "Pengcheng Yin",
        "Edward J. Schwartz",
        "Miltiadis Allamanis",
        "Claire Le Goues",
        "Graham Neubig",
        "Bogdan Vasilescu"
      ],
      "categories": null,
      "citations": 47,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ASE.2019.00064",
      "keywords": [
        "Deep learning",
        "Decompilation"
      ],
      "number_of_pages": 12,
      "pages": "628-639",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781728125084",
        "issn": "1938-4300",
        "publisher": "IEEE Press",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2019 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019"
      },
      "publication_date": "2020-02-07",
      "selected": null,
      "title": "DIRE: a neural approach to decompiled identifier naming",
      "urls": [
        "https://dl.acm.org/doi/10.1109/ASE.2019.00064",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8952404",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85078913653&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Seraj S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3405962.3405980",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "205-209",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ACM International Conference Proceeding Series"
      },
      "publication_date": "2020-01-01",
      "selected": null,
      "title": "A Novel Dataset for Fake Android Anti-Malware Detection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85091504552&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Canfora G."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 13,
      "pages": "243-255",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16130073",
        "publisher": "CEUR-WS",
        "sjr": 0.202,
        "snip": 0.223,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "CEUR Workshop Proceedings"
      },
      "publication_date": "2020-01-01",
      "selected": null,
      "title": "Repadiography: Towards a visual support for triaging repackaged ApPs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85084749801&origin=inward"
      ]
    },
    {
      "abstract": "People believe that any sufficiently advanced technology is indistinguishable from magic. The ability to analyze and act on data is increasingly gaining importance in this ever-expanding world. Data forms an integral part of the identity of an individual or an...",
      "authors": [
        "Dutta, Ditipriya",
        "Agarwal, Shubham",
        "Dash, Ria",
        "Sahoo, Bhaswati"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-34080-3_46",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "410-417",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "978-3-030-34080-3",
        "issn": "23674512",
        "publisher": "Springer International Publishing AG",
        "sjr": 0.125,
        "snip": 0.104,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Media Technology",
          "Information Systems",
          "Computer Networks and Communications",
          "Computer Science Applications"
        ],
        "title": "International Conference on Intelligent Data Communication Technologies and Internet of Things"
      },
      "publication_date": "2020-01-01",
      "selected": null,
      "title": "A Detailed Analysis of Data Security Issues in Android Devices",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85083465124&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-030-34080-3_46.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Butz C.J."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 12,
      "pages": "53-64",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of Machine Learning Research"
      },
      "publication_date": "2020-01-01",
      "selected": null,
      "title": "Sum-Product Network Decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85162935067&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Li Z."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 2,
      "pages": "13861-13862",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781577358350",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "AAAI 2020 - 34th AAAI Conference on Artificial Intelligence"
      },
      "publication_date": "2020-01-01",
      "selected": null,
      "title": "Adabot: Fault-Tolerant Java Decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85106593254&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2020-01-01",
      "selected": null,
      "title": "18th International Conference on Software Engineering and Formal Methods, SEFM 2020",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85091556107&origin=inward"
      ]
    },
    {
      "abstract": "There exists a dichotomy between classical probabilistic graphical models, such as Bayesian networks (BNs), and modern tractable models, such as sum-product networks (SPNs). The former generally have intractable inference, but provide a high level of interpretability, while the latter admits a wide range of tractable inference routines, but are typically harder to interpret. Due to this dichotomy, tools to convert between BNs and SPNs are desirable. While one direction -- compiling BNs into SPNs -- is well discussed in Darwiche's seminal work on arithmetic circuit compilation, the converse direction -- decompiling SPNs into BNs -- has received surprisingly little attention. In this paper, we fill this gap by proposing SPN2BN, an algorithm that decompiles an SPN into a BN. SPN2BN has several salient features when compared to the only other two works decompiling SPNs. Most significantly, the BNs returned by SPN2BN are minimal independence-maps that are more parsimonious with respect to the introduction of latent variables. Secondly, the output BN produced by SPN2BN can be precisely characterized with respect to a compiled BN. More specifically, a certain set of directed edges will be added to the input BN, giving what we will call the moral-closure. Lastly, it is established that our compilation-decompilation process is idempotent. This has practical significance as it limits the size of the decompiled SPN.",
      "authors": [
        "Butz, Cory J.",
        "Oliveira, Jhonatan S.",
        "Peharz, Robert"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2019-12-20",
      "selected": null,
      "title": "Sum-Product Network Decompilation",
      "urls": [
        "http://arxiv.org/pdf/1912.10092v2",
        "http://arxiv.org/pdf/1912.10092.pdf",
        "http://arxiv.org/abs/1912.10092v2"
      ]
    },
    {
      "abstract": "Reverse engineering of binary executables is a critical problem in the computer security domain. On the one hand, malicious parties may recover interpretable source codes from the software products to gain commercial advantages. On the other hand, binary decompilation can be leveraged for code vulnerability analysis and malware detection. However, efficient binary decompilation is challenging. Conventional decompilers have the following major limitations: (i) they are only applicable to specific source-target language pair, hence incurs undesired development cost for new language tasks; (ii) their output high-level code cannot effectively preserve the correct functionality of the input binary; (iii) their output program does not capture the semantics of the input and the reversed program is hard to interpret. To address the above problems, we propose Coda1, the first end-to-end neural-based framework for code decompilation. Coda decomposes the decompilation task into of two key phases: First, Coda employs an instruction type-aware encoder and a tree decoder for generating an abstract syntax tree (AST) with attention feeding during the code sketch generation stage. Second, Coda then updates the code sketch using an iterative error correction machine guided by an ensembled neural error predictor. By finding a good approximate candidate and then fixing it towards perfect, Coda achieves superior performance compared to baseline approaches. We assess Coda's performance with extensive experiments on various benchmarks. Evaluation results show that Coda achieves an average of 82% program recovery accuracy on unseen binary samples, where the state-of-the-art decompilers yield 0% accuracy. Furthermore, Coda outperforms the sequence-to-sequence model with attention by a margin of 70% program accuracy. Our work reveals the vulnerability of binary executables and imposes a new threat to the protection of Intellectual Property (IP) for software development.",
      "authors": [
        "Cheng Fu",
        "Huili Chen",
        "Haolan Liu",
        "Xinyun Chen",
        "Yuandong Tian",
        "Farinaz Koushanfar",
        "Jishen Zhao"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/3454287.3454620",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "3708-3719",
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "Curran Associates Inc.",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 33rd International Conference on Neural Information Processing Systems"
      },
      "publication_date": "2019-12-08",
      "selected": null,
      "title": "Coda: an end-to-end neural program decompiler",
      "urls": [
        "https://dl.acm.org/doi/10.5555/3454287.3454620"
      ]
    },
    {
      "abstract": "Due to people in companies use mobile devices to access corporate data, attackers targeting corporate data use vulnerabilities in mobile devices. Most vulnerabilities in applications are caused by the carelessness of developers, and confused deputy attacks and data leak attacks using inter-application vulnerabilities are possible. These vulnerabilities are difficult to find through the single-application diagnostic tool that is currently being studied. This paper proposes a process to automate the decompilation of all the applications on a user\u2019s mobile device and a mechanism to find inter-application vulnerabilities. The mechanism generates a list and matrix, detailing the vulnerabilities in the mobile device. The proposed mechanism is validated through an experiment on an actual mobile device with four installed applications, and the results show that the mechanism can accurately capture all application risks as well as inter-application risks. Through this mechanism, users can expect to find the risks in their mobile devices in advance and prevent damage.",
      "authors": [
        "Yeom, Cheolmin",
        "Won, Yoojae"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/su11236637",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 5.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2071-1050",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.664,
        "snip": 1.198,
        "subject_areas": [
          "Hardware and Architecture",
          "Environmental Science (miscellaneous)",
          "Management, Monitoring, Policy and Law",
          "Geography, Planning and Development",
          "Renewable Energy, Sustainability and the Environment",
          "Computer Science (miscellaneous)",
          "Computer Networks and Communications",
          "Energy Engineering and Power Technology"
        ],
        "title": "Sustainability (Switzerland)"
      },
      "publication_date": "2019-12-01",
      "selected": null,
      "title": "Vulnerability Evaluation Method through Correlation Analysis of Android Applications",
      "urls": [
        "https://www.mdpi.com/2071-1050/11/23/6637/pdf?version=1574583872",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85076685329&origin=inward"
      ]
    },
    {
      "abstract": "We classify .NET files as either benign or malicious by examining directed graphs derived from the set of functions comprising the given file. Each graph is viewed probabilistically as a Markov chain where each node represents a code block of the corresponding function, and by computing the PageRank vector (Perron vector with transport), a probability measure can be defined over the nodes of the given graph. Each graph is vectorized by computing Lebesgue antiderivatives of hand-engineered functions defined on the vertex set of the given graph against the PageRank measure. Files are subsequently vectorized by aggregating the set of vectors corresponding to the set of graphs resulting from decompiling the given file. The result is a fast, intuitive, and easy-to-compute glass-box vectorization scheme, which can be leveraged for training a standalone classifier or to augment an existing feature space. We refer to this vectorization technique as PageRank Measure Integration Vectorization (PMIV). We demonstrate the efficacy of PMIV by training a vanilla random forest on 2.5 million samples of decompiled. NET, evenly split between benign and malicious, from our in-house corpus and compare this model to a baseline model which leverages a text-only feature space. The median time needed for decompilation and scoring was 24ms. 11Code available at https://github.com/gtownrocks/grafuple.",
      "authors": [
        "Michael Slawinski",
        "Andy Wortman"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICSRS48664.2019.8987703",
      "keywords": [
        "machine learning",
        "NET",
        "graph integration",
        "classification",
        "pagerank",
        "malware",
        "decompilation",
        "abstract syntax tree"
      ],
      "number_of_pages": 9,
      "pages": "16-24",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-4782-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2019 4th International Conference on System Reliability and Safety, ICSRS 2019"
      },
      "publication_date": "2019-11-20",
      "selected": null,
      "title": "Applications of Graph Integration to Function Comparison and Malware Classification",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8987703",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85080120018&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Rohleder R."
      ],
      "categories": null,
      "citations": 12,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3338503.3357725",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "77-78",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450368353",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "SPRO 2019 - Proceedings of the 3rd ACM Workshop on Software Protection"
      },
      "publication_date": "2019-11-15",
      "selected": null,
      "title": "Hands-On Ghidra - A Tutorial about the Software Reverse Engineering Framework",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85090494931&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhou S."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1088/1742-6596/1314/1/012195",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17426588",
        "publisher": "IOP Publishing Ltd.",
        "sjr": 0.183,
        "snip": 0.26,
        "subject_areas": [
          "Physics and Astronomy (all)"
        ],
        "title": "Journal of Physics: Conference Series"
      },
      "publication_date": "2019-11-06",
      "selected": null,
      "title": "Research on Android Application Reinforcement Method for Mobile Medical Service",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85075888567&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is frequently used to analyze binary programs. In Android, however, decompilers all perform differently with varying apps due to their own characteristics. Obviously, there is no universal solution in all conditions. Based on this observation, we present a practical Android app decompilation system (called Kerberoid) that automatically stitches the results from multiple decompilers together to maximize the coverage and the accuracy of decompiled codes. We evaluate the performance of Kerberoid with 151 Android apps in which their corresponding source codes are publicly available. Kerberoid fully recovered all functions for 17% of the apps tested and gained a similarity score over 50% for 40% of the apps tested, increased by 7% and 9%, respectively, compared with the best existing decompiler.",
      "authors": [
        "Heejun Jang",
        "Beomjin Jin",
        "Sangwon Hyun",
        "Hyoungshick Kim"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3319535.3363255",
      "keywords": [
        "reverse engineering",
        "mobile security",
        "decompilation",
        "android apps"
      ],
      "number_of_pages": 3,
      "pages": "2557-2559",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450367479",
        "issn": "15437221",
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security"
      },
      "publication_date": "2019-11-06",
      "selected": null,
      "title": "Kerberoid: A Practical Android App Decompilation System with Multiple Decompilers",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3319535.3363255",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85075915058&origin=inward"
      ]
    },
    {
      "abstract": "In this paper, we propose a detection algorithm for Android malicious code based on integrated multi-feature. By decompiling and processing APK files, the multi-class behavior features of Android application are extracted, and the classification is achieved through an integrated learning framework based on quadratic pruning optimization. The prototype system automatically detects the malicious code of the Android platform and analyzes the validity of the algorithm through experimental verification.",
      "authors": [
        "Qing Yu",
        "Kuolang Ma",
        "Zuohua Wang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CISP-BMEI48845.2019.8965960",
      "keywords": [
        "Multi-feature",
        "Pruning",
        "Android",
        "Optimization"
      ],
      "number_of_pages": 5,
      "pages": "1-5",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-4853-3",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2019 12th International Congress on Image and Signal Processing, BioMedical Engineering and Informatics, CISP-BMEI 2019"
      },
      "publication_date": "2019-10-19",
      "selected": null,
      "title": "Android Malicious Code Detection Based on Secondary Pruning Optimization",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8965960",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85079184110&origin=inward"
      ]
    },
    {
      "abstract": "Recent program synthesis techniques help users customize CAD models(e.g., for\n3D printing) by decompiling low-level triangle meshes to Constructive Solid\nGeometry (CSG) expressions. Without loops or functions, editing CSG can require\nmany coordinated changes, and existing mesh decompilers use heuristics that can\nobfuscate high-level structure.\n  This paper proposes a second decompilation stage to robustly \"shrink\"\nunstructured CSG expressions into more editable programs with map and fold\noperators. We present Szalinski, a tool that uses Equality Saturation with\nsemantics-preserving CAD rewrites to efficiently search for smaller equivalent\nprograms. Szalinski relies on inverse transformations, a novel way for solvers\nto speculatively add equivalences to an E-graph. We qualitatively evaluate\nSzalinski in case studies, show how it composes with an existing mesh\ndecompiler, and demonstrate that Szalinski can shrink large models in seconds.",
      "authors": [
        "Chandrakana Nandi",
        "Max Willsey",
        "Adam Anderson",
        "James R. Wilcox",
        "Eva Darulova",
        "Dan Grossman",
        "Zachary Tatlock"
      ],
      "categories": null,
      "citations": 43,
      "comments": "14 pages",
      "databases": [
        "arXiv",
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3385412.3386012",
      "keywords": [
        "Computer-Aided Design",
        "Equality Saturation",
        "Program Synthesis",
        "Decompilation"
      ],
      "number_of_pages": 14,
      "pages": "31-44",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450376136",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Programming Languages",
          "Computational Geometry"
        ],
        "title": "Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)"
      },
      "publication_date": "2019-09-26",
      "selected": null,
      "title": "Synthesizing Structured CAD Models with Equality Saturation and Inverse Transformations",
      "urls": [
        "http://dx.doi.org/10.1145/3385412.3386012",
        "http://arxiv.org/pdf/1909.12252v3",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85086820248&origin=inward",
        "https://dl.acm.org/doi/10.1145/3385412.3386012",
        "http://arxiv.org/abs/1909.12252v3"
      ]
    },
    {
      "abstract": "The decompiler is one of the most common tools for examining binaries without corresponding source code. It transforms binaries into high-level code, reversing the compilation process. Decompilers can reconstruct much of the information that is lost during the compilation process (e.g., structure and type information). Unfortunately, they do not reconstruct semantically meaningful variable names, which are known to increase code understandability. We propose the Decompiled Identifier Renaming Engine (DIRE), a novel probabilistic technique for variable name recovery that uses both lexical and structural information recovered by the decompiler. We also present a technique for generating corpora suitable for training and evaluating models of decompiled code renaming, which we use to create a corpus of 164,632 unique x86-64 binaries generated from C projects mined from GitHub. Our results show that on this corpus DIRE can predict variable names identical to the names in the original source code up to 74.3% of the time.",
      "authors": [
        "Lacomis, Jeremy",
        "Yin, Pengcheng",
        "Schwartz, Edward J.",
        "Allamanis, Miltiadis",
        "Goues, Claire Le",
        "Neubig, Graham",
        "Vasilescu, Bogdan"
      ],
      "categories": null,
      "citations": null,
      "comments": "2019 International Conference on Automated Software Engineering",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2019-09-19",
      "selected": null,
      "title": "DIRE: A Neural Approach to Decompiled Identifier Naming",
      "urls": [
        "http://arxiv.org/pdf/1909.09029v2",
        "http://arxiv.org/pdf/1909.09029.pdf",
        "http://arxiv.org/abs/1909.09029v2"
      ]
    },
    {
      "abstract": "During compilation from Java source code to bytecode, some information is\nirreversibly lost. In other words, compilation and decompilation of Java code\nis not symmetric. Consequently, the decompilation process, which aims at\nproducing source code from bytecode, must establish some strategies to\nreconstruct the information that has been lost. Modern Java decompilers tend to\nuse distinct strategies to achieve proper decompilation. In this work, we\nhypothesize that the diverse ways in which bytecode can be decompiled has a\ndirect impact on the quality of the source code produced by decompilers.\n  We study the effectiveness of eight Java decompilers with respect to three\nquality indicators: syntactic correctness, syntactic distortion and semantic\nequivalence modulo inputs. This study relies on a benchmark set of 14\nreal-world open-source software projects to be decompiled (2041 classes in\ntotal).\n  Our results show that no single modern decompiler is able to correctly handle\nthe variety of bytecode structures coming from real-world programs. Even the\nhighest ranking decompiler in this study produces syntactically correct output\nfor 84% of classes of our dataset and semantically equivalent code output for\n78% of classes.",
      "authors": [
        "Nicolas Harrand",
        "C\u00e9sar Soto-Valero",
        "Martin Monperrus",
        "Benoit Baudry"
      ],
      "categories": null,
      "citations": null,
      "comments": "11 pages, 6 figures, 9 listings, 3 tables",
      "databases": [
        "arXiv"
      ],
      "doi": "10.1109/scam.2019.00019",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Software Engineering"
        ],
        "title": "Proceedings of the 19th IEEE International Working Conference on\n  Source Code Analysis and Manipulation (SCAM 2019)"
      },
      "publication_date": "2019-08-19",
      "selected": null,
      "title": "The Strengths and Behavioral Quirks of Java Bytecode Decompilers",
      "urls": [
        "http://arxiv.org/abs/1908.06895v1",
        "http://arxiv.org/pdf/1908.06895v1",
        "http://dx.doi.org/10.1109/scam.2019.00019"
      ]
    },
    {
      "abstract": "Reverse Engineering(RE) has been a fundamental task in software engineering. However, most of the traditional Java reverse engineering tools are strictly rule defined, thus are not fault-tolerant, which pose serious problem when noise and interference were introduced into the system. In this paper, we view reverse engineering as a statistical machine translation task instead of rule-based task, and propose a fault-tolerant Java decompiler based on machine translation models. Our model is based on attention-based Neural Machine Translation (NMT) and Transformer architectures. First, we measure the translation quality on both the redundant and purified datasets. Next, we evaluate the fault-tolerance(anti-noise ability) of our framework on test sets with different unit error probability (UEP). In addition, we compare the suitability of different word segmentation algorithms for decompilation task. Experimental results demonstrate that our model is more robust and fault-tolerant compared to traditional Abstract Syntax Tree (AST) based decompilers. Specifically, in terms of BLEU-4 and Word Error Rate (WER), our performance has reached 94.50% and 2.65% on the redundant test set; 92.30% and 3.48% on the purified test set.",
      "authors": [
        "Li, Zhiming",
        "Wu, Qing",
        "Qian, Kun"
      ],
      "categories": null,
      "citations": null,
      "comments": "8 pages",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2019-08-14",
      "selected": null,
      "title": "Adabot: Fault-Tolerant Java Decompiler",
      "urls": [
        "http://arxiv.org/abs/1908.06748v2",
        "http://arxiv.org/pdf/1908.06748.pdf",
        "http://arxiv.org/pdf/1908.06748v2"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Kumar L."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3340422.3343639",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "33-40",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450368490",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the Asian Internet Engineering Conference, AINTEC 2019"
      },
      "publication_date": "2019-08-07",
      "selected": null,
      "title": "Android Malware Prediction Using Extreme Learning Machine with Different Kernel Functions",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85072050792&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "ZHANG J."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.19678/j.issn.1000-3428.0051790",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 0.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10003428",
        "publisher": "Shanghai Jisuanji Xuehui/Shanghai Computer Society",
        "sjr": 0.166,
        "snip": 0.463,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Computer Graphics and Computer-Aided Design",
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Jisuanji Gongcheng/Computer Engineering"
      },
      "publication_date": "2019-08-01",
      "selected": null,
      "title": "Research on Malware Code Classification Based on Features Fusion",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85133165689&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Liao F."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.19678/j.issn.1000-3428.0055156",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "25-30",
      "publication": {
        "category": "Journal",
        "cite_score": 0.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10003428",
        "publisher": "Shanghai Jisuanji Xuehui/Shanghai Computer Society",
        "sjr": 0.166,
        "snip": 0.463,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Computer Graphics and Computer-Aided Design",
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Jisuanji Gongcheng/Computer Engineering"
      },
      "publication_date": "2019-08-01",
      "selected": null,
      "title": "Vulnerability Analysis and Detection of Android System Signature",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85175118137&origin=inward"
      ]
    },
    {
      "abstract": "Recovering class inheritance from C++ binaries has several security benefits including in solving problems such as decompilation and program hardening. Thanks to the optimization guidelines prescribed by the C++ standard, commercial C++ binaries tend to be optimized. While state-of-the-art class inheritance inference solutions are effective in dealing with unoptimized code, their efficacy is impeded by optimization. Particularly, constructor inlining---or worse exclusion---due to optimization render class inheritance recovery challenging. Further, while modern solutions such as MARX can successfully group classes within an inheritance sub-tree, they fail to establish directionality of inheritance, which is crucial for security-related applications (e.g. decompilation). We implemented a prototype of DeClassifier using Binary Analysis Platform (BAP) and evaluated DeClassifier against 16 binaries compiled using gcc under multiple optimization settings. We show that (1) DeClassifier can recover 94.5% and 71.4% true positive directed edges in the class hierarchy tree (CHT) under O0 and O2 optimizations respectively, (2) a combination of constructor-destructor (ctor-dtor) analysis provides a substantial improvement in inheritance inference than constructor-only (ctor-only) analysis.",
      "authors": [
        "Rukayat Ayomide Erinfolami",
        "Aravind Prakash"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3321705.3329833",
      "keywords": [
        "software reverse engineering",
        "class hierarchy recovery"
      ],
      "number_of_pages": 13,
      "pages": "28-40",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450367523",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "AsiaCCS 2019 - Proceedings of the 2019 ACM Asia Conference on Computer and Communications Security"
      },
      "publication_date": "2019-07-02",
      "selected": null,
      "title": "DeClassifier: Class-Inheritance Inference Engine for Optimized C++ Binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85069973990&origin=inward",
        "https://dl.acm.org/doi/10.1145/3321705.3329833"
      ]
    },
    {
      "abstract": "Reverse engineering of binary executables is a critical problem in the computer security domain. On the one hand, malicious parties may recover interpretable source codes from the software products to gain commercial advantages. On the other hand, binary decompilation can be leveraged for code vulnerability analysis and malware detection. However, efficient binary decompilation is challenging. Conventional decompilers have the following major limitations: (i) they are only applicable to specific source-target language pair, hence incurs undesired development cost for new language tasks; (ii) their output high-level code cannot effectively preserve the correct functionality of the input binary; (iii) their output program does not capture the semantics of the input and the reversed program is hard to interpret. To address the above problems, we propose Coda, the first end-to-end neural-based framework for code decompilation. Coda decomposes the decompilation task into two key phases: First, Coda employs an instruction type-aware encoder and a tree decoder for generating an abstract syntax tree (AST) with attention feeding during the code sketch generation stage. Second, Coda then updates the code sketch using an iterative error correction machine guided by an ensembled neural error predictor. By finding a good approximate candidate and then fixing it towards perfect, Coda achieves superior performance compared to baseline approaches. We assess Coda's performance with extensive experiments on various benchmarks. Evaluation results show that Coda achieves an average of 82\\% program recovery accuracy on unseen binary samples, where the state-of-the-art decompilers yield 0\\% accuracy. Furthermore, Coda outperforms the sequence-to-sequence model with attention by a margin of 70\\% program accuracy.",
      "authors": [
        "Fu, Cheng",
        "Chen, Huili",
        "Liu, Haolan",
        "Chen, Xinyun",
        "Tian, Yuandong",
        "Koushanfar, Farinaz",
        "Zhao, Jishen"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2019-06-28",
      "selected": null,
      "title": "A Neural-based Program Decompiler",
      "urls": [
        "http://arxiv.org/abs/1906.12029v1",
        "http://arxiv.org/pdf/1906.12029v1",
        "http://arxiv.org/pdf/1906.12029.pdf"
      ]
    },
    {
      "abstract": "The rise of smart contracts - autonomous applications running on blockchains - has led to a growing number of threats, necessitating sophisticated program analysis. However, smart contracts, which transact valuable tokens and cryptocurrencies, are compiled to very low-level bytecode. This bytecode is the ultimate semantics and means of enforcement of the contract. We present the Gigahorse toolchain. At its core is a reverse compiler (i.e., a decompiler) that decompiles smart contracts from Ethereum Virtual Machine (EVM) bytecode into a highlevel 3-address code representation. The new intermediate representation of smart contracts makes implicit data- and control-flow dependencies of the EVM bytecode explicit. Decompilation obviates the need for a contract's source and allows the analysis of both new and deployed contracts. Gigahorse advances the state of the art on several fronts. It gives the highest analysis precision and completeness among decompilers for Ethereum smart contracts - e.g., Gigahorse can decompile over 99.98% of deployed contracts, compared to 88% for the recently-published Vandal decompiler and under 50% for the state-of-the-practice Porosity decompiler. Importantly, Gigahorse offers a full-featured toolchain for further analyses (and a \u201cbatteries included\u201d approach, with multiple clients already implemented), together with the highest performance and scalability. Key to these improvements is Gigahorse's use of a declarative, logic-based specification, which allows high-level insights to inform low-level decompilation.",
      "authors": [
        "Neville Grech",
        "Lexi Brent",
        "Bernhard Scholz",
        "Yannis Smaragdakis"
      ],
      "categories": null,
      "citations": 63,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICSE.2019.00120",
      "keywords": [
        "Program Analysis",
        "Ethereum",
        "Security",
        "Decompilation",
        "Blockchain"
      ],
      "number_of_pages": 11,
      "pages": "1176-1186",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 7.0,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-0870-4",
        "issn": "0270-5257",
        "publisher": "IEEE Computer Society",
        "sjr": 1.235,
        "snip": 1.945,
        "subject_areas": [
          "Software"
        ],
        "title": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)"
      },
      "publication_date": "2019-05-25",
      "selected": null,
      "title": "Gigahorse: thorough, declarative decompilation of smart contracts",
      "urls": [
        "https://dl.acm.org/doi/10.1109/ICSE.2019.00120",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8811905",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85072298992&origin=inward"
      ]
    },
    {
      "abstract": "We address the problem of automatic decompilation, converting a program in low-level representation back to a higher-level human-readable programming language. The problem of decompilation is extremely important for security researchers. Finding vulnerabilities and understanding how malware operates is much easier when done over source code. The importance of decompilation has motivated the construction of hand-crafted rule-based decompilers. Such decompilers have been designed by experts to detect specific control-flow structures and idioms in low-level code and lift them to source level. The cost of supporting additional languages or new language features in these models is very high. We present a novel approach to decompilation based on neural machine translation. The main idea is to automatically learn a decompiler from a given compiler. Given a compiler from a source language S to a target language T , our approach automatically trains a decompiler that can translate (decompile) T back to S . We used our framework to decompile both LLVM IR and x86 assembly to C code with high success rates. Using our LLVM and x86 instantiations, we were able to successfully decompile over 97% and 88% of our benchmarks respectively.",
      "authors": [
        "Katz, Omer",
        "Olshaker, Yuval",
        "Goldberg, Yoav",
        "Yahav, Eran"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2019-05-20",
      "selected": null,
      "title": "Towards Neural Decompilation",
      "urls": [
        "http://arxiv.org/pdf/1905.08325v1",
        "http://arxiv.org/pdf/1905.08325.pdf",
        "http://arxiv.org/abs/1905.08325v1"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781728112886",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2019 International Conference on Platform Technology and Service, PlatCon 2019 - Proceedings"
      },
      "publication_date": "2019-03-18",
      "selected": null,
      "title": "2019 International Conference on Platform Technology and Service, PlatCon 2019 - Proceedings",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85063907129&origin=inward"
      ]
    },
    {
      "abstract": "In this paper we propose a deep learning framework for classification of malware. There has been an enormous increase in the volume of malware generated lately which represents a genuine security danger to organizations and people. So as to battle the expansion of malwares, new strategies are needed to quickly identify and classify malware. Malimg dataset, a publicly available benchmark data set was used for the experimentation. The architecture used in this work is a hybrid cost-sensitive network of one-dimensional Convolutional Neural Network (CNN) and Long Short-Term Memory (LSTM) network which obtained an accuracy of 94.4%, an increase in performance compared to work done by [1] which got 84.9%. Hyper parameter tuning is done on deep learning architecture to set the parameters. A learning rate of 0.01 was taken for all experiments. Train-test split of 70-30% was done during experimentation. This facilitates to find how well the models perform on imbalanced data sets. Usual methods like disassembly, decompiling, de-obfuscation or execution of the binary need not be done in this proposed method. The source code and the trained models are made publicly available for further research.",
      "authors": [
        "S. Akarsh",
        "K. Simran",
        "Prabaharan Poornachandran",
        "Vijay Krishna Menon",
        "K.P. Soman"
      ],
      "categories": null,
      "citations": 24,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICACCS.2019.8728471",
      "keywords": [
        "machine learning",
        "deep learning",
        "cost-sensitive learning",
        "Malware",
        "image processing"
      ],
      "number_of_pages": 5,
      "pages": "1059-1063",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-9534-0",
        "issn": "2469-5556",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2019 5th International Conference on Advanced Computing and Communication Systems, ICACCS 2019"
      },
      "publication_date": "2019-03-15",
      "selected": null,
      "title": "Deep Learning Framework and Visualization for Malware Classification",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85067911208&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8728471"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Song Y."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3785/j.issn.1008-973X.2019.03.017",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "555-562",
      "publication": {
        "category": "Journal",
        "cite_score": 1.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1008973X",
        "publisher": "Zhejiang University Press",
        "sjr": 0.21,
        "snip": 0.415,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Zhejiang Daxue Xuebao (Gongxue Ban)/Journal of Zhejiang University (Engineering Science)"
      },
      "publication_date": "2019-03-01",
      "selected": null,
      "title": "Android APP reinforcement method with function Nativeization",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85066424438&origin=inward"
      ]
    },
    {
      "abstract": "Recovering class inheritance from C++ binaries has several security benefits including problems such as decompilation and program hardening. Thanks to the optimization guidelines prescribed by the C++ standard, commercial C++ binaries tend to be optimized. While state-of-the-art class inheritance inference solutions are effective in dealing with unoptimized code, their efficacy is impeded by optimization. Particularly, constructor inlining--or worse exclusion--due to optimization render class inheritance recovery challenging. Further, while modern solutions such as MARX can successfully group classes within an inheritance sub-tree, they fail to establish directionality of inheritance, which is crucial for security-related applications (e.g. decompilation). We implemented a prototype of DeClassifier using Binary Analysis Platform (BAP) and evaluated DeClassifier against 16 binaries compiled using gcc under multiple optimization settings. We show that (1) DeClassifier can recover 94.5% and 71.4% true positive directed edges in the class hierarchy tree under O0 and O2 optimizations respectively, (2) a combination of ctor+dtor analysis provides much better inference than ctor only analysis.",
      "authors": [
        "Erinfolami, Rukayat Ayomide",
        "Prakash, Aravind"
      ],
      "categories": null,
      "citations": null,
      "comments": "13 pages of main paper including references, 1 page of appendix, 2\n  figures and 10 tables",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2019-01-29",
      "selected": null,
      "title": "DeClassifier: Class-Inheritance Inference Engine for Optimized C++ Binaries",
      "urls": [
        "http://arxiv.org/abs/1901.10073v2",
        "http://arxiv.org/pdf/1901.10073.pdf",
        "http://arxiv.org/pdf/1901.10073v2"
      ]
    },
    {
      "abstract": "Nowadays, many applications tend to collect user profile, such as location, usage trace and so on, even if it is not malicious. This information can be important clues in the criminal investigation. So, the technique is needed which extract artifacts from applications using decompilation. We describe a method for selecting and analyzing forensic artifacts from the Android application with a share of over 80% of mobile devices. Based on the static analysis method, we propose a method for automatically collecting forensic artifact. The effectiveness of the proposed idea is proved by simulation.",
      "authors": [
        "Dongkyun Yoo",
        "Yeonghun Shin",
        "SungJin Kim",
        "HyunJin Kim",
        "SungMoon Kwon",
        "Taeshik Shon"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/PlatCon.2019.8668959",
      "keywords": [
        "APK Decompilation",
        "Reverse Engineering"
      ],
      "number_of_pages": 3,
      "pages": "1-3",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-1289-3",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2019 International Conference on Platform Technology and Service, PlatCon 2019 - Proceedings"
      },
      "publication_date": "2019-01-28",
      "selected": null,
      "title": "Digital Forensic Artifact Collection Technique using Application Decompilation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8668959",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85063869854&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Roessle I."
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3293880.3294102",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "181-195",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450362221",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "CPP 2019 - Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, Co-located with POPL 2019"
      },
      "publication_date": "2019-01-14",
      "selected": null,
      "title": "Formally verified big step semantics out of x86-64 binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85061199480&origin=inward"
      ]
    },
    {
      "abstract": "During compilation from Java source code to bytecode, some information is irreversibly lost. In other words, compilation and decompilation of Java code is not symmetric. Consequently, the decompilation process, which aims at producing source code from bytecode, must establish some strategies to reconstruct the information that has been lost. Modern Java decompilers tend to use distinct strategies to achieve proper decompilation. In this work, we hypothesize that the diverse ways in which bytecode can be decompiled has a direct impact on the quality of the source code produced by decompilers. We study the effectiveness of eight Java decompilers with respect to three quality indicators: syntactic correctness, syntactic distortion and semantic equivalence modulo inputs. This study relies on a benchmark set of 14 real-world open-source software projects to be decompiled (2041 classes in total). Our results show that no single modern decompiler is able to correctly handle the variety of bytecode structures coming from real-world programs. Even the highest ranking decompiler in this study produces syntactically correct output for 84% of classes of our dataset and semantically equivalent code output for 78% of classes.",
      "authors": [
        "Nicolas Harrand",
        "C\u00e9sar Soto-Valero",
        "Martin Monperrus",
        "Benoit Baudry"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2019.00019",
      "keywords": [
        "reverse engineering",
        "Java bytecode",
        "decompilation",
        "source code analysis"
      ],
      "number_of_pages": 11,
      "pages": "92-102",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-7281-4938-7",
        "issn": "1942-5430",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 19th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2019"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "The Strengths and Behavioral Quirks of Java Bytecode Decompilers",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8930870",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85077811612&origin=inward"
      ]
    },
    {
      "abstract": "Android usually employs the Secure Socket Layer (SSL) protocol to protect the user&#x2019;s privacy in network transmission. However, developers may misuse SSL-related APIs, which would lead attackers to steal user&#x2019;s privacy through man-in-the-middle attacks. Existing methods based on static decompiling technology to detect SSL security vulnerabilities of Android applications cannot cope with the increasingly common packed applications. Meanwhile, dynamic analysis approaches have the disadvantages of excessive resource consumption and time-consuming. In this paper, we propose a dynamic method to solve this issue based on our novel automatic traversal model. At first, we propose several new traversal strategies to optimize the widget tree according to the user interface (UI) types and the interface state similarity. Furthermore, we develop a more granular traversal model by refining the traversal level from the Activity component to the Widget and implement a heuristic depth-first traversal algorithm in combination with our customized traversal strategy. In addition, the man-in-the-middle agent plug-in is extended to implement real-time attack test and return the attack results. Based on the above ideas, we have implemented SSLDetecter, an efficient automated detection system of Android application SSL security vulnerability. We apply it on multiple devices in parallel to detect 2456 popular applications in several mainstream application markets and find that 424 applications are suffering from SSL security vulnerabilities. Compared with the existing system SMV-HUNTER, the time efficiency of our system increases by 38&#x0025; and the average detection rate increases by 6.39 percentage points, with many types of SSL vulnerabilities detected.",
      "authors": [
        "Tang, Junwei",
        "Li, Jingjing",
        "Li, Ruixuan",
        "Han, Hongmu",
        "Gu, Xiwu",
        "Xu, Zhiyong"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "https://doi.org/10.1155/2019/7193684",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19390114",
        "publisher": "Hindawi Limited",
        "sjr": 0.494,
        "snip": 0.785,
        "subject_areas": [
          "Computer Networks and Communications",
          "Information Systems"
        ],
        "title": "Security and Communication Networks"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "SSLDetecter: Detecting SSL Security Vulnerabilities of Android Applications Based on a Novel Automatic Traversal Method",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85075127216&origin=inward",
        "https://downloads.hindawi.com/journals/scn/2019/7193684.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "My\u0161ka M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Jusletter IT"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Internet of things, interoperability and interfaces: A copyright law perspective",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85074226003&origin=inward"
      ]
    },
    {
      "abstract": "\nWith the widespread use of the Android operating system, the number of applications based on the Android platform is growing. How to effectively identify malware is critical to the security of phones. This paper proposes an Android malware detection method based on...",
      "authors": [
        "Zhao, Chunhui",
        "Wang, Chundong",
        "Zheng, Wenbai"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-21373-2_10",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "105-113",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "9783030734282",
        "issn": "18678211",
        "publisher": "Springer Verlag",
        "sjr": 0.159,
        "snip": 0.137,
        "subject_areas": [
          "Computer Networks and Communications"
        ],
        "title": "Lecture Notes of the Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering, LNICST"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Android Malware Detection Based on Sensitive Permissions and APIs",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-030-21373-2_10.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85067617360&origin=inward"
      ]
    },
    {
      "abstract": "\nAndroid apps developed in Java language is vulnerable to repackaging attacks as it is easy to decompile an app. Therefore, obfuscation techniques can be used to make it difficult to analyzing the source of Android apps. However, repackaging attacks are fundamentally...",
      "authors": [
        "Lee, Hyung-Woo",
        "Lee, Jaekyu"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-13-0311-1_29",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "176-182",
      "publication": {
        "category": "Book",
        "cite_score": 0.6,
        "is_potentially_predatory": false,
        "isbn": "9789811303104",
        "issn": "18761100",
        "publisher": "Springer Verlag",
        "sjr": 0.147,
        "snip": 0.158,
        "subject_areas": [
          "Industrial and Manufacturing Engineering"
        ],
        "title": "International Conference on Ubiquitous Information Technologies and Applications, International Conference on Computer Science and its Applications"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Mobile Forged App Identification System with Centralized Signature Self-verification Method",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-981-13-0311-1_29.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85049587028&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cheremisinov D.I."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.17223/19988605/48/9",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "74-82",
      "publication": {
        "category": "Journal",
        "cite_score": 0.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19988605",
        "publisher": "Tomsk State University",
        "sjr": 0.141,
        "snip": 0.168,
        "subject_areas": [
          "Computer Networks and Communications",
          "Information Systems",
          "Computer Science Applications"
        ],
        "title": "Vestnik Tomskogo Gosudarstvennogo Universiteta - Upravlenie, Vychislitel'naya Tekhnika i Informatika"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Subcircuits discovery in transistor level CMOS circuits using graph mining",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85085568713&origin=inward"
      ]
    },
    {
      "abstract": "This paper presents Similo, an automated scalable framework for control logic forensics in industrial control systems. Similo is designed to investigate denial of engineering operations (DEO) attacks, recently demonstrated to hide malicious control logic in a...",
      "authors": [
        "Qasim, Syed Ali",
        "Lopez, Juan",
        "Ahmed, Irfan"
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-30215-3_20",
      "keywords": [],
      "number_of_pages": 21,
      "pages": "402-422",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Automated Reconstruction of Control Logic for Programmable Logic Controller Forensics",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-030-30215-3_20.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85072859530&origin=inward"
      ]
    },
    {
      "abstract": "\nMalicious programs like the viruses, worms, Trojan horses, and backdoors infect host computers by taking advantage of flaws of the software and thereby introducing some kind of secret functionalities. The authors of these malicious programs attempt to find new...",
      "authors": [
        "Behera, Chandan Kumar",
        "Sanjog, Genius",
        "Lalitha Bhaskari, D."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-10-8848-3_26",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "267-275",
      "publication": {
        "category": "Book",
        "cite_score": 0.9,
        "is_potentially_predatory": false,
        "isbn": "9783030631277",
        "issn": "21945357",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.215,
        "snip": 0.291,
        "subject_areas": [
          "Computer Science (all)",
          "Control and Systems Engineering"
        ],
        "title": "Proceedings of the Future Technologies Conference"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Control Flow Graph Matching for Detecting Obfuscated Programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85049079693&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-981-10-8848-3_26.pdf"
      ]
    },
    {
      "abstract": "Ransomware threat continues to grow over years. The existing defense techniques for detecting malicious malware will never be sufficient because of Malware Persistence Techniques. Packed malware makes analysis harder & also it may sound like a trusted executable...",
      "authors": [
        "Naveen, S.",
        "Gireesh Kumar, T."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-13-9942-8_18",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "185-194",
      "publication": {
        "category": "Book",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": "9789811399411",
        "issn": "18650929",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.194,
        "snip": 0.241,
        "subject_areas": [
          "Computer Science (all)",
          "Mathematics (all)"
        ],
        "title": "International Conference of Pioneering Computer Scientists, Engineers and Educators"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Ransomware Analysis Using Reverse Engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85070216800&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-981-13-9942-8_18.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yaseen A."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 8,
      "pages": "1239-1246",
      "publication": {
        "category": "Journal",
        "cite_score": 0.2,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "09743154",
        "publisher": "International Research Publication House",
        "sjr": 0.145,
        "snip": 0.316,
        "subject_areas": [
          "Engineering (all)",
          "Artificial Intelligence",
          "Environmental Engineering",
          "Chemical Engineering (all)",
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Energy Engineering and Power Technology",
          "Software"
        ],
        "title": "International Journal of Engineering Research and Technology"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Visualization and Synchronization of Object-oriented Programs using Re-engineering Approach",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85074791090&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Fu C."
      ],
      "categories": null,
      "citations": 29,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10495258",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Advances in Neural Information Processing Systems"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "Coda: An end-to-end neural program decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85085729737&origin=inward"
      ]
    },
    {
      "abstract": "With the development of software, software maintenance and software security become an important research of software engineering. Software reverse engineering plays an irreplaceable role in software maintenance and software security. In this paper, the applications...",
      "authors": [
        "Chen, Zhuangyou",
        "Pan, Bing",
        "Sun, Yanbin"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-24268-8_22",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "235-245",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2019-01-01",
      "selected": null,
      "title": "A Survey of Software Reverse Engineering Applications",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-030-24268-8_22.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85073898482&origin=inward"
      ]
    },
    {
      "abstract": "Along with new artifact development, software engineering also includes other tasks. One of these tasks is the reverse engineering of binary artifacts. This task can be performed by using special \u00e2\u0080\u009cdecompiler\u00e2\u0080\u009d software. In the present paper, the author performs a comparison of four different Java programming language decompilers that have been chosen based on both personal experience and results of a software developer survey.",
      "authors": [
        "Konstantins Gusarovs"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.2478/acss-2018-0014",
      "keywords": [
        "reverse engineering",
        "Java",
        "Decompilation"
      ],
      "number_of_pages": 9,
      "pages": "109-117",
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2255-8691",
        "publisher": "Walter de Gruyter GmbH",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Appl. Comput. Syst."
      },
      "publication_date": "2018-12-01",
      "selected": null,
      "title": "An Analysis on Java Programming Language Decompiler Capabilities",
      "urls": [
        "https://dl.acm.org/doi/10.2478/acss-2018-0014"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Li T."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.13209/j.0479-8023.2018.083",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "1147-1158",
      "publication": {
        "category": "Journal",
        "cite_score": 1.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "04798023",
        "publisher": "Peking University",
        "sjr": 0.171,
        "snip": 0.312,
        "subject_areas": [
          "Multidisciplinary"
        ],
        "title": "Beijing Daxue Xuebao (Ziran Kexue Ban)/Acta Scientiarum Naturalium Universitatis Pekinensis"
      },
      "publication_date": "2018-11-20",
      "selected": null,
      "title": "Noninvasive Repackaging Method Research for Android Supporting Packed Apps",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85058875177&origin=inward"
      ]
    },
    {
      "abstract": " In this paper, we classify and identify gas-focused vulnerabilities, and present MadMax: a static program analysis technique to automatically detect gas-focused vulnerabilities with very high confidence. Our approach combines a control-flow-analysis-based decompiler and declarative program-structure queries. The combined analysis captures high-level domain-specific concepts (such as \"dynamic data structure storage\" and \"safely resumable loops\") and achieves high precision and scalability. MadMax analyzes the entirety of smart contracts in the Ethereum blockchain in just 10 hours (with decompilation timeouts in 8% of the cases) and flags contracts with a (highly volatile) monetary value of over $2.8B as vulnerable. Manual inspection of a sample of flagged contracts shows that 81% of the sampled warnings do indeed lead to vulnerabilities, which we report on in our experiment.",
      "authors": [
        "Neville Grech",
        "Michael Kong",
        "Anton Jurisevic",
        "Lexi Brent",
        "Bernhard Scholz",
        "Yannis Smaragdakis"
      ],
      "categories": null,
      "citations": 211,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3276486",
      "keywords": [
        "Smart Contracts",
        "Program Analysis",
        "Blockchain",
        "Security"
      ],
      "number_of_pages": 27,
      "pages": "1-27",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM on Programming Languages"
      },
      "publication_date": "2018-10-24",
      "selected": null,
      "title": "MadMax: surviving out-of-gas conditions in Ethereum smart contracts",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85120140965&origin=inward",
        "https://dl.acm.org/doi/10.1145/3276486"
      ]
    },
    {
      "abstract": "Contrary to interacting with software remotely at runtime, commercial software may be altered by an attacker that is able to to change the meaning of the program at will by decompiling and recompiling the program. An attacker is able to coerce control-flow, manipulate predicates in order to lead the program into a favourable state. The aim of this paper is to present a strictly limited set of low-level attack patterns and to draw a parallel to exploits carried out against system software that cannot be tampered with.",
      "authors": [
        "Horia V. Corcalciuc"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ROLCG.2018.8572021",
      "keywords": [
        "control flow",
        "software protection",
        "predicate logic",
        "UML",
        "security"
      ],
      "number_of_pages": 4,
      "pages": "1-4",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-7043-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "11th ROLCG Conference on Grid, Cloud and High-Performance Computing in Science - Proceedings"
      },
      "publication_date": "2018-10-17",
      "selected": null,
      "title": "Low-Level Control-Flow Manipulation Techniques",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8572021",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85060481324&origin=inward"
      ]
    },
    {
      "abstract": "We classify .NET files as either benign or malicious by examining directed graphs derived from the set of functions comprising the given file. Each graph is viewed probabilistically as a Markov chain where each node represents a code block of the corresponding function, and by computing the PageRank vector (Perron vector with transport), a probability measure can be defined over the nodes of the given graph. Each graph is vectorized by computing Lebesgue antiderivatives of hand-engineered functions defined on the vertex set of the given graph against the PageRank measure. Files are subsequently vectorized by aggregating the set of vectors corresponding to the set of graphs resulting from decompiling the given file. The result is a fast, intuitive, and easy-to-compute glass-box vectorization scheme, which can be leveraged for training a standalone classifier or to augment an existing feature space. We refer to this vectorization technique as PageRank Measure Integration Vectorization (PMIV). We demonstrate the efficacy of PMIV by training a vanilla random forest on 2.5 million samples of decompiled .NET, evenly split between benign and malicious, from our in-house corpus and compare this model to a baseline model which leverages a text-only feature space. The median time needed for decompilation and scoring was 24ms.",
      "authors": [
        "Slawinski, Michael A.",
        "Wortman, Andy"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2018-10-11",
      "selected": null,
      "title": "Applications of Graph Integration to Function Comparison and Malware Classification",
      "urls": [
        "http://arxiv.org/abs/1810.04789v6",
        "http://arxiv.org/pdf/1810.04789.pdf",
        "http://arxiv.org/pdf/1810.04789v6"
      ]
    },
    {
      "abstract": "Mobile app ads pose a far greater security threat to users than adverts on computer browsers. This is because app developers must embed a Software Development Kit (SDK), called an ad library or ad lib for short, provided by ad networks (i.e., ad companies) into their app program, and then merge and compile it into an Android PacKage (APK) execution file. The ad lib thus becomes a part of the entire app, and shares the whole permissions granted to the app. Unfortunately, this also resulted in many security issues, such as ad libs abusing the permissions to collect and leak private data, ad servers redirecting ad requests to download malicious JavaScript from unknown servers to execute it in the background of the mobile operating system without the user\u2019s consent. The more well-known an embedded ad lib, the safer the app may be, and vice versa. Importantly, while decompiling an APK to inspect its source code may not identify the ad lib(s), executing the app on a simulator can reveal the network behavior of the embedded ad lib(s). Ad libs exhibit different behavior patterns when communicating with ad servers. This study uses a dynamic analysis method to inspect an executing app, and plots the ad lib behavior patterns related to the advertisement into a graph. It is then determined whether or not the ad lib is from a trusted ad network using comparisons of graph similarities.",
      "authors": [
        "Su, Ming-Yang",
        "Wei, Hong-Siou",
        "Chen, Xin-Yu",
        "Lin, Po-Wei",
        "Qiu, Ding-You"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3390/app8101852",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 4.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2076-3417",
        "publisher": "Multidisciplinary Digital Publishing Institute (MDPI)",
        "sjr": 0.492,
        "snip": 0.974,
        "subject_areas": [
          "Engineering (all)",
          "Materials Science (all)",
          "Process Chemistry and Technology",
          "Instrumentation",
          "Computer Science Applications",
          "Fluid Flow and Transfer Processes"
        ],
        "title": "Applied Sciences (Switzerland)"
      },
      "publication_date": "2018-10-09",
      "selected": null,
      "title": "Using Ad-Related Network Behavior to Distinguish Ad Libraries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85054712912&origin=inward",
        "https://www.mdpi.com/2076-3417/8/10/1852/pdf?version=1539076543"
      ]
    },
    {
      "abstract": "Control flow obfuscation (CFO) alters the control flow path of a program without altering its semantics. Existing literature has proposed several techniques; however, a quick survey reveals a lack of clarity in the types of techniques proposed, and how many are unique. What is also unclear is whether there is a disparity in the theory and practice of CFO. In this paper, we systematically study CFO techniques proposed for Java programs, both from papers and commercially available tools. We evaluate 13 obfuscators using a dataset of 16 programs with varying software characteristics, and different obfuscator parameters. Each program is carefully reverse engineered to study the effect of obfuscation. Our study reveals that there are 36 unique techniques proposed in the literature and 7 from tools. Three of the most popular commercial obfuscators implement only 13 of the 36 techniques in the literature. Thus there appears to be a gap between the theory and practice of CFO. We propose a novel classification of the obfuscation techniques based on the underlying component of a program that is transformed. We identify the techniques that are potent against reverse engineering attacks, both from the perspective of a human analyst and an automated program decompiler. Our analysis reveals that majority of the tools do not implement these techniques, thus defeating the protection obfuscation offers. We furnish examples of select techniques and discuss our findings. To the best of our knowledge, we are the first to assemble such a research. This study will be useful to software designers to decide upon the best techniques to use based upon their needs, for researchers to understand the state-of-the-art and for commercial obfuscator developers to develop new techniques.",
      "authors": [
        "Kumar, Renuka",
        "Kurian, Anjana Mariam"
      ],
      "categories": null,
      "citations": null,
      "comments": "20 pages, 3 tables",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2018-09-28",
      "selected": null,
      "title": "A Systematic Study on Static Control Flow Obfuscation Techniques in Java",
      "urls": [
        "http://arxiv.org/pdf/1809.11037v1",
        "http://arxiv.org/pdf/1809.11037.pdf",
        "http://arxiv.org/abs/1809.11037v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Nandi C."
      ],
      "categories": null,
      "citations": 28,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3236794",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM on Programming Languages"
      },
      "publication_date": "2018-09-01",
      "selected": null,
      "title": "Functional programming for compiling and decompiling computer-aided design",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85097577890&origin=inward"
      ]
    },
    {
      "abstract": "Copying and pasting of source code is a common activity in software engineering. Often, the code is not copied as it is and it may be modified for various purposes; e.g. refactoring, bug fixing, or even software plagiarism. These code modifications could affect the performance of code similarity analysers including code clone and plagiarism detectors to some certain degree. We are interested in two types of code modification in this study: pervasive modifications, i.e. transformations that may have a global effect, and local modifications, i.e. code changes that are contained in a single method or code block. We evaluate 30 code similarity detection techniques and tools using five experimental scenarios for Java source code. These are (1) pervasively modified code, created with tools for source code and bytecode obfuscation, and boiler-plate code, (2) source code normalisation through compilation and decompilation using different decompilers, (3) reuse of optimal configurations over different data sets, (4) tool evaluation using ranked-based measures, and (5) local + global code modifications. Our experimental results show that in the presence of pervasive modifications, some of the general textual similarity measures can offer similar performance to specialised code similarity tools, whilst in the presence of boiler-plate code, highly specialised source code similarity detection techniques and tools outperform textual similarity measures. Our study strongly validates the use of compilation/decompilation as a normalisation technique. Its use reduced false classifications to zero for three of the tools. Moreover, we demonstrate that optimal configurations are very sensitive to a specific data set. After directly applying optimal configurations derived from one data set to another, the tools perform poorly on the new data set. The code similarity analysers are thoroughly evaluated not only based on several well-known pair-based and query-based error measures but also on each specific type of pervasive code modification. This broad, thorough study is the largest in existence and potentially an invaluable guide for future users of similarity detection in source code.",
      "authors": [
        "Ragkhitwetsagul, Chaiyong",
        "Krinke, Jens",
        "Clark, David"
      ],
      "categories": null,
      "citations": 84,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s10664-017-9564-7",
      "keywords": [],
      "number_of_pages": 56,
      "pages": "2464-2519",
      "publication": {
        "category": "Journal",
        "cite_score": 7.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "13823256",
        "publisher": "Springer Netherlands",
        "sjr": 1.287,
        "snip": 2.382,
        "subject_areas": [
          "Software"
        ],
        "title": "Empirical Software Engineering"
      },
      "publication_date": "2018-08-01",
      "selected": null,
      "title": "A comparison of code similarity analysers",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85032177107&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/s10664-017-9564-7.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Doshi S."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ICCUBEA.2018.8697714",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781538652572",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2018 4th International Conference on Computing, Communication Control and Automation, ICCUBEA 2018"
      },
      "publication_date": "2018-07-02",
      "selected": null,
      "title": "S3ntinel: An Extensible Static Analysis Framework for Android Applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85065170331&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Feichtner J."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3212480.3212487",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "236-247",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450357319",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "WiSec 2018 - Proceedings of the 11th ACM Conference on Security and Privacy in Wireless and Mobile Networks"
      },
      "publication_date": "2018-06-18",
      "selected": null,
      "title": "Automated binary analysis on iOS - a case study on cryptographic misuse in ios applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85050935588&origin=inward"
      ]
    },
    {
      "abstract": "When code is compiled, information is lost, including some of the structure of the original source code as well as local identifier names. Existing decompilers can reconstruct much of the original source code, but typically use meaningless placeholder variables for identifier names. Using variable names which are more natural in the given context can make the code much easier to interpret, despite the fact that variable names have no effect on the execution of the program. In theory, it is impossible to recover the original identifier names since that information has been lost. However, most code is natural: it is highly repetitive and predictable based on the context. In this paper we propose a technique that assigns variables meaningful names by taking advantage of this naturalness property. We consider decompiler output to be a noisy distortion of the original source code, where the original source code is transformed into the decompiler output. Using this noisy channel model, we apply standard statistical machine translation approaches to choose natural identifiers, combining a translation model trained on a parallel corpus with a language model trained on unmodified C code. We generate a large parallel corpus from 1.2 TB of C source code obtained from GitHub. Under the most conservative assumptions, our technique is still able to recover the original variable names up to 16.2% of the time, which represents a lower bound for performance.",
      "authors": [
        "Alan Jaffe",
        "Jeremy Lacomis",
        "Edward J. Schwartz",
        "Claire Le Goues",
        "Bogdan Vasilescu"
      ],
      "categories": null,
      "citations": 30,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3196321.3196330",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "20-30",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 7.0,
        "is_potentially_predatory": false,
        "isbn": "9781450357142",
        "issn": "02705257",
        "publisher": "IEEE Computer Society",
        "sjr": 1.235,
        "snip": 1.945,
        "subject_areas": [
          "Software"
        ],
        "title": "Proceedings - International Conference on Software Engineering"
      },
      "publication_date": "2018-05-28",
      "selected": null,
      "title": "Meaningful variable names for decompiled code: a machine translation approach",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3196321.3196330",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85051632684&origin=inward"
      ]
    },
    {
      "abstract": "This paper investigates the security and privacy of Internet-connected children's smart toys through case studies of three commercially available products. We conduct network and application vulnerability analyses of each toy using static and dynamic analysis techniques, including application binary decompilation and network monitoring. We discover several publicly undisclosed vulnerabilities that violate the Children's Online Privacy Protection Rule as well as the toys' individual privacy policies. These vulnerabilities, especially security flaws in network communications with first-party servers, are indicative of a disconnect between many Internet of Things toy developers and security and privacy best practices despite increased attention to Internet-connected toy hacking risks.",
      "authors": [
        "Gordon Chu",
        "Noah Apthorpe",
        "Nick Feamster"
      ],
      "categories": null,
      "citations": 52,
      "comments": "8 pages, 8 figures; publication version",
      "databases": [
        "arXiv",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/JIOT.2018.2866423",
      "keywords": [
        "Internet of Things (IoT)",
        "privacy",
        "Data security"
      ],
      "number_of_pages": 8,
      "pages": "978-985",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2372-2541",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Computers and Society",
          "Cryptography and Security"
        ],
        "title": "IEEE Internet of Things Journal (IoT-J), 2018"
      },
      "publication_date": "2018-05-07",
      "selected": null,
      "title": "Security and Privacy Analyses of Internet of Things Children's Toys",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85052705707&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8443103",
        "http://arxiv.org/abs/1805.02751v2",
        "http://dx.doi.org/10.1109/JIOT.2018.2866423",
        "http://arxiv.org/pdf/1805.02751v2"
      ]
    },
    {
      "abstract": "Configuring and maintaining a firewall configuration is notoriously hard. Policies are written in low-level, platform-specific languages where firewall rules are inspected and enforced along non trivial control flow paths. Further difficulties arise from Network Address Translation (NAT), since filters must be implemented with addresses translations in mind. In this work, we study the problem of decompiling a real firewall configuration into an abstract specification. This abstract version throws the low-level details away by exposing the meaning of the configuration, i.e., the allowed connections with possible address translations. The generated specification makes it easier for system administrators to check if: (i) the intended security policy is actually implemented; (ii) two configurations are equivalent; (iii) updates have the desired effect on the firewall behavior. The peculiarity of our approach is that is independent of the specific target firewall system and language. This independence is obtained through a generic intermediate language that provides the typical features of real configuration languages and that separates the specification of the rulesets, determining the destiny of packets, from the specification of the platform-dependent steps needed to elaborate packets. We present a tool that decompiles real firewall configurations from different systems into this intermediate language and uses the Z3 solver to synthesize the abstract specification that succinctly represents the firewall behavior and the NAT. Tests on real configurations show that the tool is effective: it synthesizes complex policies in a matter of minutes and, and it answers to specific queries in just a few seconds. The tool can also point out policy differences before and after configuration updates in a simple, tabular form.",
      "authors": [
        "Chiara Bodei",
        "Pierpaolo Degano",
        "Letterio Galletta",
        "Riccardo Focardi",
        "Mauro Tempesta",
        "Lorenzo Veronese"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/EuroSP.2018.00015",
      "keywords": [
        "Policy Synthesis",
        "Firewall configuration",
        "Network Security"
      ],
      "number_of_pages": 15,
      "pages": "92-106",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-4229-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 3rd IEEE European Symposium on Security and Privacy, EURO S and P 2018"
      },
      "publication_date": "2018-04-24",
      "selected": null,
      "title": "Language-Independent Synthesis of Firewall Policies",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8406593",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85045665063&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation, recovering source code from binary, is useful in many situations where it is necessary to analyze or understand software for which source code is not available. Source code is much easier for humans to read than binary code, and there are many tools available to analyze source code. Existing decompilation techniques often generate source code that is difficult for humans to understand because the generated code often does not use the coding idioms that programmers use. Differences from human-written code also reduce the effectiveness of analysis tools on the decompiled source code. To address the problem of differences between decompiled code and human-written code, we present a novel technique for decompiling binary code snippets using a model based on Recurrent Neural Networks. The model learns properties and patterns that occur in source code and uses them to produce decompilation output. We train and evaluate our technique on snippets of binary machine code compiled from C source code. The general approach we outline in this paper is not language-specific and requires little or no domain knowledge of a language and its properties or how a compiler operates, making the approach easily extensible to new languages and constructs. Furthermore, the technique can be extended and applied in situations to which traditional decompilers are not targeted, such as for decompilation of isolated binary snippets; fast, on-demand decompilation; domain-specific learned decompilation; optimizing for readability of decompilation; and recovering control flow constructs, comments, and variable or function names. We show that the translations produced by this technique are often accurate or close and can provide a useful picture of the snippet's behavior.",
      "authors": [
        "Deborah S. Katz",
        "Jason Ruchti",
        "Eric Schulte"
      ],
      "categories": null,
      "citations": 32,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SANER.2018.8330222",
      "keywords": [
        "recurrent neural networks",
        "translation",
        "decompilation",
        "deep learning"
      ],
      "number_of_pages": 11,
      "pages": "346-356",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-4970-1",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "25th IEEE International Conference on Software Analysis, Evolution and Reengineering, SANER 2018 - Proceedings"
      },
      "publication_date": "2018-03-20",
      "selected": null,
      "title": "Using recurrent neural networks for decompilation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8330222",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85051026285&origin=inward"
      ]
    },
    {
      "abstract": "Solidity is a language used for smart contracts on the Ethereum blockchain. Smart contracts are embedded procedures stored with the data they act upon. Debugging smart contracts is a really difficult task since once deployed, the code cannot be reexecuted and inspecting a simple attribute is not easily possible because data is encoded. In this paper, we address the lack of inspectability of a deployed contract by analyzing contract state using decompilation techniques driven by the contract structure definition. Our solution, SmartInspect, also uses a mirror-based architecture to represent locally object responsible for the interpretation of the contract state. SmartInspect allows contract developers to better visualize and understand the contract stored state without needing to redeploy, nor develop any ad-hoc code.",
      "authors": [
        "Santiago Bragagnolo",
        "Henrique Rocha",
        "Marcus Denker",
        "Stephane Ducasse"
      ],
      "categories": null,
      "citations": 58,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IWBOSE.2018.8327566",
      "keywords": [
        "Inspecting",
        "Smart Contracts",
        "Blockchain",
        "Solidity"
      ],
      "number_of_pages": 10,
      "pages": "9-18",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-5987-8",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2018 IEEE 1st International Workshop on Blockchain Oriented Software Engineering, IWBOSE 2018 - Proceedings"
      },
      "publication_date": "2018-03-20",
      "selected": null,
      "title": "SmartInspect: solidity smart contract inspector",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85049759806&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8327566"
      ]
    },
    {
      "abstract": "Ladder logic is a graphical programming language for PLCs that control physical processes such as power grid, pipelines, and chemical plants; PLCs are a common target of malicious modifications leading to the compromise of the control behavior (and potentially serious consequences). Our decompiler, Laddis, transforms a low-level representation to its corresponding high-level original representation comprising of graphical symbols and connections. The evaluation of the accuracy of the decompiler on the program of varying complexity demonstrates perfect reconstruction of the original program. We present three new attack scenarios on PLC-deployed ladder logic and demonstrate the effectiveness of the decompiler on these scenarios.",
      "authors": [
        "Saranyan Senthivel",
        "Shrey Dhungana",
        "Hyunguk Yoo",
        "Irfan Ahmed",
        "Vassil Roussev"
      ],
      "categories": null,
      "citations": 39,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3176258.3176319",
      "keywords": [
        "plc",
        "forensics",
        "protocol reverse engineering",
        "disassembler",
        "industrial control system",
        "ladder logic",
        "scada"
      ],
      "number_of_pages": 11,
      "pages": "319-329",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450356329",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "CODASPY 2018 - Proceedings of the 8th ACM Conference on Data and Application Security and Privacy"
      },
      "publication_date": "2018-03-13",
      "selected": null,
      "title": "Denial of Engineering Operations Attacks in Industrial Control Systems",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3176258.3176319",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85052027207&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhuang Y."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.cose.2017.10.004",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "57-72",
      "publication": {
        "category": "Journal",
        "cite_score": 11.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01674048",
        "publisher": "Elsevier Ltd.",
        "sjr": 1.605,
        "snip": 2.232,
        "subject_areas": [
          "Computer Science (all)",
          "Law"
        ],
        "title": "Computers and Security"
      },
      "publication_date": "2018-03-01",
      "selected": null,
      "title": "The performance cost of software obfuscation for Android applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85034587314&origin=inward"
      ]
    },
    {
      "abstract": "When code is compiled, information is lost, including some of the structure of the original source code as well as local identifier names. Existing decompilers can reconstruct much of the original source code, but typically use meaningless placeholder variables for identifier names. Using variable names which are more natural in the given context can make the code much easier to interpret, despite the fact that variable names have no effect on the execution of the program. In theory, it is impossible to recover the original identifier names since that information has been lost. However, most code is natural: it is highly repetitive and predictable based on the context. In this paper we propose a technique that assigns variables meaningful names by taking advantage of this naturalness property. We consider decompiler output to be a noisy distortion of the original source code, where the original source code is transformed into the decompiler output. Using this noisy channel model, we apply standard statistical machine translation approaches to choose natural identifiers, combining a translation model trained on a parallel corpus with a language model trained on unmodified C code. We generate a large parallel corpus from 1.2 TB of C source code obtained from GitHub. Under the most conservative assumptions, our technique is still able to recover the original variable names up to 16.2% of the time, which represents a lower bound for performance.",
      "authors": [
        "Alan Jaffe",
        "Jeremy Lacomis",
        "Edward J. Schwartz",
        "Claire Le Goues",
        "Bogdan Vasilescu"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": null,
      "keywords": [
        "Renaming Identifiers",
        "Statistical Machine Translation",
        "Understandability",
        "Decompilation"
      ],
      "number_of_pages": 1991,
      "pages": "20-2010",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "979-8-3503-3751-8",
        "issn": "2643-7147",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2023 IEEE/ACM 31st International Conference on Program Comprehension (ICPC)"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Meaningful Variable Names for Decompiled Code: A Machine Translation Approach",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8973072"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lee J."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3923/jeasci.2018.1567.1574",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "1567-1574",
      "publication": {
        "category": "Journal",
        "cite_score": 0.2,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "1816949X",
        "publisher": "Medwell Journals",
        "sjr": 0.154,
        "snip": 0.472,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Journal of Engineering and Applied Sciences"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Forged Android Mobile Apps. Detection system with server-side signature verification method",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85046799391&origin=inward"
      ]
    },
    {
      "abstract": "\nAnalysts sometimes need to analyze the app depending on the situation. There are two main ways to analyze Android apps. This is the static analysis that grasps the flow of the app through the source code and the dynamic analysis that analyzes the variable that...",
      "authors": [
        "Lee, Suhyoo",
        "Park, Junhoo",
        "Ryou, Jaecheol"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-10-7605-3_125",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "784-789",
      "publication": {
        "category": "Book",
        "cite_score": 0.6,
        "is_potentially_predatory": false,
        "isbn": "9789811303104",
        "issn": "18761100",
        "publisher": "Springer Verlag",
        "sjr": 0.147,
        "snip": 0.158,
        "subject_areas": [
          "Industrial and Manufacturing Engineering"
        ],
        "title": "International Conference on Ubiquitous Information Technologies and Applications, International Conference on Computer Science and its Applications"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Method to Modify the Hex of Android Manifest File in Android Apps for Dynamic Analysis",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85039445586&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-981-10-7605-3_125.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Muslimin"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 12,
      "pages": "107-118",
      "publication": {
        "category": "Journal",
        "cite_score": 2.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "02161370",
        "publisher": "Universitas Negeri Yogyakarta (Yogyakarta State University)",
        "sjr": 0.362,
        "snip": 0.74,
        "subject_areas": [
          "Education"
        ],
        "title": "Cakrawala Pendidikan"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Foster a culture of literacy through increased reading interest in village communities",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85057441025&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yu B."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1504/IJSN.2018.090643",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "51-57",
      "publication": {
        "category": "Journal",
        "cite_score": 1.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17478405",
        "publisher": "Inderscience Enterprises Ltd",
        "sjr": 0.18,
        "snip": 0.237,
        "subject_areas": [
          "Computer Networks and Communications",
          "Safety, Risk, Reliability and Quality",
          "Electrical and Electronic Engineering"
        ],
        "title": "International Journal of Security and Networks"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "An android malware static detection scheme based on cloud security structure",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85044644931&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Li Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3923/jeasci.2018.3059.3066",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "3059-3066",
      "publication": {
        "category": "Journal",
        "cite_score": 0.2,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "1816949X",
        "publisher": "Medwell Journals",
        "sjr": 0.154,
        "snip": 0.472,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Journal of Engineering and Applied Sciences"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Key resources integrity verification scheme on Android platform",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85052457399&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lee Y.H."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.4337/ielr.2018.02.03",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "103-108",
      "publication": {
        "category": "Journal",
        "cite_score": 0.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "25153870",
        "publisher": "Edward Elgar Publishing Ltd.",
        "sjr": 0.2,
        "snip": 1.843,
        "subject_areas": [
          "Law"
        ],
        "title": "Interactive Entertainment Law Review"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Making videogame history: Videogame preservation and copyright law",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85089235364&origin=inward"
      ]
    },
    {
      "abstract": "At present, smart watches are loved by users because of their convenience, high efficiency, aesthetics and practicality. Smart watches interconnect with matching smart phones instead of working individually to achieve their maximum functionality. The wireless network...",
      "authors": [
        "Han, Wencong",
        "Zhang, Quanxin",
        "Gao, Chongzhi",
        "Hu, Jingjing",
        "Yan, Fang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-030-05063-4_20",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "249-259",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Security Extension and Robust Upgrade of Smart-Watch Wi-Fi Controller Firmware",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85058663799&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-030-05063-4_20.pdf"
      ]
    },
    {
      "abstract": "Malware detection plays a crucial role in computer security. Recent researches mainly use machine learning based methods heavily relying on domain knowledge for manually extracting malicious features. In this paper, we propose MalNet, a novel malware detection method that learns features automatically from the raw data. Concretely, we first generate a grayscale image from malware file, meanwhile extracting its opcode sequences with the decompilation tool IDA. Then MalNet uses CNN and LSTM networks to learn from grayscale image and opcode sequence, respectively, and takes a stacking ensemble for malware classification. We perform experiments on more than 40,000 samples including 20,650 benign files collected from online software providers and 21,736 malwares provided by Microsoft. The evaluation result shows that MalNet achieves 99.88&#x25; validation accuracy for malware detection. In addition, we also take malware family classification experiment on 9 malware families to compare MalNet with other related works, in which MalNet outperforms most of related works with 99.36&#x25; detection accuracy and achieves a considerable speed-up on detecting efficiency comparing with two state-of-the-art results on Microsoft malware dataset.",
      "authors": [
        "Yan, Jinpei",
        "Qi, Yong",
        "Rao, Qifan"
      ],
      "categories": null,
      "citations": 130,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "https://doi.org/10.1155/2018/7247095",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19390114",
        "publisher": "Hindawi Limited",
        "sjr": 0.494,
        "snip": 0.785,
        "subject_areas": [
          "Computer Networks and Communications",
          "Information Systems"
        ],
        "title": "Security and Communication Networks"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Detecting Malware with an Ensemble Method Based on Deep Neural Network",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85045029483&origin=inward",
        "https://downloads.hindawi.com/journals/scn/2018/7247095.pdf"
      ]
    },
    {
      "abstract": "Storm has been a popular distributed real-time computation system for stream data processing, which currently provides an acker mechanism to enable all topologies to be processed reliably. In this paper, via the source code analysis, we point out that the acker...",
      "authors": [
        "Qian, Wenjun",
        "Shen, Qingni",
        "Yang, Yizhe",
        "Yang, Yahui",
        "Wu, Zhonghai"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-89500-0_56",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "661-673",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2018-01-01",
      "selected": null,
      "title": "Statically Defend Network Consumption Against Acker Failure Vulnerability in Storm",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85045966013&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-319-89500-0_56.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Kostelansky J."
      ],
      "categories": null,
      "citations": 10,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.23919/KIT.2017.8109451",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9788080405502",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2017 9th International Scientific Conference on Communication and Information Technologies, KIT 2017 - Proceedings"
      },
      "publication_date": "2017-11-14",
      "selected": null,
      "title": "An evaluation of output from current Java bytecode decompilers: Is it Android which is responsible for such quality boost?",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85040514763&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ji W."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1049/cje.2017.09.003",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "1118-1124",
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10224653",
        "publisher": "John Wiley and Sons Inc.",
        "sjr": 0.307,
        "snip": 0.587,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Applied Mathematics"
        ],
        "title": "Chinese Journal of Electronics"
      },
      "publication_date": "2017-11-10",
      "selected": null,
      "title": "Control structure analysis and recovery of embedded binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85037027471&origin=inward"
      ]
    },
    {
      "abstract": "Enterprise mobility management (EMM) solution is widely used to securely protect confidential information stored on an individual's smartphone, while increasing the efficiency because of BYOD policy. The application wrapping (Appwrapping) technology is one way to be applied EMM solutions, by modifying binary applications without the original source code. In the past, Appwrapping was performed to control permissions or APIs to protect privacy on Android. This method is applied collectively to the whole section, not a specific section of the app, so it is difficult to control the section (flow) desired by the user or the manager. In addition, system overhead can occur because the control is applied to the whole section of the app. In this paper, we propose a method to insert an additional security policy code at a certain interval position in the intermediate code of a binary app, so that it can be controlled at a specific interval rather than the whole interval of the app. The proposed method extracts and saves the security policy intermediate code and the related file in advance and then adds the security policy code to the specific method on the intermediate code of the specific activity acquired by decompiling the target app. Finally, the additional security policy code is modified to avoid errors caused by the additional code. We create an automation tool for performance verification, experiment with five commercial office apps, and confirm that the apps work properly with the added EMM security functions.",
      "authors": [
        "Sung-Hoon Lee",
        "Seung-Hyun Kim",
        "SooHyung Kim",
        "Seung-Hun Jin"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ISSREW.2017.25",
      "keywords": [
        "mobile security",
        "EMM",
        "Appwrapping"
      ],
      "number_of_pages": 4,
      "pages": "36-39",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-2388-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2017 IEEE 28th International Symposium on Software Reliability Engineering Workshops, ISSREW 2017"
      },
      "publication_date": "2017-10-23",
      "selected": null,
      "title": "Appwrapping Providing Fine-Grained Security Policy Enforcement Per Method Unit in Android",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8109245",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85040635182&origin=inward"
      ]
    },
    {
      "abstract": "In recent years, medicine has seen how technology was going day by day more present to become necessary. At the same time, security became a critical aspect, since private patient medical data are handled. In this field in which gather mobile technologies with medicine, security has great importance. Therefore, it is essential to conduct security audits to mobile applications which deal with private information and confidential patient data. The main objective of this paper is to carry out an audit of security of an mHealth Android application. Taking HeartKeeper application to self-manage cardiac patients, a series of tests and modifications are conducted to check its strengths and weaknesses. The methodology consists in attempting to decompile the application HeartKeeper. Applying to the source code techniques of reverse engineering, we will try to perform an analysis that allows us to carry out the security check of the Android application HeartKeeper. It can be applied to audit security on any other Android application. In this way, it provides developers a tool that allows them to check the security of any Android app. Among these vulnerabilities found, the most relevant is that which allows us to inject code to steal some private information. This information should only be accessible from the application itself and only once the user is authenticated. As solutions, we propose different protections. These are: protection against decompilation, against code analysis, and against modified applications. It is very important to carry out a comprehensive review of the mobile applications' strength, since they are increasingly present in our lives and they manage sensitive and protected data. It is highly recommended to install applications from trusty sources, as they are the official app stores like Google Play Store in Android and iOS App Store.",
      "authors": [
        "Isabel de la Torre-D\u00edez",
        "Bruno Olivar Trinchet",
        "Joel J.P.C. Rodrigues",
        "Miguel L\u00f3pez-Coronado"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/HealthCom.2017.8210757",
      "keywords": [
        "audit",
        "mhealth",
        "Android",
        "app",
        "security"
      ],
      "number_of_pages": 6,
      "pages": "1-6",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-6705-3",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2017 IEEE 19th International Conference on e-Health Networking, Applications and Services, Healthcom 2017"
      },
      "publication_date": "2017-10-12",
      "selected": null,
      "title": "Security analysis of a mHealth app in Android: Problems and solutions",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8210757",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85048535852&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Luk\u00e1cs D."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3123569.3123572",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "31-42",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450351799",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Erlang 2017 - Proceedings of the 16th ACM SIGPLAN International Workshop on Erlang, co-located with ICFP 2017"
      },
      "publication_date": "2017-09-08",
      "selected": null,
      "title": "Structuring Erlang BEAM control flow",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85031012966&origin=inward"
      ]
    },
    {
      "abstract": "In this paper we present a novel approach for static analysis we are using in bin2llvm, a work-in-progress analysis framework, in order to find and identify cryptographic routines in binary programs. Our approach does not need to run the target of analysis in any way and is based on decompilation of binaries to an intermediate language similar to assembly code, the LLVM Intermediate Representation (IR), by using the open source decompiler Dagger. After decompilation we are able to apply various analysis techniques to the resulting code. These methods can be easily implemented and extended as optimization passes for the LLVM optimizer and can therefore benefit from its extensive API. Although we discovered certain drawbacks and issues with this approach, our results and proof of concept show that IR code is a very suitable target for analyses and it is well worth driving research further into this topic.",
      "authors": [
        "Kevin Kirchner",
        "Stefan Rosenthaler"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/3098954.3103152",
      "keywords": [
        "Decompiler",
        "Intermediate Representation",
        "LLVM",
        "Analysis",
        "Binary",
        "Cryptography"
      ],
      "number_of_pages": 7,
      "pages": "1-7",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450352574",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 12th International Conference on Availability, Reliability and Security"
      },
      "publication_date": "2017-08-29",
      "selected": null,
      "title": "bin2llvm: Analysis of Binary Programs Using LLVM Intermediate Representation",
      "urls": [
        "https://dl.acm.org/doi/10.1145/3098954.3103152",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85030330734&origin=inward"
      ]
    },
    {
      "abstract": "There are many mobile operating systems for different smartphones. iOS is one of them available exclusively on Apple devices. It offers various features such as GPS tracking, Siri, multi touch gestures, biometric authentication etc. The functionality of an iOS device can be expanded by installing third party applications, available from App store. Apple follows a mandatory code signing process to ensure that applications are developed by trusted enterprises/developers and no malware exists on App Store. However, past attacks on iOS devices such as ikee, Wirelurker have revealed that Apple's code signing process is not sufficient to ensure the security of its devices. Considering past attacks on iOS devices and with view of analyzing the behavior of iOS applications, this paper aims to describe how an analyst can perform reverse engineering of iOS applications by disassembling, decompiling and debugging application's code using Disassembler to discover the vulnerable areas.",
      "authors": [
        "Chetna Gupta",
        "Arpita Jadhav Bhatt",
        "Sangeeta Mittal"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IC3.2017.8284326",
      "keywords": [
        "Code Patching",
        "Disassembling",
        "Reverse Engineering",
        "iOS application",
        "Interactive Disassembler"
      ],
      "number_of_pages": 6,
      "pages": "1-6",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5386-3078-5",
        "issn": "2572-6129",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2017 10th International Conference on Contemporary Computing, IC3 2017"
      },
      "publication_date": "2017-08-10",
      "selected": null,
      "title": "Disassembling and patching iOS applications at assembly level",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85046375916&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8284326"
      ]
    },
    {
      "abstract": "Android access control granularity based on its permission mechanism is relatively coarse, which cannot effectively protect the user privacy. Many Android applications do not strictly abide by the principle of least privilege (PLP). Both benign and malicious apps may request more permissions than those they really use. We rethink previous permission over-claim problem of Android applications, and extend it to three kinds of problems: Explicit Permission Over-claim, Implicit Permission Over-claim and Ad Library Permission Over-claim. The latter two problems are new that have not been raised by any previous work. Static analysis is to decompile the applications to generate intermediate code and then analyze the usage of permissions. Our static analysis on 10710 applications shows that 76.08% of them may have Explicit Permission Over-claim problem, among those there are 424 applications that have sensitive permissions, which are only used in the advertisement library's code of the applications rather than developer's own code. They have Ad Library Permission Over-claim problem. The main idea of our semantic analysis is to calculate the semantic similarity between apps' descriptions and function phrases. If the similarity exceeds a certain threshold, the app is considered relevant to the corresponding function. We compare the results of the semantic analysis with those of manual reading of 102 Android application descriptions. The F-measures of the three chosen functions are 80.82%, 70.48% and 89.62%, respectively. The evaluation results show our method can efficiently detect the above three kinds of permission over claim problems which indicates that our method would be helpful for normal users to have a clear understanding of permission usage of Android applications.",
      "authors": [
        "Junwei Tang",
        "Ruixuan Li",
        "Hongmu Han",
        "Heng Zhang",
        "Xiwu Gu"
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/Trustcom/BigDataSE/ICESS.2017.303",
      "keywords": [
        "Mobile security",
        "semantic analysis",
        "static analysis",
        "permission overclaim problem",
        "Android system"
      ],
      "number_of_pages": 8,
      "pages": "706-713",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-4907-3",
        "issn": "2324-9013",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 16th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, 11th IEEE International Conference on Big Data Science and Engineering and 14th IEEE International Conference on Embedded Software and Systems, Trustcom/BigDataSE/ICESS 2017"
      },
      "publication_date": "2017-08-01",
      "selected": null,
      "title": "Detecting Permission Over-claim of Android Applications with Static and Semantic Analysis Approach",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8029506",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85032360101&origin=inward"
      ]
    },
    {
      "abstract": "The domain of text-based adventure games has been recently established as a\nnew challenge of creating the agent that is both able to understand natural\nlanguage, and acts intelligently in text-described environments.\n  In this paper, we present our approach to tackle the problem. Our agent,\nnamed Golovin, takes advantage of the limited game domain. We use genre-related\ncorpora (including fantasy books and decompiled games) to create language\nmodels suitable to this domain. Moreover, we embed mechanisms that allow us to\nspecify, and separately handle, important tasks as fighting opponents, managing\ninventory, and navigating on the game map.\n  We validated usefulness of these mechanisms, measuring agent's performance on\nthe set of 50 interactive fiction games. Finally, we show that our agent plays\non a level comparable to the winner of the last year Text-Based Adventure AI\nCompetition.",
      "authors": [
        "Bartosz Kostka",
        "Jaroslaw Kwiecien",
        "Jakub Kowalski",
        "Pawel Rychlikowski"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": "10.1109/CIG.2017.8080433",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2017-05-16",
      "selected": null,
      "title": "Text-based Adventures of the Golovin AI Agent",
      "urls": [
        "http://arxiv.org/abs/1705.05637v1",
        "http://dx.doi.org/10.1109/CIG.2017.8080433",
        "http://arxiv.org/pdf/1705.05637v1"
      ]
    },
    {
      "abstract": "Program logical controllers (PLCs) are the kernel equipment of industrial control system (ICS) as they directly monitor and control industrial processes. Recently, ICS is suffering from various cyber threats, which may lead to significant consequences due to its inherent characteristics. In IT system, decompilation is a useful method to detect intrusion or to discovery vulnerabilities, however, it has yet not been developed in ICS. In this work, we present a technique to decompile the bytecode of PLC program. By introducing the instruction template and operand template, we propose a decompiling framework, which is validated by 11 PLC programs. In disassembling experiments, the present framework can cover all instructions with disassembling accuracy reaching 100%, this fully shows that our framework is able to effectively decompile the bytecode of PLC programs.",
      "authors": [
        "Xuefeng Lv",
        "Yaobin Xie",
        "Xiaodong Zhu",
        "Lu Ren"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IAEAC.2017.8054016",
      "keywords": [
        "bytecode",
        "mapping rules",
        "decompilation",
        "programmable logical controller"
      ],
      "number_of_pages": 6,
      "pages": "252-257",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4673-8980-8",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of 2017 IEEE 2nd Advanced Information Technology, Electronic and Automation Control Conference, IAEAC 2017"
      },
      "publication_date": "2017-03-25",
      "selected": null,
      "title": "A technique for bytecode decompilation of PLC program",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8054016",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85034604302&origin=inward"
      ]
    },
    {
      "abstract": "Reverse engineering is the process of decompiling and disassembling the executables to recover the source code/assembly code embedded within it. While reverse engineering is the process of examining the code, in offensive context the attackers can re-engineer the code which leads to software piracy. Software anti-tamper technology like obfuscation is used to deter both reverse engineering and re-engineering of proprietary software and software-powered systems. Code obfuscation, as a part of software protection, got commercial interest from both vendors and as well as from the clients. Vendors want to keep their proprietary code as secret and customers needs software upon which they can trust. In this article, a code obfuscation technique has been proposed to complicate the process of reverse engineering. The basic idea is to conceal the proprietary code section by using preventive design obfuscation and insertion of self-modifying code at the binary level. The combination of design level obfuscation and the insertion of self-modifying code converts the code into a semantically equivalent one that makes it difficult to reverse engineer. The technique is evaluated using different sorting algorithms. The experimental results quantify the degree of obfuscation, stealth of the code, and effects on execution time and code size.",
      "authors": [
        "Asish Kumar Dalai",
        "Shakya Sundar Das",
        "Sanjay Kumar Jena"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WiSPNET.2017.8299877",
      "keywords": [
        "Software Security",
        "Code Obfuscation",
        "Reverse Engineering"
      ],
      "number_of_pages": 5,
      "pages": "828-832",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-4443-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2017 International Conference on Wireless Communications, Signal Processing and Networking, WiSPNET 2017"
      },
      "publication_date": "2017-03-22",
      "selected": null,
      "title": "A code obfuscation technique to prevent reverse engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85046343079&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8299877"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781509065950",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IWSC 2017 - 11th IEEE International Workshop on Software Clones, co-located with SANER 2017"
      },
      "publication_date": "2017-03-16",
      "selected": null,
      "title": "IWSC 2017 - 11th IEEE International Workshop on Software Clones, co-located with SANER 2017",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85017217423&origin=inward"
      ]
    },
    {
      "abstract": "As the quality of crucial entities can directly affect that of software, their identification and protection become an important premise for effective software development, management, maintenance and testing, which thus contribute to improving the software quality and its attack-defending ability. Most analysis and evaluation on important entities like codes-based static structure analysis are on the destruction of the actual software running. In this paper, from the perspective of software execution process, we proposed an approach to mine dynamic noteworthy functions (DNFM)in software execution sequences. First, according to software decompiling and tracking stack changes, the execution traces composed of a series of function addresses were acquired. Then these traces were modeled as execution sequences and then simplified so as to get simplified sequences (SFS), followed by the extraction of patterns through pattern extraction (PE) algorithm from SFS. After that, evaluating indicators inner-importance and inter-importance were designed to measure the noteworthiness of functions in DNFM algorithm. Finally, these functions were sorted by their noteworthiness. Comparison and contrast were conducted on the experiment results from two traditional complex network-based node mining methods, namely PageRank and DegreeRank. The results show that the DNFM method can mine noteworthy functions in software effectively and precisely.",
      "authors": [
        "Bing Zhang",
        "Guoyan Huang",
        "Yuqian Wang",
        "Haitao He",
        "Jiadong Ren"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "PubMed"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": "e0173244",
      "publication": {
        "category": "Journal",
        "cite_score": 6.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1932-6203",
        "publisher": "Public Library of Science",
        "sjr": 0.885,
        "snip": 1.253,
        "subject_areas": [
          "Multidisciplinary"
        ],
        "title": "PloS one"
      },
      "publication_date": "2017-03-09",
      "selected": null,
      "title": "Mining dynamic noteworthy functions in software execution sequences.",
      "urls": []
    },
    {
      "abstract": "As the quality of crucial entities can directly affect that of software, their identification and protection become an important premise for effective software development, management, maintenance and testing, which thus contribute to improving the software quality and its attack-defending ability. Most analysis and evaluation on important entities like codes-based static structure analysis are on the destruction of the actual software running. In this paper, from the perspective of software execution process, we proposed an approach to mine dynamic noteworthy functions (DNFM)in software execution sequences. First, according to software decompiling and tracking stack changes, the execution traces composed of a series of function addresses were acquired. Then these traces were modeled as execution sequences and then simplified so as to get simplified sequences (SFS), followed by the extraction of patterns through pattern extraction (PE) algorithm from SFS. After that, evaluating indicators inner-importance and inter-importance were designed to measure the noteworthiness of functions in DNFM algorithm. Finally, these functions were sorted by their noteworthiness. Comparison and contrast were conducted on the experiment results from two traditional complex network-based node mining methods, namely PageRank and DegreeRank. The results show that the DNFM method can mine noteworthy functions in software effectively and precisely.",
      "authors": [
        "Bing Zhang",
        "Guoyan Huang",
        "Yuqian Wang",
        "Haitao He",
        "Jiadong Ren"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1371/journal.pone.0173244",
      "keywords": [
        "Network reciprocity",
        "Open source software",
        "Computer software",
        "Centrality",
        "Algorithms",
        "Network analysis",
        "Vendors",
        "Software development"
      ],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 6.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1932-6203",
        "publisher": "Public Library of Science",
        "sjr": 0.885,
        "snip": 1.253,
        "subject_areas": [
          "Multidisciplinary"
        ],
        "title": "PLoS ONE"
      },
      "publication_date": "2017-03-01",
      "selected": null,
      "title": "Mining dynamic noteworthy functions in software execution sequences",
      "urls": [
        "https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0173244&type=printable",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85014922944&origin=inward"
      ]
    },
    {
      "abstract": "We study effects of compilation and decompilation to code clone detection in Java. Compilation/decompilation canonicalise syntactic changes made to source code and can be used as source code normalisation. We used NiCad to detect clones before and after decompilation in three open source software systems, JUnit, JFreeChart, and Tomcat. We filtered and compared the clones in the original and decompiled clone set and found that 1,201 clone pairs (78.7%) are common between the two sets while 326 pairs (21.3%) are only in one of the sets. A manual investigation identified 325 out of the 326 pairs as true clones. The 252 original-only clone pairs contain a single false positive while the 74 decompiled-only clone pairs are all true positives. Many clones in the original source code that are detected only after decompilation are type-3 clones that are dicult to detect due to added or deleted statements, keywords, package names; flipped if-else statements; or changed loops. We suggest to use decompilation as normalisation to compliment clone detection. By combining clones found before and after decompilation, one can achieve higher recall without losing precision.",
      "authors": [
        "Chaiyong Ragkhitwetsagul",
        "Jens Krinke"
      ],
      "categories": null,
      "citations": 28,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IWSC.2017.7880502",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "8-14",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-6596-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IWSC 2017 - 11th IEEE International Workshop on Software Clones, co-located with SANER 2017"
      },
      "publication_date": "2017-02-21",
      "selected": null,
      "title": "Using compilation/decompilation to enhance clone detection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85017256746&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7880502"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Maheshwari Y."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3021460.3021472",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "112-116",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450348560",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ACM International Conference Proceeding Series"
      },
      "publication_date": "2017-02-05",
      "selected": null,
      "title": "A study on migrating flash files to HTML5/JavaScript",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85045731289&origin=inward"
      ]
    },
    {
      "abstract": "In order to reuse a software component or verify it, the information about compiler, that is used for compilation of the component, is very significant. Due to unknown build flags and compiler information, third party components usually cannot be reused. When it comes to the matter of software components developed in C language, the only place to look for this information is in compiled binary file. Since there are no standards for C language that bind compiler to leave any information about itself in binary file, the information is not expected to be found. However, the information can be found in most of the binary files. This paper investigates what is the possibility of retrieving the information about compiler name and version based on the content of the binary code, without decompiling the binary code. The information retrieving opens up new possibilities for reusing the components and verifying the software requirements as well.",
      "authors": [
        "Sr\u0111an Popi\u0107",
        "Ivan Veliki\u0107",
        "Nikola Tesli\u0107"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICCE.2017.7889345",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "338-339",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-5545-6",
        "issn": "2158-4001",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2017 IEEE International Conference on Consumer Electronics, ICCE 2017"
      },
      "publication_date": "2017-01-08",
      "selected": null,
      "title": "Retrieving the useful information from the binary files compiled by C compiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85018309153&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7889345"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Weston S."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1080/17579961.2017.1302695",
      "keywords": [],
      "number_of_pages": 39,
      "pages": "78-116",
      "publication": {
        "category": "Journal",
        "cite_score": 2.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17579961",
        "publisher": "Taylor and Francis Ltd.",
        "sjr": 0.306,
        "snip": 4.593,
        "subject_areas": [
          "Artificial Intelligence",
          "Computer Science (miscellaneous)",
          "Law",
          "Computer Science Applications",
          "Biotechnology"
        ],
        "title": "Law, Innovation and Technology"
      },
      "publication_date": "2017-01-01",
      "selected": null,
      "title": "Improving interoperability by encouraging the sharing of interface specifications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85026204727&origin=inward"
      ]
    },
    {
      "abstract": "Unauthorized code modification through reverse engineering is a major concern for Android application developers. Code reverse engineering is often used by adversaries to remove the copyright protection or advertisements from the app, or to inject malicious code into...",
      "authors": [
        "Zhao, Beibei",
        "Tang, Zhanyong",
        "Li, Zhen",
        "Song, Lina",
        "Gong, Xiaoqing",
        "Fang, Dingyi",
        "Liu, Fangyuan",
        "Wang, Zheng"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-69471-9_27",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "367-382",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2017-01-01",
      "selected": null,
      "title": "DexPro: A Bytecode Level Code Protection System for Android Applications",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-319-69471-9_27.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85034250400&origin=inward"
      ]
    },
    {
      "abstract": "The diversity of Linux versions brings challenges to Linux memory analysis, which is an established technique in security and forensic investigations. During memory forensics, kernel data structures are essential information. Existing solutions obtain this...",
      "authors": [
        "Zhang, Shuhui",
        "Meng, Xiangxu",
        "Wang, Lianhai",
        "Liu, Guangqi"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-10-6385-5_32",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "373-385",
      "publication": {
        "category": "Book",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": "9789811399411",
        "issn": "18650929",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.194,
        "snip": 0.241,
        "subject_areas": [
          "Computer Science (all)",
          "Mathematics (all)"
        ],
        "title": "International Conference of Pioneering Computer Scientists, Engineers and Educators"
      },
      "publication_date": "2017-01-01",
      "selected": null,
      "title": "Research on Linux Kernel Version Diversity for\u00a0Precise Memory Analysis",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-981-10-6385-5_32.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85030031091&origin=inward"
      ]
    },
    {
      "abstract": "Structured programs are believed to be easier to understand, and compiler friendly\u00a0[5, 10, 45]. However, compilers do not process the source programs directly; they instead work on control flow graphs (CFGs) of the programs. Unfortunately, there is little...",
      "authors": [
        "Sabne, Amit",
        "Sakdhnagool, Putt",
        "Eigenmann, Rudolf"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-52709-3_13",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "153-168",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2017-01-01",
      "selected": null,
      "title": "Formalizing Structured Control Flow Graphs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85011332595&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-319-52709-3_13.pdf"
      ]
    },
    {
      "abstract": "Nowadays, analysis methods based on big data have been widely used in malicious software detection. Since Android has become the dominator of smartphone operating system market, the number of Android malicious applications are increasing rapidly as well, which...",
      "authors": [
        "Wu, Qixin",
        "Qin, Zheng",
        "Zhang, Jinxin",
        "Yin, Hui",
        "Yang, Guangyi",
        "Hu, Kuangsheng"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-981-10-6385-5_23",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "262-275",
      "publication": {
        "category": "Book",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": "9789811399411",
        "issn": "18650929",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.194,
        "snip": 0.241,
        "subject_areas": [
          "Computer Science (all)",
          "Mathematics (all)"
        ],
        "title": "International Conference of Pioneering Computer Scientists, Engineers and Educators"
      },
      "publication_date": "2017-01-01",
      "selected": null,
      "title": "Android Malware Detection Using Local Binary Pattern and Principal Component Analysis",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-981-10-6385-5_23.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85030031159&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Jaffe A."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/3106237.3121274",
      "keywords": [],
      "number_of_pages": 3,
      "pages": "1050-1052",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering"
      },
      "publication_date": "2017-01-01",
      "selected": null,
      "title": "Suggesting meaningful variable names for decompiled code: a machine translation approach",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85056811143&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Tang J."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.13245/j.hust.16S105",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "20-24",
      "publication": {
        "category": "Journal",
        "cite_score": 0.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16714512",
        "publisher": "Huazhong University of Science and Technology",
        "sjr": 0.171,
        "snip": 0.393,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Huazhong Keji Daxue Xuebao (Ziran Kexue Ban)/Journal of Huazhong University of Science and Technology (Natural Science Edition)"
      },
      "publication_date": "2016-11-23",
      "selected": null,
      "title": "Android application vulnerabilities static mining technology",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84994403164&origin=inward"
      ]
    },
    {
      "abstract": " Software engineering researchers and practitioners working on the Android ecosystem frequently have to do the same tasks over and over: retrieve data from the Google Play store to analyze it, decompile the Dalvik bytecode to understand the behavior of the app, and analyze applications metadata and user reviews. In this paper we present CALAPPA, a highly reusable and customizable toolchain that allows researchers to easily run common analysis tasks on large Android application datasets. CALAPPA includes components to retrieve the data from different Android stores, and comes with a predefined, but extensible, set of modules that can analyze apps metadata and code. ",
      "authors": [
        "Vitalii Avdiienko",
        "Konstantin Kuznetsov",
        "Paolo Calciati",
        "Juan Carlos Caiza Rom\u00e1n",
        "Alessandra Gorla",
        "Andreas Zeller"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/2993259.2993262",
      "keywords": [
        "Android Analysis",
        "Android app mining",
        "App market analysis"
      ],
      "number_of_pages": 4,
      "pages": "22-25",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450343985",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "WAMA 2016 - Proceedings of the International Workshop on App Market Analytics, co-located with FSE 2016"
      },
      "publication_date": "2016-11-14",
      "selected": null,
      "title": "CALAPPA: a toolchain for mining Android applications",
      "urls": [
        "https://dl.acm.org/doi/10.1145/2993259.2993262",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85007412058&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Deshotels L."
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2976749.2978336",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "704-716",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450370899",
        "issn": "15437221",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM Conference on Computer and Communications Security"
      },
      "publication_date": "2016-10-24",
      "selected": null,
      "title": "SandScout: Automatic detection of flaws in iOS sandbox profiles",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84995477457&origin=inward"
      ]
    },
    {
      "abstract": "Source code analysis to detect code cloning, code plagiarism, and code reuse suffers from the problem of pervasive code modifications, i.e. transformations that may have a global effect. We compare 30 similarity detection techniques and tools against pervasive code modifications. We evaluate the tools using two experimental scenarios for Java source code. These are (1) pervasive modifications created with tools for source code and bytecode obfuscation and (2) source code normalisation through compilation and decompilation using different decompilers. Our experimental results show that highly specialised source code similarity detection techniques and tools can perform better than more general, textual similarity measures. Our study strongly validates the use of compilation/decompilation as a normalisation technique. Its use reduced false classifications to zero for six of the tools. This broad, thorough study is the largest in existence and potentially an invaluable guide for future users of similarity detection in source code.",
      "authors": [
        "Chaiyong Ragkhitwetsagul",
        "Jens Krinke",
        "David Clark"
      ],
      "categories": null,
      "citations": 27,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2016.13",
      "keywords": [
        "code plagiarism",
        "code normalisation",
        "code reuse",
        "code cloning",
        "decompilation",
        "source code similarity"
      ],
      "number_of_pages": 10,
      "pages": "117-126",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-3849-7",
        "issn": "2470-6892",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2016 IEEE 16th International Working Conference on Source Code Analysis and Manipulation, SCAM 2016"
      },
      "publication_date": "2016-10-02",
      "selected": null,
      "title": "Similarity of Source Code in the Presence of Pervasive Modifications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85010739004&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7781805"
      ]
    },
    {
      "abstract": "We describe a graph visualization tool for visualizing Java bytecode. Our tool, which we call J-Viz, visualizes connected directed graphs according to a canonical node ordering, which we call the sibling-first recursive (SFR) numbering. The particular graphs we consider are derived from applying Shiver's k-CFA framework to Java bytecode, and our visualizer includes helpful links between the nodes of an input graph and the Java bytecode that produced it, as well as a decompiled version of that Java bytecode. We show through several case studies that the canonical drawing paradigm used in J-Viz is effective for identifying potential security vulnerabilities and repeated use of the same code in Java applications.",
      "authors": [
        "Alam, Md. Jawaherul",
        "Goodrich, Michael T.",
        "Johnson, Timothy"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2016-08-31",
      "selected": null,
      "title": "J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java Bytecode",
      "urls": [
        "http://arxiv.org/pdf/1608.08970.pdf",
        "http://arxiv.org/pdf/1608.08970v1",
        "http://arxiv.org/abs/1608.08970v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sateanpattanakul S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ICIS.2016.7550827",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781509008063",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2016 IEEE/ACIS 15th International Conference on Computer and Information Science, ICIS 2016 - Proceedings"
      },
      "publication_date": "2016-08-23",
      "selected": null,
      "title": "Comments recovery approach for Java decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84987984785&origin=inward"
      ]
    },
    {
      "abstract": "As the Android mobile terminals have become prevalent, an increasing number of developers build Android applications and get benefits from bonus of advertising sharing. However, some mobile advertisements have serious security problems, such as traffic consumption, malicious deduction and privacy leak. White list and semantic analysis are proposed to defect the problem recently. In this paper, we put forward the work further by analyzing the decompiled digital sequence of ad plugins. We select appropriate decompiling tools to decompile the ad plugins to get the Java files that we need. And then we traverse the Java files to count the unique word of each file. The number of the unique word is the digital sequence of the file which could be applied as the feature of machine learning classifier to detect ad plugins. The experimental results show that the decompiled digital sequence has very good performance in terms of detect ad plugins, which cannot only avoid the situation of getting less semantic features, but also solve white list method inadequate.",
      "authors": [
        "Yanhui Guo",
        "Jianpeng Hou",
        "Weiping Chen",
        "Qi Li"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CCIS.2016.7790233",
      "keywords": [
        "Ad Plugins",
        "Classifier",
        "Decompiled Digital Sequence"
      ],
      "number_of_pages": 5,
      "pages": "104-108",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-1257-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of 2016 4th IEEE International Conference on Cloud Computing and Intelligence Systems, CCIS 2016"
      },
      "publication_date": "2016-08-17",
      "selected": null,
      "title": "A method to detect Android ad plugins based on decompiled digital sequence",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7790233",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85011026089&origin=inward"
      ]
    },
    {
      "abstract": "In order to limit the damage of malware on Mac OS X and iOS, Apple uses sandboxing, a kernel-level security layer that provides tight constraints for system calls. Particularly used for Apple iOS, sandboxing prevents apps from executing potentially dangerous actions, by defining rules in a sandbox profile. Investigating Apple's built-in sandbox profiles is difficult as they are compiled and stored in binary format. We present SandBlaster, a software bundle that is able to reverse/decompile Apple binary sandbox profiles to their original human readable SBPL (SandBox Profile Language) format. We use SandBlaster to reverse all built-in Apple iOS binary sandbox profiles for iOS 7, 8 and 9. Our tool is, to the best of our knowledge, the first to provide a full reversing of the Apple sandbox, shedding light into the inner workings of Apple sandbox profiles and providing essential support for security researchers and professionals interested in Apple security mechanisms.",
      "authors": [
        "Deaconescu, R\u0103zvan",
        "Deshotels, Luke",
        "Bucicoiu, Mihai",
        "Enck, William",
        "Davi, Lucas",
        "Sadeghi, Ahmad-Reza"
      ],
      "categories": null,
      "citations": null,
      "comments": "25 pages, 9 figures, 14 listings This report is an auxiliary document\n  to the paper \"SandScout: Automatic Detection of Flaws in iOS Sandbox\n  Profiles\", to be presented at the ACM Conference on Computer and\n  Communications Security (CCS) 2016",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2016-08-15",
      "selected": null,
      "title": "SandBlaster: Reversing the Apple Sandbox",
      "urls": [
        "http://arxiv.org/pdf/1608.04303v1",
        "http://arxiv.org/pdf/1608.04303.pdf",
        "http://arxiv.org/abs/1608.04303v1"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781509029570",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2016 Zooming Innovation in Consumer Electronics International Conference, ZINC 2016"
      },
      "publication_date": "2016-07-14",
      "selected": null,
      "title": "2016 Zooming Innovation in Consumer Electronics International Conference, ZINC 2016",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84980517788&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Noonan M."
      ],
      "categories": null,
      "citations": 19,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2908080.2908119",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "27-41",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 4.9,
        "is_potentially_predatory": false,
        "isbn": "9781450342612",
        "issn": "15232867",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.962,
        "snip": 1.749,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)"
      },
      "publication_date": "2016-06-02",
      "selected": null,
      "title": "Polymorphic type inference for machine code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85119293789&origin=inward",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84975804490&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhang X."
      ],
      "categories": null,
      "citations": 15,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.diin.2016.03.002",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "28-39",
      "publication": {
        "category": "Journal",
        "cite_score": 5.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17422876",
        "publisher": "Elsevier Ltd.",
        "sjr": 0.348,
        "snip": 1.749,
        "subject_areas": [
          "Pathology and Forensic Medicine",
          "Information Systems",
          "Computer Science Applications",
          "Law",
          "Medical Laboratory Technology"
        ],
        "title": "Digital Investigation"
      },
      "publication_date": "2016-06-01",
      "selected": null,
      "title": "Rapid Android Parser for Investigating DEX files (RAPID)",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84961620852&origin=inward"
      ]
    },
    {
      "abstract": "In this paper we analyzed how different methods of protection, namely class encryption and usage of native code, affect decompilation of Android applications. This is important in consumer electronics as it can be used to stop repackaging and spreading of maliciously modified applications. We analyzed two different methods of protection, their benefits and flaws.",
      "authors": [
        "Stefan Ili\u0107",
        "Slavica \u0110uki\u0107"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ZINC.2016.7513642",
      "keywords": [
        "decompilation",
        "class encryption",
        "native code",
        "Android"
      ],
      "number_of_pages": 2,
      "pages": "10-11",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-2958-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2016 Zooming Innovation in Consumer Electronics International Conference, ZINC 2016"
      },
      "publication_date": "2016-06-01",
      "selected": null,
      "title": "Protection of Android applications from decompilation using class encryption and native code",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7513642",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84982976140&origin=inward"
      ]
    },
    {
      "abstract": "Analysis of malicious software is an essential task in computer security, it provides the necessary understanding to devise effective countermeasures and mitigation strategies. The level of sophistication and complexity of current malware continues to evolve significantly, as the recently discovered \"Regin\" malware family strikingly illustrates. This complexity makes the already tedious and time-consuming task of manual malware reverse engineering even more difficult and challenging. Decompilation can accelerate this process by enabling analysts to reason about a high-level, more abstract from of binary code. While significant advances have been made, state-of-the-art decompilers still produce very complex and unreadable code and malware analysts still frequently go back to analyzing the assembly code. In this paper, we present several semantics-preserving code transformations to make the decompiled code more readable, thus helping malware analysts understand and combat malware. We have implemented our optimizations as extensions to the academic decompiler DREAM. To evaluate our approach, we conducted the first user study to measure the quality of decompilers for malware analysis. Our study includes 6 analysis tasks based on real malware samples we obtained from independent malware experts. We evaluate three decompilers: the leading industry decompiler Hex-Rays, the state-of-the-art academic decompiler DREAM, and our usability-optimized decompiler DREAM++. The results show that our readability improvements had a significant effect on how well our participants could analyze the malware samples. DREAM++ outperforms both Hex-Rays and DREAM significantly. Using DREAM++ participants solved 3x more tasks than when using Hex-Rays and 2x more tasks than when using DREAM.",
      "authors": [
        "Khaled Yakdan",
        "Sergej Dechand",
        "Elmar Gerhards-Padilla",
        "Matthew Smith"
      ],
      "categories": null,
      "citations": 60,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SP.2016.18",
      "keywords": [],
      "number_of_pages": 20,
      "pages": "158-177",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-0825-4",
        "issn": "2375-1207",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2016 IEEE Symposium on Security and Privacy, SP 2016"
      },
      "publication_date": "2016-05-22",
      "selected": null,
      "title": "Helping Johnny to Analyze Malware: A Usability-Optimized Decompiler and Malware Analysis User Study",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84987680555&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7546501"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Aycock J."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2910925.2910929",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450343558",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the WCCCE 2016 - The 21st Western Canadian Conference on Computing Education"
      },
      "publication_date": "2016-05-06",
      "selected": null,
      "title": "Code protection: When abstinence is not an option",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84974578247&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Robbins E."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2837614.2837633",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "191-203",
      "publication": {
        "category": "Journal",
        "cite_score": 4.9,
        "is_potentially_predatory": false,
        "isbn": "9781450335492",
        "issn": "15232867",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.962,
        "snip": 1.749,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Conference Record of the Annual ACM Symposium on Principles of Programming Languages"
      },
      "publication_date": "2016-04-08",
      "selected": null,
      "title": "From MINX to MINC: Semantics-driven decompilation of recursive datatypes",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84962492583&origin=inward",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84965043961&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Piao Y."
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/sec.936",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "457-467",
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19390114",
        "publisher": "Hindawi Limited",
        "sjr": 0.494,
        "snip": 0.785,
        "subject_areas": [
          "Computer Networks and Communications",
          "Information Systems"
        ],
        "title": "Security and Communication Networks"
      },
      "publication_date": "2016-04-01",
      "selected": null,
      "title": "Server-based code obfuscation scheme for APK tamper detection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84959272528&origin=inward"
      ]
    },
    {
      "abstract": "For many compiled languages, source-level types are erased very early in the compilation process. As a result, further compiler passes may convert type-safe source into type-unsafe machine code. Type-unsafe idioms in the original source and type-unsafe optimizations mean that type information in a stripped binary is essentially nonexistent. The problem of recovering high-level types by performing type inference over stripped machine code is called type reconstruction, and offers a useful capability in support of reverse engineering and decompilation. In this paper, we motivate and develop a novel type system and algorithm for machine-code type inference. The features of this type system were developed by surveying a wide collection of common source- and machine-code idioms, building a catalog of challenging cases for type reconstruction. We found that these idioms place a sophisticated set of requirements on the type system, inducing features such as recursively-constrained polymorphic types. Many of the features we identify are often seen only in expressive and powerful type systems used by high-level functional languages. Using these type-system features as a guideline, we have developed Retypd: a novel static type-inference algorithm for machine code that supports recursive types, polymorphism, and subtyping. Retypd yields more accurate inferred types than existing algorithms, while also enabling new capabilities such as reconstruction of pointer const annotations with 98% recall. Retypd can operate on weaker program representations than the current state of the art, removing the need for high-quality points-to information that may be impractical to compute.",
      "authors": [
        "Noonan, Matthew",
        "Loginov, Alexey",
        "Cok, David"
      ],
      "categories": null,
      "citations": null,
      "comments": "Full version with appendices, for PLDI 2016",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2016-03-17",
      "selected": null,
      "title": "Polymorphic Type Inference for Machine Code",
      "urls": [
        "http://arxiv.org/abs/1603.05495v2",
        "http://arxiv.org/pdf/1603.05495v2",
        "http://arxiv.org/pdf/1603.05495.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Nanda M.G."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2856636.2856651",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "59-69",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450340182",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ACM International Conference Proceeding Series"
      },
      "publication_date": "2016-02-18",
      "selected": null,
      "title": "Decompiling boolean expressions from Java<sup>\u2122</sup> bytecode",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84976613492&origin=inward"
      ]
    },
    {
      "abstract": "Instruction levelHu, Erh-Wen\n\t\t\t\t loop optimizationSu, Bogong\n\t\t\t\t has beenWang, Jian\n\t\t\t\t widely used in modern compilers. Decompilation\u2014the reverse of compilation\u2014has also generated much interest for its applications in porting legacy software written...",
      "authors": [
        "Hu, Erh-Wen",
        "Su, Bogong",
        "Wang, Jian"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-23467-0_15",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "221-234",
      "publication": {
        "category": "Book",
        "cite_score": 2.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1860949X",
        "publisher": "Springer Verlag",
        "sjr": 0.209,
        "snip": 0.296,
        "subject_areas": [
          "Artificial Intelligence"
        ],
        "title": "Studies in Computational Intelligence"
      },
      "publication_date": "2016-01-01",
      "selected": null,
      "title": "Instruction Level Loop De-optimization",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84944474813&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-319-23467-0_15.pdf"
      ]
    },
    {
      "abstract": "Android plays a paramount role in mobile internet era and it is an extremely comfortable operating system to deploy in mobile devices. More and more security problems have been taken place on Android devices, and lead to leak users\u2019 privilege information. In...",
      "authors": [
        "Fu, Chengzhou",
        "Huang, Chang",
        "Tang, Yong",
        "Zeng, Weiquan",
        "Wang, Dahao",
        "Yuan, Chengzhe"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-31854-7_9",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "92-103",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2016-01-01",
      "selected": null,
      "title": "Survey on Android Applications Security",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-319-31854-7_9.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84966661157&origin=inward"
      ]
    },
    {
      "abstract": "The ability to identify authors of computer programs based on their coding\nstyle is a direct threat to the privacy and anonymity of programmers. While\nrecent work found that source code can be attributed to authors with high\naccuracy, attribution of executable binaries appears to be much more difficult.\nMany distinguishing features present in source code, e.g. variable names, are\nremoved in the compilation process, and compiler optimization may alter the\nstructure of a program, further obscuring features that are known to be useful\nin determining authorship. We examine programmer de-anonymization from the\nstandpoint of machine learning, using a novel set of features that include ones\nobtained by decompiling the executable binary to source code. We adapt a\npowerful set of techniques from the domain of source code authorship\nattribution along with stylistic representations embedded in assembly,\nresulting in successful de-anonymization of a large set of programmers.\n  We evaluate our approach on data from the Google Code Jam, obtaining\nattribution accuracy of up to 96% with 100 and 83% with 600 candidate\nprogrammers. We present an executable binary authorship attribution approach,\nfor the first time, that is robust to basic obfuscations, a range of compiler\noptimization settings, and binaries that have been stripped of their symbol\ntables. We perform programmer de-anonymization using both obfuscated binaries,\nand real-world code found \"in the wild\" in single-author GitHub repositories\nand the recently leaked Nulled.IO hacker forum. We show that programmers who\nwould like to remain anonymous need to take extreme countermeasures to protect\ntheir privacy.",
      "authors": [
        "Aylin Caliskan",
        "Fabian Yamaguchi",
        "Edwin Dauber",
        "Richard Harang",
        "Konrad Rieck",
        "Rachel Greenstadt",
        "Arvind Narayanan"
      ],
      "categories": null,
      "citations": 37,
      "comments": "15 pages",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": "10.14722/ndss.2018.23304",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "1891562495",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "25th Annual Network and Distributed System Security Symposium, NDSS 2018"
      },
      "publication_date": "2015-12-28",
      "selected": null,
      "title": "When Coding Style Survives Compilation: De-anonymizing Programmers from Executable Binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85145616074&origin=inward",
        "http://arxiv.org/pdf/1512.08546v3",
        "http://arxiv.org/abs/1512.08546v3",
        "http://dx.doi.org/10.14722/ndss.2018.23304"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Xu J."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/FCST.2015.76",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "184-190",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781467392952",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2015 9th International Conference on Frontier of Computer Science and Technology, FCST 2015"
      },
      "publication_date": "2015-10-30",
      "selected": null,
      "title": "Recommendable Schemes of Anti-decompilation for Android Applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84961755602&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Dewey D."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ARES.2015.61",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "90-99",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781467365901",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 10th International Conference on Availability, Reliability and Security, ARES 2015"
      },
      "publication_date": "2015-10-16",
      "selected": null,
      "title": "Uncovering use-after-free conditions in compiled code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84961657962&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Maheshwari Y."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2811681.2811686",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "23-27",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450337960",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ACM International Conference Proceeding Series"
      },
      "publication_date": "2015-09-28",
      "selected": null,
      "title": "Transformation of flash files to HTML5 and javascript",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84958770337&origin=inward"
      ]
    },
    {
      "abstract": "Android is currently one of the most popular smartphone operating systems. However, Android has the largest share of global mobile malware and significant public attention has been brought to the security issues of Android. In this paper, we investigate the use of a clone detector to identify known Android malware. We collect a set of Android applications known to contain malware and a set of benign applications. We extract the Java source code from the binary code of the applications and use NiCad, a near-miss clone detector, to find the classes of clones in a small subset of the malicious applications. We then use these clone classes as a signature to find similar source files in the rest of the malicious applications. The benign collection is used as a control group. In our evaluation, we successfully decompile more than 1 000 malicious apps in 19 malware families. Our results show that using a small portion of malicious applications as a training set can detect 95% of previously known malware with very low false positives and high accuracy at 96.88%. Our method can effectively and reliably pinpoint malicious applications that belong to certain malware families.",
      "authors": [
        "Chen, Jian",
        "Alalfi, Manar H.",
        "Dean, Thomas R.",
        "Zou, Ying"
      ],
      "categories": null,
      "citations": 52,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s11390-015-1573-7",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "942-956",
      "publication": {
        "category": "Journal",
        "cite_score": 3.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10009000",
        "publisher": "Springer New York",
        "sjr": 0.566,
        "snip": 0.936,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Theoretical Computer Science",
          "Hardware and Architecture",
          "Computer Science Applications",
          "Software"
        ],
        "title": "Journal of Computer Science and Technology"
      },
      "publication_date": "2015-09-22",
      "selected": null,
      "title": "Detecting Android Malware Using Clone Detection",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/s11390-015-1573-7.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84941947399&origin=inward"
      ]
    },
    {
      "abstract": "This paper reports on initial experiments using J Moore's Codewalker to reason about programs compiled to the Low-Level Virtual Machine (LLVM) intermediate form. Previously, we reported on a translator from LLVM to the applicative subset of Common Lisp accepted by the ACL2 theorem prover, producing executable ACL2 formal models, and allowing us to both prove theorems about the translated models as well as validate those models by testing. That translator provided many of the benefits of a pure decompilation into logic approach, but had the disadvantage of not being verified. The availability of Codewalker as of ACL2 7.0 has provided an opportunity to revisit this idea, and employ a more trustworthy decompilation into logic tool. Thus, we have employed the Codewalker method to create an interpreter for a subset of the LLVM instruction set, and have used Codewalker to analyze some simple array-based C programs compiled to LLVM form. We discuss advantages and limitations of the Codewalker-based method compared to the previous method, and provide some challenge problems for future Codewalker development.",
      "authors": [
        "Hardin, David S."
      ],
      "categories": null,
      "citations": 1,
      "comments": "In Proceedings ACL2 2015, arXiv:1509.05526",
      "databases": [
        "arXiv",
        "Scopus"
      ],
      "doi": "10.4204/EPTCS.192.7",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "79-92",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "20752180",
        "publisher": "Open Publishing Association",
        "sjr": 0.349,
        "snip": 0.556,
        "subject_areas": [
          "Programming Languages",
          "Logic in Computer Science",
          "Software"
        ],
        "title": "Electronic Proceedings in Theoretical Computer Science, EPTCS"
      },
      "publication_date": "2015-09-21",
      "selected": null,
      "title": "Reasoning About LLVM Code Using Codewalker",
      "urls": [
        "http://arxiv.org/abs/1509.06083v1",
        "http://arxiv.org/pdf/1509.06083v1",
        "http://arxiv.org/pdf/1509.06083.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84957943805&origin=inward",
        "http://dx.doi.org/10.4204/EPTCS.192.7"
      ]
    },
    {
      "abstract": "Background Initial treatment for early breast cancer is usually either breast-conserving surgery (BCS) or mastectomy. After BCS, whole-breast external beam radiotherapy (WB-EBRT) is the standard of care. A potential alternative to post-operative WB-EBRT is intraoperative radiation therapy delivered by the INTRABEAM\u00ae Photon Radiotherapy System (Carl Zeiss, Oberkochen, Germany) to the tissue adjacent to the resection cavity at the time of surgery. Objective To assess the clinical effectiveness and cost-effectiveness of INTRABEAM for the adjuvant treatment of early breast cancer during surgical removal of the tumour. Data sources Electronic bibliographic databases, including MEDLINE, EMBASE and The Cochrane Library, were searched from inception to March 2014 for English-language articles. Bibliographies of articles, systematic reviews, clinical guidelines and the manufacturer\u2019s submission were also searched. The advisory group was contacted to identify additional evidence. Methods Systematic reviews of clinical effectiveness, health-related quality of life and cost-effectiveness were conducted. Two reviewers independently screened titles and abstracts for eligibility. Inclusion criteria were applied to full texts of retrieved papers by one reviewer and checked by a second reviewer. Data extraction and quality assessment were undertaken by one reviewer and checked by a second reviewer, and differences in opinion were resolved through discussion at each stage. Clinical effectiveness studies were included if they were carried out in patients with early operable breast cancer. The intervention was the INTRABEAM system, which was compared with WB-EBRT, and study designs were randomised controlled trials (RCTs). Controlled clinical trials could be considered if data from available RCTs were incomplete (e.g. absence of data on outcomes of interest). A cost\u2013utility decision-analytic model was developed to estimate the costs, benefits and cost-effectiveness of INTRABEAM compared with WB-EBRT for early operable breast cancer. Results One non-inferiority RCT, TARGeted Intraoperative radioTherapy Alone (TARGIT-A), met the inclusion criteria for the review. The review found that local recurrence was slightly higher following INTRABEAM than WB-EBRT, but the difference did not exceed the 2.5% non-inferiority margin providing INTRABEAM was given at the same time as BCS. Overall survival was similar with both treatments. Statistically significant differences in complications were found for the occurrence of wound seroma requiring more than three aspirations (more frequent in the INTRABEAM group) and for a Radiation Therapy Oncology Group toxicity score of grade 3 or 4 (less frequent in the INTRABEAM group). Cost-effectiveness base-case analysis indicates that INTRABEAM is less expensive but also less effective than WB-EBRT because it is associated with lower total costs but fewer total quality-adjusted life-years gained. However, sensitivity analyses identified four model parameters that can cause a switch in the treatment option that is considered cost-effective. Limitations The base-case result from the model is subject to uncertainty because the disease progression parameters are largely drawn from the single available RCT. The RCT median follow-up of 2 years 5 months may be inadequate, particularly as the number of participants with local recurrence is low. The model is particularly sensitive to this parameter. Conclusions and implications A significant investment in INTRABEAM equipment and staff training (clinical and non-clinical) would be required to make this technology available across the NHS. Longer-term follow-up data from the TARGIT-A trial and analysis of registry data are required as results are currently based on a small number of events and economic modelling results are uncertain. Study registration This study is registered as PROSPERO CRD42013006720. Funding The National Institute for Health Research Health Technology Assessment programme. Note that the economic model associated with this document is protected by intellectual property rights, which are owned by the University of Southampton. Anyone wishing to modify, adapt, translate, reverse engineer, decompile, dismantle or create derivative work based on the economic model must first seek the agreement of the property owners. ",
      "authors": [
        "Picot, Jo",
        "Copley, Vicky",
        "Colquitt, Jill L",
        "Kalita, Neelam",
        "Hartwell, Debbie",
        "Bryant, Jackie"
      ],
      "categories": null,
      "citations": 16,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3310/hta19690",
      "keywords": [],
      "number_of_pages": 190,
      "pages": "1-190",
      "publication": {
        "category": "Journal",
        "cite_score": 6.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "13665278",
        "publisher": "National Co-ordinating Centre for HTA",
        "sjr": 1.207,
        "snip": 1.381,
        "subject_areas": [
          "Health Policy"
        ],
        "title": "Health Technology Assessment"
      },
      "publication_date": "2015-09-01",
      "selected": null,
      "title": "The INTRABEAM\u00ae Photon Radiotherapy System for the adjuvant treatment of early breast cancer: a systematic review and economic evaluation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84940992183&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Alharbi K."
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2785830.2785892",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "515-524",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450336529",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "MobileHCI 2015 - Proceedings of the 17th International Conference on Human-Computer Interaction with Mobile Devices and Services"
      },
      "publication_date": "2015-08-24",
      "selected": null,
      "title": "Collect, decompile, extract, stats, and diff: Mining design pattern changes in android apps",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84959419451&origin=inward"
      ]
    },
    {
      "abstract": "BACKGROUND BACKGROUND Initial treatment for early breast cancer is usually either breast-conserving surgery (BCS) or mastectomy. After BCS, whole-breast external beam radiotherapy (WB-EBRT) is the standard of care. A potential alternative to post-operative WB-EBRT is intraoperative radiation therapy delivered by the INTRABEAM(\u00ae) Photon Radiotherapy System (Carl Zeiss, Oberkochen, Germany) to the tissue adjacent to the resection cavity at the time of surgery.\nOBJECTIVE OBJECTIVE To assess the clinical effectiveness and cost-effectiveness of INTRABEAM for the adjuvant treatment of early breast cancer during surgical removal of the tumour.\nDATA SOURCES METHODS Electronic bibliographic databases, including MEDLINE, EMBASE and The Cochrane Library, were searched from inception to March 2014 for English-language articles. Bibliographies of articles, systematic reviews, clinical guidelines and the manufacturer's submission were also searched. The advisory group was contacted to identify additional evidence.\nMETHODS METHODS Systematic reviews of clinical effectiveness, health-related quality of life and cost-effectiveness were conducted. Two reviewers independently screened titles and abstracts for eligibility. Inclusion criteria were applied to full texts of retrieved papers by one reviewer and checked by a second reviewer. Data extraction and quality assessment were undertaken by one reviewer and checked by a second reviewer, and differences in opinion were resolved through discussion at each stage. Clinical effectiveness studies were included if they were carried out in patients with early operable breast cancer. The intervention was the INTRABEAM system, which was compared with WB-EBRT, and study designs were randomised controlled trials (RCTs). Controlled clinical trials could be considered if data from available RCTs were incomplete (e.g. absence of data on outcomes of interest). A cost-utility decision-analytic model was developed to estimate the costs, benefits and cost-effectiveness of INTRABEAM compared with WB-EBRT for early operable breast cancer.\nRESULTS RESULTS One non-inferiority RCT, TARGeted Intraoperative radioTherapy Alone (TARGIT-A), met the inclusion criteria for the review. The review found that local recurrence was slightly higher following INTRABEAM than WB-EBRT, but the difference did not exceed the 2.5% non-inferiority margin providing INTRABEAM was given at the same time as BCS. Overall survival was similar with both treatments. Statistically significant differences in complications were found for the occurrence of wound seroma requiring more than three aspirations (more frequent in the INTRABEAM group) and for a Radiation Therapy Oncology Group toxicity score of grade 3 or 4 (less frequent in the INTRABEAM group). Cost-effectiveness base-case analysis indicates that INTRABEAM is less expensive but also less effective than WB-EBRT because it is associated with lower total costs but fewer total quality-adjusted life-years gained. However, sensitivity analyses identified four model parameters that can cause a switch in the treatment option that is considered cost-effective.\nLIMITATIONS CONCLUSIONS The base-case result from the model is subject to uncertainty because the disease progression parameters are largely drawn from the single available RCT. The RCT median follow-up of 2 years 5 months may be inadequate, particularly as the number of participants with local recurrence is low. The model is particularly sensitive to this parameter.\nCONCLUSIONS AND IMPLICATIONS CONCLUSIONS A significant investment in INTRABEAM equipment and staff training (clinical and non-clinical) would be required to make this technology available across the NHS. Longer-term follow-up data from the TARGIT-A trial and analysis of registry data are required as results are currently based on a small number of events and economic modelling results are uncertain.\nSTUDY REGISTRATION BACKGROUND This study is registered as PROSPERO CRD42013006720.\nFUNDING BACKGROUND The National Institute for Health Research Health Technology Assessment programme. Note that the economic model associated with this document is protected by intellectual property rights, which are owned by the University of Southampton. Anyone wishing to modify, adapt, translate, reverse engineer, decompile, dismantle or create derivative work based on the economic model must first seek the agreement of the property owners.",
      "authors": [
        "Jo Picot",
        "Vicky Copley",
        "Jill L Colquitt",
        "Neelam Kalita",
        "Debbie Hartwell",
        "Jackie Bryant"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "PubMed"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 190,
      "pages": "1-190",
      "publication": {
        "category": "Journal",
        "cite_score": 6.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2046-4924",
        "publisher": "National Co-ordinating Centre for HTA",
        "sjr": 1.207,
        "snip": 1.381,
        "subject_areas": [
          "Health Policy"
        ],
        "title": "Health technology assessment (Winchester, England)"
      },
      "publication_date": "2015-08-01",
      "selected": null,
      "title": "The INTRABEAM\u00ae Photon Radiotherapy System for the adjuvant treatment of early breast cancer: a systematic review and economic evaluation.",
      "urls": []
    },
    {
      "abstract": "Mass vulnerabilities involved in the Android alternative applications could threaten the security of the launched device or users data. To analyze the alternative applications, generally, researchers would like to observe applications' runtime features first. Then they need to decompile the target application and read the complicated code to figure out what the application really does. Traditional dynamic analysis methodology, for instance, the TaintDroid, uses dynamic taint tracking technique to mark information at source APIs. However, TaintDroid is limited to constraint on requiring target application to run in custom sandbox that might be not compatible with all the Android versions. For solving this problem and helping analysts to have insight into the runtime behavior, this paper presents AppTrace, a novel dynamic analysis system that uses dynamic instrumentation technique to trace member methods of target application that could be deployed in any version above Android 4.0. The paper presents an evaluation of AppTrace with 8 apps from Google Play as well as 50 open source apps from F-Droid. The results show that AppTrace could trace methods of target applications successfully and notify users effectively when some sensitive APIs are invoked.",
      "authors": [
        "Lingzhi Qiu",
        "Zixiong Zhang",
        "Ziyi Shen",
        "Guozi Sun"
      ],
      "categories": null,
      "citations": 17,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICC.2015.7249466",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "7145-7150",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4673-6431-7",
        "issn": "1938-1883",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2015 IEEE International Conference on Communications (ICC)"
      },
      "publication_date": "2015-06-08",
      "selected": null,
      "title": "AppTrace: Dynamic trace on Android devices",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7249466",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84953774841&origin=inward"
      ]
    },
    {
      "abstract": "Access full-text academic articles: J-STAGE is an online platform for Japanese academic journals.",
      "authors": [
        "Nguyen Ngoc BINH",
        "Pham Van HUONG",
        "Bui Ngoc HAI"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1587/transinf.2014EDP7152",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "1166-1175",
      "publication": {
        "category": "Journal",
        "cite_score": 1.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09168532",
        "publisher": "Maruzen Co., Ltd/Maruzen Kabushikikaisha",
        "sjr": 0.281,
        "snip": 0.424,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Artificial Intelligence",
          "Hardware and Architecture",
          "Computer Vision and Pattern Recognition",
          "Software"
        ],
        "title": "IEICE Transactions on Information and Systems"
      },
      "publication_date": "2015-06-01",
      "selected": null,
      "title": "A New Approach to Embedded Software Optimization Based on Reverse Engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84930469933&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Katuli\u0107 T."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 26,
      "pages": "237-262",
      "publication": {
        "category": "Journal",
        "cite_score": 0.3,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "03502058",
        "publisher": "Faculty of Law, University of Zagreb",
        "sjr": 0.188,
        "snip": 0.631,
        "subject_areas": [
          "Law"
        ],
        "title": "Zbornik Pravnog Fakulteta u Zagrebu"
      },
      "publication_date": "2015-04-01",
      "selected": null,
      "title": "Protection of computer programs in European and Croatian law-current issues and development perspective",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84938931095&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Shaik Z."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 10,
      "pages": "295-304",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781910309964",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 10th International Conference on Cyber Warfare and Security, ICCWS 2015"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "Persistent technical difficulties preventing effective software assurance",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84969129966&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yakdan K."
      ],
      "categories": null,
      "citations": 47,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.14722/ndss.2015.23185",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "22nd Annual Network and Distributed System Security Symposium, NDSS 2015"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "No More Gotos: Decompilation Using Pattern-Independent Control-Flow Structuring and Semantics-Preserving Transformations",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85031022822&origin=inward"
      ]
    },
    {
      "abstract": "Having about 80\u00a0% of the market share, Android is currently the clearly dominating platform for mobile devices. Application theft and repackaging remains a major threat and a cause of significant losses, affecting as much as 97\u00a0% of popular paid apps. The...",
      "authors": [
        "Protsenko, Mykola",
        "M\u00fcller, Tilo"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-22906-5_8",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "99-110",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "Protecting Android Apps Against Reverse Engineering by the Use of the Native Code",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-319-22906-5_8.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84943623500&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yuhui F."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.14257/ijseia.2015.9.3.26",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "335-346",
      "publication": {
        "category": "Journal",
        "cite_score": 0.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17389976",
        "publisher": "Science and Engineering Research Support Society",
        "sjr": 0.146,
        "snip": 0.478,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "International Journal of Security and its Applications"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "The analysis of android malware behaviors",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84928378832&origin=inward"
      ]
    },
    {
      "abstract": "PHP is the most popular scripting language for web applications. Because no native solution to compile or protect PHP scripts exists, PHP applications are usually shipped as plain source code which is easily understood or copied by an adversary. In order to prevent...",
      "authors": [
        "Wei\u00dfer, Dario",
        "Dahse, Johannes",
        "Holz, Thorsten"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-26362-5_23",
      "keywords": [],
      "number_of_pages": 22,
      "pages": "493-514",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "Security Analysis of PHP Bytecode Protection Mechanisms",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-319-26362-5_23.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84950335506&origin=inward"
      ]
    },
    {
      "abstract": "The HOL4 interactive theorem prover provides a sound logical environment for reasoning about machine-code programs. The rigour of HOL\u2019s LCF-style kernel naturally guarantees very high levels of assurance, but it does present challenges when it comes...",
      "authors": [
        "Fox, Anthony"
      ],
      "categories": null,
      "citations": 17,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-22102-1_12",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "187-202",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "Improved Tool Support for Machine-Code Decompilation in HOL4",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84944687607&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-319-22102-1_12.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mikhaylov A."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2015 5th International Workshop on Computer Science and Engineering: Information Processing and Control Engineering, WCSE 2015-IPCE"
      },
      "publication_date": "2015-01-01",
      "selected": null,
      "title": "Delphi .NET object file decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84939498670&origin=inward"
      ]
    },
    {
      "abstract": "Although there has been much research on the leakage of sensitive data in Android applications, most of the existing research focus on how to detect the malware or ad ware that are intentionally collecting user privacy. There are not much research on analyzing the vulnerabilities of apps that may cause the leakage of privacy. In this paper, we present a vulnerability analyzing method which combines taint analysis and cryptography misuse detection. The four steps of this method are decompile, taint analysis, API call record, cryptography misuse analysis, all of which steps except taint analysis can be executed by the existing tools. We develop a prototype tool PW Exam to analysis how the passwords are handled and if the app is vulnerable to password leakage. Our experiment shows that a third of apps are vulnerable to leak the users' passwords.",
      "authors": [
        "Shao Shuai",
        "Dong Guowei",
        "Guo Tao",
        "Yang Tianchang",
        "Shi Chenjie"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/3PGCIC.2014.102",
      "keywords": [
        "Android apps",
        "leakage",
        "vulnerability",
        "password"
      ],
      "number_of_pages": 4,
      "pages": "504-507",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479941711",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2014 9th International Conference on P2P, Parallel, Grid, Cloud and Internet Computing, 3PGCIC 2014"
      },
      "publication_date": "2014-11-08",
      "selected": null,
      "title": "Analysis on Password Protection in Android Applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84946686236&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7024636",
        "https://dl.acm.org/doi/10.1109/3PGCIC.2014.102"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Kang S.W."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2663761.2664231",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "253-257",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450330602",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2014 Research in Adaptive and Convergent Systems, RACS 2014"
      },
      "publication_date": "2014-10-05",
      "selected": null,
      "title": "A robust and efficient birthmark-based android application filtering system",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84910014999&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Andersen J.S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 3,
      "pages": "191-193",
      "publication": {
        "category": "Journal",
        "cite_score": 0.3,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "13816551",
        "publisher": "Ada-Europe",
        "sjr": 0.126,
        "snip": 0.128,
        "subject_areas": [
          "Software"
        ],
        "title": "Ada User Journal"
      },
      "publication_date": "2014-09-01",
      "selected": null,
      "title": "Privacy leaks in java classes",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84908210715&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Li T."
      ],
      "categories": null,
      "citations": 15,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.7544/issn1000-1239.2014.20131897",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "1458-1466",
      "publication": {
        "category": "Journal",
        "cite_score": 2.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10001239",
        "publisher": "Science Press",
        "sjr": 0.312,
        "snip": 0.745,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Jisuanji Yanjiu yu Fazhan/Computer Research and Development"
      },
      "publication_date": "2014-07-01",
      "selected": null,
      "title": "Description of Android malware feature based on Dalvik instructions",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84907735165&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Viennot N."
      ],
      "categories": null,
      "citations": 146,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2591971.2592003",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "221-234",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 1.4,
        "is_potentially_predatory": false,
        "isbn": "9781450327893",
        "issn": "01635999",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.332,
        "snip": 0.354,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "SIGMETRICS 2014 - Proceedings of the 2014 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems"
      },
      "publication_date": "2014-06-20",
      "selected": null,
      "title": "A measurement study of Google Play",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84904350319&origin=inward",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84955581530&origin=inward"
      ]
    },
    {
      "abstract": "In view of the problems that exist in the copyright protection of Flash, a kind of digital watermark design scheme based on Flash animation is proposed. This scheme chooses the grey scale images including the more copyright information as the watermark information, and inserted them into the SWF files that are read in the byte array. The experiment demonstrates that, while it does not influence the playing result, this scheme can ensure the invisibility, high hiding capacity, etc. that are characteristic of the watermark, and can resist the decompilation attack effectively.",
      "authors": [
        "Hua Deng",
        "Jifu Zhang",
        "Xiaoli Chai"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IWECA.2014.6845664",
      "keywords": [
        "Flash animation",
        "watermarking",
        "SWF file"
      ],
      "number_of_pages": 3,
      "pages": "489-491",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4799-4566-5",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2014 IEEE Workshop on Electronics, Computer and Applications, IWECA 2014"
      },
      "publication_date": "2014-05-08",
      "selected": null,
      "title": "The design and implementation of Flash animation watermarking",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6845664",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84904568862&origin=inward"
      ]
    },
    {
      "abstract": "With the advent of cloud computing, a number of cloud providers have arisen to provide Storage-as-a-Service (SaaS) offerings to both regular consumers and business organizations. SaaS (different than Software-as-a-Service in this context) refers to an architectural model in which a cloud provider provides digital storage on their own infrastructure. Three models exist amongst SaaS providers for protecting the confidentiality data stored in the cloud: 1) no encryption (data is stored in plain text), 2) server-side encryption (data is encrypted once uploaded), and 3) client-side encryption (data is encrypted prior to upload). This paper seeks to identify weaknesses in the third model, as it claims to offer 100% user data confidentiality throughout all data transactions (e.g., upload, download, sharing) through a combination of Network Traffic Analysis, Source Code Decompilation, and Source Code Disassembly. The weaknesses we uncovered primarily center around the fact that the cloud providers we evaluated were each operating in a Certificate Authority capacity to facilitate data sharing. In this capacity, they assume the role of both certificate issuer and certificate authorizer as denoted in a Public-Key Infrastructure (PKI) scheme - which gives them the ability to view user data contradicting their claims of 100% data confidentiality. We have collated our analysis and findings in this paper and explore some potential solutions to address these weaknesses in these sharing methods. The solutions proposed are a combination of best practices associated with the use of PKI and other cryptographic primitives generally accepted for protecting the confidentiality of shared information.",
      "authors": [
        "Wilson, Duane",
        "Ateniese, Giuseppe"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Cryptography and Security",
          "Distributed, Parallel, and Cluster Computing"
        ],
        "title": "Information Security, Lecture Notes in Computer Science Volume\n  8783, 2014, pp 401-412"
      },
      "publication_date": "2014-04-10",
      "selected": null,
      "title": "To Share or Not to Share in Client-Side Encrypted Clouds",
      "urls": [
        "http://arxiv.org/abs/1404.2697v2",
        "http://arxiv.org/pdf/1404.2697.pdf",
        "http://arxiv.org/pdf/1404.2697v2"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ketterlin A."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.scico.2012.08.002",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "440-456",
      "publication": {
        "category": "Journal",
        "cite_score": 3.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01676423",
        "publisher": "Elsevier B.V.",
        "sjr": 0.517,
        "snip": 1.123,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Modeling and Simulation",
          "Information Systems",
          "Software"
        ],
        "title": "Science of Computer Programming"
      },
      "publication_date": "2014-02-01",
      "selected": null,
      "title": "Recovering memory access patterns of executable programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84889884909&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Book",
        "cite_score": 0.9,
        "is_potentially_predatory": false,
        "isbn": "9783030631277",
        "issn": "21945357",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.215,
        "snip": 0.291,
        "subject_areas": [
          "Computer Science (all)",
          "Control and Systems Engineering"
        ],
        "title": "Proceedings of the Future Technologies Conference"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "2014 World Conference on Information Systems and Technologies, WorldCIST 2014",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84898619558&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Juanda E.A."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.12928/v12i3.82",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "639-650",
      "publication": {
        "category": "Journal",
        "cite_score": 3.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16936930",
        "publisher": "Universitas Ahmad Dahlan",
        "sjr": 0.286,
        "snip": 0.558,
        "subject_areas": [
          "Electrical and Electronic Engineering"
        ],
        "title": "Telkomnika (Telecommunication Computing Electronics and Control)"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Designing comprehensive independent learning interactive multimedia and its resources demands",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84907912082&origin=inward"
      ]
    },
    {
      "abstract": "Smali code and .Dex file can be completely compiled and decompiled reciprocally. Thus any new functions can be injected into an existing android application directly after decompiling it into smali code under the condition of that we needn\u2019t to modify any java...",
      "authors": [
        "Xu, Junfeng",
        "Li, Shoupeng",
        "Zhang, Tao"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-11197-1_44",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "577-586",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Security Analysis and Protection Based on Smali Injection for Android Applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84958547661&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-319-11197-1_44.pdf"
      ]
    },
    {
      "abstract": "With the fast development of information technology, various software systems have been widely applied to production lines and office work. A lot of corporate data thus are stored and processed by these systems each day. Therefore, the security of the software systems is closely related to the data security and the core competitiveness of an enterprise. At present, Java becomes one of the most important programming languages of the enterprise application systems. Against its hidden risks that Trojans and Backdoors are easily implanted through decompilation, the author of this paper proposes a security enhancement technique based on JVMTI for Java software to effectively prevent the malicious users\u2019 decompilation through encrypting the bytecode files, thereby enhancing the security of the software.",
      "authors": [
        "Ze Peng Wen",
        "Gong Liang Li",
        "Yi Zheng Tao",
        "Guang Hong Yang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.4028/www.scientific.net/AMR.998-999.1247",
      "keywords": [
        "Java",
        "Security Enhancements",
        "JVMTI",
        "Encipherment",
        "Decompilation"
      ],
      "number_of_pages": 6,
      "pages": "1247-1252",
      "publication": {
        "category": "Book",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9783038351849",
        "issn": "10226680",
        "publisher": "Trans Tech Publications",
        "sjr": 0.121,
        "snip": 0.182,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Advanced Materials Research"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Researches on JVMTI-Based Security Enhancement Techniques for Java Software",
      "urls": [
        "https://www.scientific.net/AMR.998-999.1247.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84905722706&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Shanshan M."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1049/cp.2014.1340",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781849199285",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IET Conference Publications"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Android's sensitive data leakage detection based on API monitoring",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84929484447&origin=inward"
      ]
    },
    {
      "abstract": "Retargetable executable-code decompilation is a one of the most complicated\r\n   reverse-engineering tasks. Among others, it involves de-optimization of\r\n   compiler-optimized code. One type of such an optimization is usage of\r\n   so-called instruction idioms. These idioms are used to produce faster or\r\n   even smaller executable files. On the other hand, decompilation of\r\n   instruction idioms without any advanced analysis produces almost unreadable\r\n   high-level language code that may confuse the user of the decompiler. In\r\n   this paper, we revisit and extend the previous approach of\r\n   instruction-idioms detection used in a retargetable decompiler developed\r\n   within the Lissom project. The previous approach was based on detection of\r\n   instruction idioms in a very-early phase of decompilation (a front-end part)\r\n   and it was inaccurate for architectures with a complex instruction set (e.g.\r\n   Intel x86). The novel approach is based on delaying detection of idioms and\r\n   reconstruction of code to the later phase (a middleend part). For this\r\n   purpose, we use the LLVM optimizer and we implement this analysis as a new\r\n   pass in this tool. According to experimental results, this new approach\r\n   significantly outperforms the previous approach as well as the other\r\n   commercial solutions.",
      "authors": [
        "K\u00c5\u0099oustek,  Jakub",
        "Pokorn\u00c3\u00bd,  Fridol\u00c3\u00adn",
        "Kol\u00c3\u00a1\u00c5\u0099,  Du\u00c5\u00a1an"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.2298/CSIS131203076K",
      "keywords": [],
      "number_of_pages": 24,
      "pages": "1337-1360",
      "publication": {
        "category": "Journal",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "18200214",
        "publisher": "ComSIS Consortium",
        "sjr": 0.317,
        "snip": 0.577,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Computer Science and Information Systems"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "A new approach to instruction-idioms detection in a retargetable decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84923932809&origin=inward",
        "http://www.doiserbia.nb.rs/ft.aspx?id=1820-02141400076K"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Buinevich M."
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ICACT.2014.6778943",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "172-176",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9788996865032",
        "issn": "17389445",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "International Conference on Advanced Communication Technology, ICACT"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Method and utility for recovering code algorithms of telecommunication devices for vulnerability search",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84898933467&origin=inward"
      ]
    },
    {
      "abstract": "This paper proposes an obfuscation method against illegal analysis. The proposed method tries to build a fake call flow graph from debugging tools. The call flow graph represents relations among methods, and helps understanding of a program. The fake call flow graph leads misunderstanding of the program. We focus on a hook mechanism of the method call for changing a callee. We conduct two experiments to evaluate the proposed method. First experiment simulates attacks by existing tools: Soot, jad, Procyon, and Krakatau. The Procyon only succeeded decompilation, the others crashed. Second experiment evaluates understandability of the obfuscated program by the hand. Only one subject in the nine subjects answered the correct value. The experiments shows the proposed method has good tolerance against existing tools, and high difficulty of understanding even if the target program is tiny and simple program.",
      "authors": [
        "Kazumasa Fukuda",
        "Haruaki Tamada"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SNPD.2014.6888726",
      "keywords": [
        "Hook Mechanism",
        "Java 7",
        "Call Flow Graph",
        "Obfuscation"
      ],
      "number_of_pages": 6,
      "pages": "1-6",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4799-5604-3",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2014 IEEE/ACIS 15th International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing, SNPD 2014 - Proceedings"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "An obfuscation method to build a fake call flow graph by hooking method calls",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6888726",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84908701443&origin=inward"
      ]
    },
    {
      "abstract": "The conventional decompilation approach is based on a combination of heuristics and pattern matching. This approach depends on the processor architecture, the code generation templates used by the compiler, and the optimization level. In addition, there are specific...",
      "authors": [
        "Escalada, Javier",
        "Ortin, Franciso"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-05948-8_9",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "85-94",
      "publication": {
        "category": "Book",
        "cite_score": 0.9,
        "is_potentially_predatory": false,
        "isbn": "9783030631277",
        "issn": "21945357",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.215,
        "snip": 0.291,
        "subject_areas": [
          "Computer Science (all)",
          "Control and Systems Engineering"
        ],
        "title": "Proceedings of the Future Technologies Conference"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "An Adaptable Infrastructure to Generate Training Datasets for Decompilation Issues",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-319-05948-8_9.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84898668079&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Shah S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 7,
      "pages": "23-29",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781880843963",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "23rd International Conference on Software Engineering and Data Engineering, SEDE 2014"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Reverse engineering - A survey of tools involved in reverse engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84913586283&origin=inward"
      ]
    },
    {
      "abstract": "Static detection of malware variants plays an important role in system security and control flow has been shown as an effective characteristic that represents polymorphic malware. In our research, we propose a similarity search of malware to detect these variants using novel distance metrics. We describe a malware signature by the set of control flowgraphs the malware contains. We use a distance metric based on the distance between feature vectors of string-based signatures. The feature vector is a decomposition of the set of graphs into either fixed size k-subgraphs, or q-gram strings of the high-level source after decompilation. We use this distance metric to perform pre-filtering. We also propose a more effective but less computationally efficient distance metric based on the minimum matching distance. The minimum matching distance uses the string edit distances between programs' decompiled flowgraphs, and the linear sum assignment problem to construct a minimum sum weight matching between two sets of graphs. We implement the distance metrics in a complete malware variant detection system. The evaluation shows that our approach is highly effective in terms of a limited false positive rate and our system detects more malware variants when compared to the detection rates of other algorithms.",
      "authors": [
        "Silvio Cesare",
        "Yang Xiang",
        "Wanlei Zhou"
      ],
      "categories": null,
      "citations": 106,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TDSC.2013.40",
      "keywords": [
        "control flow",
        "Computer security",
        "static analysis",
        "decompilation",
        "structuring",
        "malware classification"
      ],
      "number_of_pages": 11,
      "pages": "307-317",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2160-9209",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE Transactions on Dependable and Secure Computing"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Control Flow-Based Malware VariantDetection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84904618097&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6601601"
      ]
    },
    {
      "abstract": "With the increasing scale of software system, the interaction between software elements becomes more and more complex, which lead to the increased dirty data in running software system. This may reduce the system performance and cause system collapse. In this paper, we proposed a discovery method of the dirty data transmission path based on complex network. Firstly, the binary file is decompiled and the function call graph is drawn by using the source code. Then the software structure is described as a weighted directed graph based on the knowledge of complex network. In addition, the dirty data node is marked by using the power-law distribution characteristics of the scale-free network construction of complex network chart. Finally, we found the dirty data transmission path during software running process. The experimental results show the transmission path of dirty data is accurate, which confirmed the feasibility of the method.",
      "authors": [
        "Xiao Lin Zhao",
        "Gang Hao",
        "Chang Zhen Hu",
        "Zhi Qiang Li"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.4028/www.scientific.net/AMM.651-653.1741",
      "keywords": [
        "Dirty Data",
        "Complex Network",
        "Function Call",
        "Decompilation"
      ],
      "number_of_pages": 7,
      "pages": "1741-1747",
      "publication": {
        "category": "Book",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9783038352679",
        "issn": "16609336",
        "publisher": "Trans Tech Publications",
        "sjr": 0.112,
        "snip": 0.0,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Applied Mechanics and Materials"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "A Discovery Method of the Dirty Data Transmission Path Based on Complex Network",
      "urls": [
        "https://www.scientific.net/AMM.651-653.1741.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84914674534&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sun Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-40618-8_81",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "625-631",
      "publication": {
        "category": "Book",
        "cite_score": 0.6,
        "is_potentially_predatory": false,
        "isbn": "9789811303104",
        "issn": "18761100",
        "publisher": "Springer Verlag",
        "sjr": 0.147,
        "snip": 0.158,
        "subject_areas": [
          "Industrial and Manufacturing Engineering"
        ],
        "title": "International Conference on Ubiquitous Information Technologies and Applications, International Conference on Computer Science and its Applications"
      },
      "publication_date": "2014-01-01",
      "selected": null,
      "title": "Code obfuscation technology based on renaming identifier",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84958542427&origin=inward"
      ]
    },
    {
      "abstract": "Machine-code decompilation, belonging to the area of reverse engineering, has found its applications in many real-world areas. Analysis of malicious software, search for vulnerabilities, and source-code recovery are some of the most important uses. As there exists a diversity of different platforms on which software can be run, an existence of a generic decompiler would be highly appreciated. The present paper describes such a tool. In this paper, we provide a description of a retargetable decompiler that is being developed within the Lissom project. First, we give an introduction into the area of machine-code decompilation, including a brief discussion of existing tools. Then, we describe the concept and architecture of the decompiler. As it is available in the form of a web service, we also provide its description. Finally, we summarize our results, present a case study of using the tool for analysing malicious software, and conclude the paper by several remarks on future research.",
      "authors": [
        "Luk\u00e1\u0161 \u010eurfina",
        "Jakub K\u0159oustek",
        "Petr Zemek"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WICT.2013.7113109",
      "keywords": [
        "Lissom",
        "retargetable decompiler",
        "reverse engineering",
        "web service",
        "decompilation"
      ],
      "number_of_pages": 6,
      "pages": "57-62",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4799-3230-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2013 Third World Congress on Information and Communication Technologies (WICT 2013)"
      },
      "publication_date": "2013-12-15",
      "selected": null,
      "title": "Retargetable machine-code decompilation in your web browser",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7113109",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84936970627&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zeng J."
      ],
      "categories": null,
      "citations": 50,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2508859.2516664",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "487-498",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450370899",
        "issn": "15437221",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ACM Conference on Computer and Communications Security"
      },
      "publication_date": "2013-12-09",
      "selected": null,
      "title": "Obfuscation resilient binary code reuse through trace-oriented programming",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84888988661&origin=inward"
      ]
    },
    {
      "abstract": "Verification of machine code can easily deteriorate into an endless clutter of low-level details. This paper presents a case study which shows that machine-code verification does not necessitate ghastly low-level proofs. The case study we describe is the construction...",
      "authors": [
        "Myreen, Magnus O.",
        "Curello, Gregorio"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-319-03545-1_5",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "66-81",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2013-12-01",
      "selected": null,
      "title": "Proof Pearl: A Verified Bignum Implementation in x86-64 Machine Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84893034163&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-319-03545-1_5.pdf"
      ]
    },
    {
      "abstract": "Although anyone can easily publish Android applications (or apps) in an app marketplace according to an open policy, decompiling the apps is also easy due to the structural characteristics of the app building process, making them very vulnerable to forgery or modification attacks. In particular, users may suffer direct financial loss if this vulnerability is exploited in security-critical private and business applications, such as online banking. In this paper, some of the major Android-based smartphone banking apps in Korea being distributed on either the Android Market or the third party market were tested to verify whether a money transfer could be made to an unintended recipient. The experimental results with real Android banking apps showed that an attack of this kind is possible without having to illegally obtain any of the sender\u2019s personal information, such as the senders public key certificate, the password to their bank account, or their security card. In addition, the cause of this vulnerability is analyzed and some technical countermeasures are discussed.",
      "authors": [
        "Jung, Jin-Hyuk",
        "Kim, Ju Young",
        "Lee, Hyeong-Chan",
        "Yi, Jeong Hyun"
      ],
      "categories": null,
      "citations": 65,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/s11277-013-1258-x",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "1421-1437",
      "publication": {
        "category": "Journal",
        "cite_score": 4.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09296212",
        "publisher": "Springer Netherlands",
        "sjr": 0.545,
        "snip": 0.908,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Computer Science Applications"
        ],
        "title": "Wireless Personal Communications"
      },
      "publication_date": "2013-12-01",
      "selected": null,
      "title": "Repackaging Attack on Android Banking Applications and Its Countermeasures",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84890552399&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/s11277-013-1258-x.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ko J."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2513228.2513308",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "336-340",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450323482",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2013 Research in Adaptive and Convergent Systems, RACS 2013"
      },
      "publication_date": "2013-12-01",
      "selected": null,
      "title": "Measuring similarity of Android applications via reversing and k-gram birthmarking",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84891478386&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Chen G."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/spe.2138",
      "keywords": [],
      "number_of_pages": 22,
      "pages": "1337-1358",
      "publication": {
        "category": "Journal",
        "cite_score": 6.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00380644",
        "publisher": "John Wiley and Sons Ltd",
        "sjr": 0.867,
        "snip": 1.301,
        "subject_areas": [
          "Software"
        ],
        "title": "Software - Practice and Experience"
      },
      "publication_date": "2013-11-01",
      "selected": null,
      "title": "A refined decompiler to generate C code with high readability",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84885929581&origin=inward"
      ]
    },
    {
      "abstract": "Reverse engineering of binary code is an essential step for malware analysis. However, it is a tedious and time-consuming task. Decompilation facilitates this process by transforming machine code into a high-level representation that is more concise and easier to understand. This paper describes REcompile, an efficient and extensible decompilation framework. REcompile uses the static single assignment form (SSA) as its intermediate representation and performs three main classes of analysis. Data flow analysis removes machine-specific details from code and transforms it into a concise high-level form. Type analysis finds variable types based on how those variables are used in code. Control flow analysis identifies high-level control structures such as conditionals, loops, and switch statements. These steps enable REcompile to produce well-readable decompiled code. The overall evaluation, using real programs and malware samples, shows that REcompile achieves a comparable and in many cases better performance than state-of-the-art decompilers.",
      "authors": [
        "Khaled Yakdan",
        "Sebastian Eschweiler",
        "Elmar Gerhards-Padilla"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/MALWARE.2013.6703690",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "95-102",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4799-2533-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2013 8th International Conference on Malicious and Unwanted Software: \"The Americas\", MALWARE 2013"
      },
      "publication_date": "2013-10-22",
      "selected": null,
      "title": "REcompile: A decompilation framework for static analysis of binaries",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6703690",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84893758823&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation (i.e. reverse compilation) represents one of the most toughest and challenging tasks in reverse engineering. Even more difficult task is the decompilation of malware because it typically does not follow standard application binary interface conventions, has stripped symbols, is obfuscated, and can contain polymorphic code. Moreover, in the recent years, there is a rapid expansion of various smart devices, running different types of operating systems on many types of processors, and malware targeting these platforms. These facts, combined with the boundedness of standard decompilation tools to a particular platform, imply that a considerable amount of effort is needed when decompiling malware for such a diversity of platforms. This is an experience paper reporting the decompilation of a real-world malware. We give a step-by-step case study of decompiling a MIPS worm called psyb0t by using a retargetable decompiler that is being developed within the Lissom project. First, we describe the decompiler in detail. Then, we present the case study. After that, we analyse the results obtained during the decompilation and present our personal experience. The paper is concluded by discussing future research possibilities.",
      "authors": [
        "Luk\u00e1s \u010eurfina",
        "Jakub K\u0159oustek",
        "Petr Zemek"
      ],
      "categories": null,
      "citations": 24,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2013.6671321",
      "keywords": [
        "Lissom",
        "retargetable decompiler",
        "Reverse engineering",
        "malware",
        "psyb0t",
        "decompilation",
        "experience"
      ],
      "number_of_pages": 8,
      "pages": "449-456",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4799-2931-3",
        "issn": "2375-5369",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2013-10-14",
      "selected": null,
      "title": "PsybOt malware: A step-by-step decompilation case study",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6671321",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84893379629&origin=inward"
      ]
    },
    {
      "abstract": "The very first step of each tool such as linker, disassembler, or debugger is\r\n   parsing of an input executable or object file. These files are stored in one\r\n   of the existing object file formats (OFF). Retargetable tools are not limited\r\n   to any particular target platform and they have to deal with handling of\r\n   several OFFs. Handling of these formats is similar to parsing of computer\r\n   languages - both of them have a predefined structure and a list of allowed\r\n   constructions. However, OFF constructions are heavily mutually interconnected\r\n   and they create context-sensitive units. In present, there is no generic\r\n   system, which can be used for OFF description and its effective parsing. In\r\n   this paper, we propose a formal language that can be used for OFF\r\n   description. Furthermore, we present a design of a context parser of this\r\n   language that is based on the formal models. The major advance of this\r\n   solution is an ability to describe context-sensitive properties on the level\r\n   of the language itself. This concept is planned to be used in the existing\r\n   retargetable decompiler developed within the Lissom project. In this project,\r\n   the language and its parser will be used for an object file parsing and its\r\n   automatic conversion into the internal uniform file format. It is important\r\n   to say that the concept of this parser can be utilized within other\r\n   programming languages.",
      "authors": [
        "K\u00c5\u0099oustek,  Jakub",
        "Kol\u00c3\u00a1\u00c5\u0099,  Du\u00c5\u00a1an"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.2298/CSIS130120071K",
      "keywords": [],
      "number_of_pages": 29,
      "pages": "1673-1701",
      "publication": {
        "category": "Journal",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "18200214",
        "publisher": "ComSIS Consortium",
        "sjr": 0.317,
        "snip": 0.577,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Computer Science and Information Systems"
      },
      "publication_date": "2013-10-01",
      "selected": null,
      "title": "Context parsing (not only) of the object-file-format description language",
      "urls": [
        "http://www.doiserbia.nb.rs/ft.aspx?id=1820-02141300071K",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84886776681&origin=inward"
      ]
    },
    {
      "abstract": "Machine-code decompilation is a reverse-engineering discipline focused on reverse compilation. It performs an application recovery from binary executable files back into the high level language (HLL) representation. One of its critical tasks is to produce an accurate and well-readable code. However, this is a challenging task since the executable code may be produced by one of the modern compilers that use advanced optimizations. One type of such an optimization is usage of so-called instruction idioms. These idioms are used to produce faster or even smaller executable files. On the other hand, decompilation of instruction idioms without any advanced analysis produces almost unreadable HLL code that may confuse the user of a decompiler. In this paper, we present a method of instruction-idioms detection and reconstruction back into a readable form with the same meaning. This approach is adapted in an existing retargetable decompiler developed within the Lissom project. The implementation has been tested on several modern compilers and target architectures. According to our experimental results, the proposed solution is highly accurate on the RISC (Reduced Instruction Set Computer) processor families, but it should be further improved on the CISC (Complex Instruction Set Computer) architectures.",
      "authors": [
        "Jakub K\u0159oustek",
        "Fridol\u00edn Pokorn\u00fd"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": null,
      "keywords": [
        "Lissom",
        "decompiler",
        "instruction idioms",
        "reverse engineering",
        "bit twiddling hacks",
        "compiler optimizations"
      ],
      "number_of_pages": 8,
      "pages": "1519-1526",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-83-60810-52-1",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2013 Federated Conference on Computer Science and Information Systems, FedCSIS 2013"
      },
      "publication_date": "2013-09-08",
      "selected": null,
      "title": "Reconstruction of instruction idioms in a retargetable decompiler",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6644218",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84892556138&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lee H."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1166/sl.2013.3004",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "1820-1827",
      "publication": {
        "category": "Journal",
        "cite_score": 0.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1546198X",
        "publisher": "American Scientific Publishers",
        "sjr": 0.159,
        "snip": 0.591,
        "subject_areas": [
          "Atomic and Molecular Physics, and Optics",
          "Electrical and Electronic Engineering"
        ],
        "title": "Sensor Letters"
      },
      "publication_date": "2013-09-01",
      "selected": null,
      "title": "Multi-signature based tamper detection scheme of android applications",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84893473031&origin=inward"
      ]
    },
    {
      "abstract": "We evaluate our decompiler, Phoenix, and our new structuring algorithm, on a set of 107 real world programs from GNU coreutils. Our evaluation is an order of magnitude larger than previous systematic studies of endto-end decompilers. We show that our decompiler outperforms the de facto industry standard decompiler Hex-Rays in correctness by 114%, and recovers 30\u00c3\u0097 more control-flow structure than existing structuring algorithms in the literature.",
      "authors": [
        "Edward J. Schwartz",
        "JongHyup Lee",
        "Maverick Woo",
        "David Brumley"
      ],
      "categories": null,
      "citations": 27,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/2534766.2534797",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "353-368",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781931971034",
        "issn": null,
        "publisher": "USENIX Association",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 22nd USENIX conference on Security"
      },
      "publication_date": "2013-08-14",
      "selected": null,
      "title": "Native \u00d786 decompilation using semantics-preserving structural analysis and iterative control-flow structuring",
      "urls": [
        "https://dl.acm.org/doi/10.5555/2534766.2534797"
      ]
    },
    {
      "abstract": "The article describes static and dynamic analysis techniques and its applicability in information security problems such as software protection against unauthorized research. The basic idea of the article is that techniques of dynamic and static analysis must be used in combination with each other to increase the effectiveness of binary code analysis. In the article authors make contributions in binary code decompilation and dynamic execution analysis techniques. The results are applied to the problem of software protection against unauthorized reverse engineering. Authors used analysis of the basic program control flow algorithm to obfuscate the program and protect it against research.",
      "authors": [
        "Maxim Shudrak",
        "Vyacheslav Zolotarev"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/EUROCON.2013.6624963",
      "keywords": [
        "control flow",
        "software protection",
        "static analysis",
        "dynamic",
        "obfuscation"
      ],
      "number_of_pages": 6,
      "pages": "40-45",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4673-2230-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE EuroCon 2013"
      },
      "publication_date": "2013-07-01",
      "selected": null,
      "title": "The technique of dynamic binary analysis and its application in the information security sphere",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84888581596&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6624963"
      ]
    },
    {
      "abstract": "This paper addresses the problem of modernizing graphical user interfaces of interactive applications by re-engineering their resource files in four phases: resource decompilation, which extracts resource files from the executable code of an interactive application; modeling the source user interface, which transforms extracted resources into a resource model; resource to user interface transformation, which transforms the resource model into a Concrete User Interface model, and forward engineering, which offers two alternatives: after editing the user interface model, a new interface could be generated or recompiled into a resource to be incorporated back. The paper motivates and details this re-engineering approach by focusing on methods and algorithms implemented in UsiResourcer, a software tool that reverse engineers MS Windows resource files into a Concrete User Interface Model for further process. A discussion on the generalization of the approach is also provided.",
      "authors": [
        "\u00d3scar S\u00e1nchez Ram\u00f3n",
        "Jean Vanderdonckt",
        "Jes\u00fas Garc\u00eda Molina"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/RCIS.2013.6577696",
      "keywords": [
        "Model Driven Engineering",
        "User Interfaces",
        "Reverse Engineering",
        "Modernization",
        "Reengineering"
      ],
      "number_of_pages": 12,
      "pages": "1-12",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4673-2912-5",
        "issn": "2151-1357",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE 7th International Conference on Research Challenges in Information Science (RCIS)"
      },
      "publication_date": "2013-05-29",
      "selected": null,
      "title": "Re-engineering graphical user interfaces from their resource files with UsiResourcer",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84884135526&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6577696"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ding Z."
      ],
      "categories": null,
      "citations": 36,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.micpro.2012.12.003",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "299-312",
      "publication": {
        "category": "Journal",
        "cite_score": 4.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01419331",
        "publisher": "Elsevier B.V.",
        "sjr": 0.488,
        "snip": 0.882,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Artificial Intelligence",
          "Software"
        ],
        "title": "Microprocessors and Microsystems"
      },
      "publication_date": "2013-03-25",
      "selected": null,
      "title": "Deriving an NCD file from an FPGA bitstream: Methodology, architecture and evaluation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84875126234&origin=inward"
      ]
    },
    {
      "abstract": "Software piracy is one of the major concerns of programmers and software developers costing them huge amounts of financial losses every year. One of the programming languages used to develop software is Java. Although Java has some advantages over other languages, programs written using it are more vulnerable to software piracy than others. This is due to the fact that decompiling Java programs to their source codes is a relatively easy task. This paper proposed a novel method of watermarking Java programs. The suggested technique aimed to embed a watermark by means of appending a spurious If statement on to it. The proposed method was then implemented and tested in order to evaluate its security and resiliency against different types of attacks. The experimental results showed that the new method is more resilient to obfuscation and decompile-recompile attacks in comparison with the methods proposed by Genevieve Arboit in A Method for Watermarking Java Programs via Opaque Predicates [7] and Monden et al in A Practical Method for Watermarking Java Programs [5].",
      "authors": [
        "Mohammad Alitavoli",
        "Mahdi Joafshani",
        "Aida Erfanian"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/2480362.2480556",
      "keywords": [
        "software piracy",
        "software protection",
        "Java protection",
        "copyright law",
        "software watermarking"
      ],
      "number_of_pages": 6,
      "pages": "1013-1018",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450316569",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 28th Annual ACM Symposium on Applied Computing"
      },
      "publication_date": "2013-03-18",
      "selected": null,
      "title": "A novel watermarking method for Java programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84877997961&origin=inward",
        "https://dl.acm.org/doi/10.1145/2480362.2480556"
      ]
    },
    {
      "abstract": "Signature-based malware detection systems have been a much used response to the pervasive problem of malware. Identification of malware variants is essential to a detection system and is made possible by identifying invariant characteristics in related samples. To classify the packed and polymorphic malware, this paper proposes a novel system, named Malwise, for malware classification using a fast application-level emulator to reverse the code packing transformation, and two flowgraph matching algorithms to perform classification. An exact flowgraph matching algorithm is employed that uses string-based signatures, and is able to detect malware with near real-time performance. Additionally, a more effective approximate flowgraph matching algorithm is proposed that uses the decompilation technique of structuring to generate string-based signatures amenable to the string edit distance. We use real and synthetic malware to demonstrate the effectiveness and efficiency of Malwise. Using more than 15,000 real malware, collected from honeypots, the effectiveness is validated by showing that there is an 88 percent probability that new malware is detected as a variant of existing malware. The efficiency is demonstrated from a smaller sample set of malware where 86 percent of the samples can be classified in under 1.3 seconds.",
      "authors": [
        "Silvio Cesare",
        "Yang Xiang",
        "Wanlei Zhou"
      ],
      "categories": null,
      "citations": 82,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TC.2012.65",
      "keywords": [
        "control flow",
        "structural classification",
        "structured control flow",
        "malware",
        "unpacking",
        "Computer security"
      ],
      "number_of_pages": 14,
      "pages": "1193-1206",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2326-3814",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE Transactions on Computers"
      },
      "publication_date": "2013-01-01",
      "selected": null,
      "title": "Malwise\u2014An Effective and Efficient Classification System for Packed and Polymorphic Malware",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84877264918&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6171162"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Dai C."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3969/j.issn.0253-2778.2013.07.009",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "574-579",
      "publication": {
        "category": "Journal",
        "cite_score": 0.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "02532778",
        "publisher": "China University of Science and Technology",
        "sjr": 0.11,
        "snip": 0.086,
        "subject_areas": [
          "Mechanical Engineering"
        ],
        "title": "Journal of University of Science and Technology of China"
      },
      "publication_date": "2013-01-01",
      "selected": null,
      "title": "The design and implementation of the frontier malicious code defense system",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84884913763&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Schwartz E.J."
      ],
      "categories": null,
      "citations": 89,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 16,
      "pages": "353-368",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781931971034",
        "issn": null,
        "publisher": "USENIX Association",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 22nd USENIX conference on Security"
      },
      "publication_date": "2013-01-01",
      "selected": null,
      "title": "Native x86 decompilation using semantics-preserving structural analysis and iterative control-flow structuring",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85022339056&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cesare S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 10,
      "pages": "21-30",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781921770258",
        "issn": "14451336",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Conferences in Research and Practice in Information Technology Series"
      },
      "publication_date": "2013-01-01",
      "selected": null,
      "title": "Simseer and Bugwise - web services for binary-level software similarity and defect detection",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84906995469&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Myreen M."
      ],
      "categories": null,
      "citations": 29,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 4,
      "pages": "78-81",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781467348324",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2012 Formal Methods in Computer-Aided Design, FMCAD 2012"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "Decompilation into logic - Improved",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84874587081&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "K\u0159oustek J."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1063/1.4756167",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "466-469",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "9780735410916",
        "issn": "0094243X",
        "publisher": "American Institute of Physics",
        "sjr": 0.164,
        "snip": 0.247,
        "subject_areas": [
          "Physics and Astronomy (all)"
        ],
        "title": "AIP Conference Proceedings"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "Object-file-format description language and its usage in retargetable decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84883097438&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhang Y.C."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3724/SP.J.1001.2012.04221",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "3149-3160",
      "publication": {
        "category": "Journal",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10009825",
        "publisher": "Chinese Academy of Sciences",
        "sjr": 0.305,
        "snip": 0.832,
        "subject_areas": [
          "Software"
        ],
        "title": "Ruan Jian Xue Bao/Journal of Software"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "Evidential reasoning method for decision of program maliciousness",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84871897210&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "Proceedings - 19th Working Conference on Reverse Engineering, WCRE 2012",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84872332293&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781467348324",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2012 Formal Methods in Computer-Aided Design, FMCAD 2012"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "2012 Formal Methods in Computer-Aided Design, FMCAD 2012",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84874585530&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781612082097",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "SECURWARE 2012 - 6th International Conference on Emerging Security Information, Systems and Technologies"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "SECURWARE 2012 - 6th International Conference on Emerging Security Information, Systems and Technologies",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84881399474&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "K\u0159oustek J."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 6,
      "pages": "79-84",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781612082097",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "SECURWARE 2012 - 6th International Conference on Emerging Security Information, Systems and Technologies"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "Accurate retargetable decompilation using additional debugging information",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84881411294&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhang M."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 9,
      "pages": "144-152",
      "publication": {
        "category": "Journal",
        "cite_score": 7.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16735447",
        "publisher": "China Institute of Communication",
        "sjr": 1.328,
        "snip": 1.349,
        "subject_areas": [
          "Computer Networks and Communications",
          "Electrical and Electronic Engineering"
        ],
        "title": "China Communications"
      },
      "publication_date": "2012-12-01",
      "selected": null,
      "title": "Malware detection in smart phones using static detection and evaluation model based on analytic hierarchy process",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84876807656&origin=inward"
      ]
    },
    {
      "abstract": "the article describes a new technique of binary code decompilation and its applicability in information security such as software protection against reverse engineering and code obfuscation analysis in malware. The basic idea of the article is the fact that the process of binary code decompilation doesn't require a machine code representation in source code view. The authors propose original decompilation technique based on restoration of code section algorithm. The technique uses a serial interpretation of binary code into intermediate code, analysis of program control flow and code transformation in the algorithmic form. The results are applied to the problem of malware obfuscation analyze and software protection against unauthorized reverse engineering. To solve the first problem, we used a serial algorithm for analysis of the resources used by the virus and the functional control flow separation. For solving the second problem we was also used analysis of the basic program control flow algorithm and additional threads to obfuscate the program and protect it against unauthorized reverse engineering.",
      "authors": [
        "Maxim Shudrak",
        "Vyacheslav Zolotarev"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/EMS.2012.20",
      "keywords": [
        "malware",
        "software protection",
        "binary code",
        "decomilation"
      ],
      "number_of_pages": 6,
      "pages": "115-120",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769549262",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2012 Sixth UKSim/AMSS European Symposium on Computer Modeling and Simulation"
      },
      "publication_date": "2012-11-14",
      "selected": null,
      "title": "The New Technique of Decompilation and Its Application in Information Security",
      "urls": [
        "https://dl.acm.org/doi/10.1109/EMS.2012.20",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6410138",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84874571569&origin=inward"
      ]
    },
    {
      "abstract": "In modern computer architecture, memory is an indispensable medium that software and systems relies upon when running on the computer. Messages about memory access could reflect attributes of programs, which should be invaluable with decompilation and security-related fields. This paper presents a novel memory access algorithm-SEA (Static Execution Analysis) for analyzing stripped executables. In order to support multi-source architectures, analysis is performed on a uniform intermediate representation, messages about memory access and register usage are recorded on an abstract memory model for further analysis. A tool integrating existing achievements is presented to show the usefulness of SEA. Experimental result has shown that SEA is of great help to solve some critical problems of decompilation and security.",
      "authors": [
        "Wang Guo-Hao",
        "Jiang Lie-Hui",
        "Jing Jing",
        "Li Dan"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/MINES.2012.199",
      "keywords": [
        "software analysis",
        "decompilation",
        "memory access",
        "abstract memory model",
        "security"
      ],
      "number_of_pages": 5,
      "pages": "887-891",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769548524",
        "issn": "2162-8998",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2012 Fourth International Conference on Multimedia Information Networking and Security"
      },
      "publication_date": "2012-11-02",
      "selected": null,
      "title": "SEA: Analyzing Memory Access of Executables",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84873109393&origin=inward",
        "https://dl.acm.org/doi/10.1109/MINES.2012.199",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6405831"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Qin Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3969/j.issn.1001-0505.2012.S2.006",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "256-260",
      "publication": {
        "category": "Journal",
        "cite_score": 1.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10010505",
        "publisher": "Southeast University",
        "sjr": 0.198,
        "snip": 0.352,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Dongnan Daxue Xuebao (Ziran Kexue Ban)/Journal of Southeast University (Natural Science Edition)"
      },
      "publication_date": "2012-11-01",
      "selected": null,
      "title": "Study of library functions identification in decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84878080783&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Boo P."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 2,
      "pages": "28-29",
      "publication": {
        "category": "Journal",
        "cite_score": 0.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "19333684",
        "publisher": "Questex Media Group Inc.",
        "sjr": 0.101,
        "snip": 0.0,
        "subject_areas": [
          "Materials Science (all)",
          "Forestry",
          "Marketing"
        ],
        "title": "Paper360"
      },
      "publication_date": "2012-11-01",
      "selected": null,
      "title": "Protecting Your Mill Against Cyber Threats: T1s a mi managerts nightmare a cyber security breach that threatens the mWI1s peope, automation, data and operation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84872442700&origin=inward"
      ]
    },
    {
      "abstract": "This paper presents improvements to a technique which aids verification of machine-code programs. This technique, called decompilation into logic, allows the verifier to only deal with tractable extracted models of the machine code rather than the concrete code itself. Our improvements make decompilation simpler, faster and more generally applicable. In particular, the new technique allows the verifier to avoid tedious reasoning directly in the underlying machine-code Hoare logic or the model of the instruction set architecture. The method described in this paper has been implemented in the HOL4 theorem prover.",
      "authors": [
        "Magnus O. Myreen",
        "Michael J. C. Gordon",
        "Konrad Slind"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 4,
      "pages": "78-81",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4673-4832-4",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2012 Formal Methods in Computer-Aided Design (FMCAD)"
      },
      "publication_date": "2012-10-22",
      "selected": null,
      "title": "Decompilation into logic \u2014 Improved",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6462558"
      ]
    },
    {
      "abstract": "Detection and recovery of high-level control structures, such as functions and their arguments, plays an important role in decompilation. It has a direct impact on the quality of the generated code because it is needed for generating functionally equivalent and highly readable code. In this paper, we present an innovative, platform-independent method of detection and recovery of functions and their arguments. This method is based on static code interpretation and iterative bidirectional search over reconstructed basic blocks. This approach has been adopted and tested in an existing retarget able decompiler. According to our experimental results, the proposed retarget able solution is fully competitive with existing hand-coded decompilers.",
      "authors": [
        "Lukas Durfina",
        "Jakub Kroustek",
        "Petr Zemek",
        "Bretislav Kabele"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2012.15",
      "keywords": [
        "Lissom",
        "control-flow analysis",
        "reverse engineering",
        "decompilation",
        "function detection"
      ],
      "number_of_pages": 10,
      "pages": "51-60",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769548913",
        "issn": "1095-1350",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2012 19th Working Conference on Reverse Engineering"
      },
      "publication_date": "2012-10-15",
      "selected": null,
      "title": "Detection and Recovery of Functions and their Arguments in a Retargetable Decompiler",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6385101",
        "https://dl.acm.org/doi/10.1109/WCRE.2012.15",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84872289590&origin=inward"
      ]
    },
    {
      "abstract": "\n                Introduction. Decompilation is used for translation of executable files into a high-level language (HLL) representation. It is an important mechanism for information forensics and malware analysis. Retargetable decompilation represents a very...",
      "authors": [
        "\u010eurfina, Luk\u00e1\u0161",
        "K\u0159oustek, Jakub",
        "Zemek, Petr",
        "K\u00e1bele, B\u0159etislav"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-33338-5_27",
      "keywords": [],
      "number_of_pages": 3,
      "pages": "390-392",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783642333378",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2012-09-12",
      "selected": null,
      "title": "Accurate Recovery of Functions in a Retargetable Decompiler(Poster Abstract)",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84867845671&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-642-33338-5_27.pdf",
        "https://dl.acm.org/doi/10.1007/978-3-642-33338-5_27"
      ]
    },
    {
      "abstract": "The compiled Java class file is not really binary files, it's just a kind of in-between code. This makes it possible for hackers to decompile the java class file, and in fact the decompiled file is almost the same as the original one. So it's very hard to protect the java application program, and there's a big issue about the security of java class file. This paper treated protecting software and using more costly forms of reverse engineering as the target, and deeply researched reverse engineering and code obfuscation about defense and attack. A prototype of Code obfuscation system (JOT) based on Java byte code is realized.",
      "authors": [
        "Le Yang",
        "Huo-jiao He"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CSSS.2012.21",
      "keywords": [
        "Code obfuscation",
        "Java",
        "Software protection"
      ],
      "number_of_pages": 4,
      "pages": "50-53",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769547190",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2012 International Conference on Computer Science and Service System, CSSS 2012"
      },
      "publication_date": "2012-08-11",
      "selected": null,
      "title": "Research on Java Bytecode Parse and Obfuscate Tool",
      "urls": [
        "https://dl.acm.org/doi/10.1109/CSSS.2012.21",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84873832074&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6394259"
      ]
    },
    {
      "abstract": "This paper considers Girard's internal coding of each term of System F by some term of a code type. This coding is the type-erasing coding definable already in the simply typed lambda-calculus using only abstraction on term variables. It is shown that there does not exist any decompiler for System F in System F, where the decompiler maps a term of System F to its code. An internal model of F is given by interpreting each type of F by some type equipped with maps between the type and the code type. This paper gives a decompiler-normalizer for this internal model in F, where the decompiler-normalizer maps any term of the internal model to the code of its normal form. It is also shown that for any model of F the composition of this internal model and the model produces another model of F whose equational theory is below untyped beta-eta-equality.",
      "authors": [
        "Stefano Berardi",
        "Makoto Tatsuta"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1016/j.tcs.2012.02.022",
      "keywords": [
        "Semantics of polymorphism",
        "Decompiler",
        "Compiler",
        "System F",
        "de Bruijn level",
        "Typed \u03bb-calculus"
      ],
      "number_of_pages": 18,
      "pages": "3-20",
      "publication": {
        "category": "Journal",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0304-3975",
        "publisher": "Elsevier B.V.",
        "sjr": 0.59,
        "snip": 1.037,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Theoretical Computer Science"
      },
      "publication_date": "2012-06-01",
      "selected": null,
      "title": "Internal models of system F for decompilation",
      "urls": [
        "https://dl.acm.org/doi/10.1016/j.tcs.2012.02.022",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84860218319&origin=inward"
      ]
    },
    {
      "abstract": "Information security is protecting information from unauthorized access, use, disclosure, disruption, modification, perusal and destruction. CAIN model suggest maintaining the Confidentiality, Authenticity, Integrity and Non-repudiation (CAIN) of information. Oracle 8i, 9i and 11g Databases support SQLJ framework allowing embedding of SQL statements in Java Programs and providing programmer friendly means to access the Oracle database. As cloud computing technology is becoming popular, SQLJ is considered as a flexible and user friendly language for developing distributed applications in grid architectures. SQLJ source codes are translated to java byte codes and decompilation is generation of source codes from intermediate byte codes. The intermediate SQLJ application byte codes are open to decompilation, allowing a malicious reader to forcefully decompile it for understanding confidential business logic or data from the codes. To the best of our knowledge, strong and cost effective techniques exist for Oracle Database security, but still data security techniques are lacking for client side applications, giving possibility for revelation of confidential business data. Data obfuscation is hiding the data in codes and we suggest enhancing the data security in SQLJ source codes by data hiding, to mitigate disclosure of confidential business data, especially integers in distributed applications.",
      "authors": [
        "Sivadasan, Praveen",
        "Lal, P. Sojan"
      ],
      "categories": null,
      "citations": null,
      "comments": "4 pages,3 Figures",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2012-05-22",
      "selected": null,
      "title": "Securing SQLJ Source Codes from Business Logic Disclosure by Data Hiding Obfuscation",
      "urls": [
        "http://arxiv.org/abs/1205.4813v1",
        "http://arxiv.org/pdf/1205.4813.pdf",
        "http://arxiv.org/pdf/1205.4813v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Myreen M."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.scico.2010.10.001",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "505-517",
      "publication": {
        "category": "Journal",
        "cite_score": 3.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01676423",
        "publisher": "Elsevier B.V.",
        "sjr": 0.517,
        "snip": 1.123,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Modeling and Simulation",
          "Information Systems",
          "Software"
        ],
        "title": "Science of Computer Programming"
      },
      "publication_date": "2012-04-01",
      "selected": null,
      "title": "Function extraction",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84857043549&origin=inward"
      ]
    },
    {
      "abstract": "The Two-Way-Compiler is an approach to show the equivalence between implemented source code and the generated binary program for safety-related software. A compiler which translates a source code into a binary program and restores the original source code out of the generated binary program exactly, like a decompiler, is described. Data that are required to build the original source code back again are especially examined in this paper. Some data are contained in the binary itself and other data lost during compilation. The lost data have to be collected and stored in the binary. With these additional data the decompiler can restore the binary program to the original source code.",
      "authors": [
        "D. Obermann",
        "J. B\u00f6rcs\u00f6k"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": null,
      "keywords": [
        "binary",
        "decompiler",
        "compiler",
        "source code"
      ],
      "number_of_pages": 4,
      "pages": "1-4",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-3-88579-294-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ARCS Workshops, ARCS 2012"
      },
      "publication_date": "2012-02-28",
      "selected": null,
      "title": "Two-Way-Compiler: Additional data saving for generating the original source code of a binary program",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84864195091&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6222219"
      ]
    },
    {
      "abstract": "Static binary analysis is more difficult than if source code is available. In many cases, the analyses are unsound and behaviours are omitted to make problems feasible. Heuristics may be required to separate code and data in a disassembly or pointer behaviour may be...",
      "authors": [
        "Cesare, Silvio",
        "Xiang, Yang"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-1-4471-2909-7_5",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "41-49",
      "publication": {
        "category": "Book",
        "cite_score": 0.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "21915768",
        "publisher": "Springer International Publishing",
        "sjr": 0.131,
        "snip": 0.0,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "SpringerBriefs in Computer Science"
      },
      "publication_date": "2012-01-01",
      "selected": null,
      "title": "Static Analysis of Binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84952326320&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-1-4471-2909-7_5.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "\u010eurfina L."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 5,
      "pages": "38-42",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "10th International Industrial Simulation Conference 2012, ISC 2012"
      },
      "publication_date": "2012-01-01",
      "selected": null,
      "title": "Generic source code migration using decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84898448097&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Park H.S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2330784.2330899",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "641-642",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450311786",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "GECCO'12 - Proceedings of the 14th International Conference on Genetic and Evolutionary Computation Companion"
      },
      "publication_date": "2012-01-01",
      "selected": null,
      "title": "Automatic Python programming using stack-based genetic programming",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84865027734&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Castelli C."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.4324/9780203813683-14",
      "keywords": [],
      "number_of_pages": 26,
      "pages": "65-90",
      "publication": {
        "category": "Book",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781136701832",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "The Global Governance of Knowledge Creation and Diffusion"
      },
      "publication_date": "2012-01-01",
      "selected": null,
      "title": "Innovation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85076287714&origin=inward"
      ]
    },
    {
      "abstract": "This paper presents a concept of a retargetable reverse compiler (i.e. a decompiler). This tool translates platform-specific binary applications into a high-level language (HLL) representation. A Python-like language was chosen as the target language. Our unique solution is automatically generated from the target platform description in the architecture description language (ADL) ISAC. The decompiler core is build on top of the LLVM Compiler System. As can be seen from the proof of concept, we are able to automatically generate a decompiler producing a highly readable HLL code for a Sony\u00ae PlayStation\u00ae Portable (PSP\u2122) platform while preserving the functional equivalency with the original application.",
      "authors": [
        "Luk\u00e1\u0161 \u010eurfina",
        "Jakub K\u0159oustek",
        "Petr Zemek",
        "Du\u0161an Kol\u00e1\u0159",
        "Tom\u00e1\u0161 Hru\u0161ka",
        "Karel Masa\u0159\u00edk",
        "Alexander Meduna"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/2209450.2209482",
      "keywords": [
        "ISAC",
        "Lissom",
        "reverse engineering",
        "LLVM",
        "malware",
        "decompilation"
      ],
      "number_of_pages": 6,
      "pages": "199-204",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781618040565",
        "issn": null,
        "publisher": "World Scientific and Engineering Academy and Society (WSEAS)",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2nd international conference on Circuits, Systems, Communications & Computers"
      },
      "publication_date": "2011-12-10",
      "selected": null,
      "title": "Design of an automatically generated retargetable decompiler",
      "urls": [
        "https://dl.acm.org/doi/10.5555/2209450.2209482"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "\u010eurfina L."
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 16,
      "pages": "91-106",
      "publication": {
        "category": "Journal",
        "cite_score": 0.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "17389976",
        "publisher": "Science and Engineering Research Support Society",
        "sjr": 0.146,
        "snip": 0.478,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "International Journal of Security and its Applications"
      },
      "publication_date": "2011-12-01",
      "selected": null,
      "title": "Design of a retargetable decompiler for a static platform-independent malware analysis",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84860378477&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zakai A."
      ],
      "categories": null,
      "citations": 156,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2048147.2048224",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "301-312",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450309424",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11, DLS'11, and SPLASH'11 Companion"
      },
      "publication_date": "2011-11-22",
      "selected": null,
      "title": "Emscripten: An LLVM-to-JavaScript compiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=81355123361&origin=inward"
      ]
    },
    {
      "abstract": "Reverse program compilation (i.e. decompilation) is a process heavily exploited in reverse engineering. The task of decompilation is to transform a platform-specific executable into a high-level language representation, which is usually the C language. Such a process can be used for source code reconstruction, compiler testing, malware analysis, etc. In present, there are several existing decompilers that are able to decompile simple applications. However, we can see a drop-off in terms of the quality of the generated code when the decompiled code is highly optimized (e.g. usage of instruction idioms) or obfuscated (e.g. dead code insertion, register renaming). Optimized or obfuscated applications are usually generated by highly optimizing compilers or metamorphic engines (used by malware authors). In this paper, we present several innovative decompilation methods based on scattered context grammars. These methods are able to effectively decompile optimized or obfuscated code. For demonstration, we used these methods for enhancement of the static analysis phase of an existing decompiler. Experimental results of our solution are presented at the end of the paper.",
      "authors": [
        "Luk\u00e1\u0161 \u010eurfina",
        "Jakub K\u0159oustek",
        "Petr Zemek",
        "Du\u0161an Kol\u00e1\u0159",
        "Tom\u00e1\u0161 Hru\u0161ka",
        "Karel Masa\u0159\u00edk",
        "Alexander Meduna"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/2183027.2183056",
      "keywords": [
        "Lissom",
        "scattered context grammars",
        "static analysis",
        "decompilation",
        "LLVM IR"
      ],
      "number_of_pages": 6,
      "pages": "164-169",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781618040510",
        "issn": null,
        "publisher": "World Scientific and Engineering Academy and Society (WSEAS)",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 13th IASME/WSEAS international conference on Mathematical Methods and Computational Techniques in Electrical Engineering conference on Applied Computing"
      },
      "publication_date": "2011-11-17",
      "selected": null,
      "title": "Advanced static analysis for decompilation using scattered context grammars",
      "urls": [
        "https://dl.acm.org/doi/10.5555/2183027.2183056"
      ]
    },
    {
      "abstract": "Static detection of polymorphic malware variants plays an important role to improve system security. Control flow has shown to be an effective characteristic that represents polymorphic malware instances. In our research, we propose a similarity search of malware using novel distance metrics of malware signatures. We describe a malware signature by the set of control flow graphs the malware contains. We propose two approaches and use the first to perform pre-filtering. Firstly, we use a distance metric based on the distance between feature vectors. The feature vector is a decomposition of the set of graphs into either fixed size k-subgraphs, or q-gram strings of the high-level source after decompilation. We also propose a more effective but less computationally efficient distance metric based on the minimum matching distance. The minimum matching distance uses the string edit distances between programs' decompiled flow graphs, and the linear sum assignment problem to construct a minimum sum weight matching between two sets of graphs. We implement the distance metrics in a complete malware variant detection system. The evaluation shows that our approach is highly effective in terms of a limited false positive rate and our system detects more malware variants when compared to the detection rates of other algorithms.",
      "authors": [
        "Silvio Cesare",
        "Yang Xiang"
      ],
      "categories": null,
      "citations": 49,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TrustCom.2011.26",
      "keywords": [
        "control flow",
        "computer security",
        "decompilation",
        "structuring",
        "static analysi",
        "malware classification"
      ],
      "number_of_pages": 9,
      "pages": "181-189",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-5090-4907-3",
        "issn": "2324-9013",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 16th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, 11th IEEE International Conference on Big Data Science and Engineering and 14th IEEE International Conference on Embedded Software and Systems, Trustcom/BigDataSE/ICESS 2017"
      },
      "publication_date": "2011-11-16",
      "selected": null,
      "title": "Malware Variant Detection Using Similarity Search over Sets of Control Flow Graphs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84856189723&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6120818"
      ]
    },
    {
      "abstract": "Integer overflow vulnerability will cause buffer overflow. The research on the relationship between them will help us to detect integer overflow vulnerability. We present a dynamic analysis methods RICB (Run-time Integer Checking via Buffer overflow). Our approach...",
      "authors": [
        "Wang, Yong",
        "Gu, Dawu",
        "Xu, Jianping",
        "Wen, Mi",
        "Deng, Liwen"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-23602-0_9",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "99-109",
      "publication": {
        "category": "Book",
        "cite_score": 0.7,
        "is_potentially_predatory": false,
        "isbn": "9783030734282",
        "issn": "18678211",
        "publisher": "Springer Verlag",
        "sjr": 0.159,
        "snip": 0.137,
        "subject_areas": [
          "Computer Networks and Communications"
        ],
        "title": "Lecture Notes of the Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering, LNICST"
      },
      "publication_date": "2011-11-14",
      "selected": null,
      "title": "RICB: Integer Overflow Vulnerability Dynamic Analysis via Buffer Overflow",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-642-23602-0_9.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84885889718&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is a reconstruction of a program in a high-level language from a program in a low-level language. Typical applications of decompilation are software security assessment, malware analysis, error correction and reverse engineering for interoperability. Native code decompilation is traditionally considered in the context of the C programming language. C++ presents new challenges for decompilation, since the rules of translation from C++ to assembly language are far more complex than those of C. In addition, when decompiling a program that was originally written in C++, reconstruction of C++ specific constructs is desired. In this paper we discuss new methods that allow partial recovery of C++ specific language constructs from a low-level code provided that this code was obtained from a C++ compiler. The challenges that arise when decompiling such code are described. These challenges include reconstruction of polymorphic classes, class hierarchies, member functions and exception handling constructs. An approach to decompilation that is used to overcome these challenges is presented. Smart Dec, a native code to C++ decompiler that is being developed by the authors at Select LTD is presented. It reconstructs expressions, function arguments, local and global variables, integral and composite types, loops and compound conditional statements, C++ class hierarchies and exception handling constructs. An empirical study of the decompiler is provided.",
      "authors": [
        "Alexander Fokin",
        "Egor Derevenetc",
        "Alexander Chernov",
        "Katerina Troshina"
      ],
      "categories": null,
      "citations": 32,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2011.49",
      "keywords": [
        "Exception Reconstruction",
        "Class Hierarchy Reconstruction",
        "Reverse Engineering",
        "Decompilation",
        "C++"
      ],
      "number_of_pages": 10,
      "pages": "347-356",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769545820",
        "issn": "1095-1350",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2011 18th Working Conference on Reverse Engineering"
      },
      "publication_date": "2011-10-17",
      "selected": null,
      "title": "SmartDec: Approaching C++ Decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=83455205842&origin=inward",
        "https://dl.acm.org/doi/10.1109/WCRE.2011.49",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6079860"
      ]
    },
    {
      "abstract": "Today software has already become the critical e-assets integrated with valuable intellectual property, such as functions, processes or secrets, etc. The problem is that software, especially written in intermediate languages (Java, .NET, etc) are easy to be decompiled for reverse engineering, so the proprietary business logic, core algorithm implementation, software licensing code, and copy protection mechanisms of software are more susceptible to malicious reuse. Anyone with special decompile or reverse engineering tools such as .NET Reflect, JAD can exploit the vulnerabilities, steal unique ideas, bypass license checks, etc. In this paper we describe a key hiding based software encryption method to protect the intellectual and copy rights for software.",
      "authors": [
        "Jian Jun Hu",
        "Qiaoyan Wen",
        "Wen Tang",
        "Ai-Fen Sui"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICCT.2011.6157970",
      "keywords": [
        "Key-hiding",
        "Software protection"
      ],
      "number_of_pages": 4,
      "pages": "719-722",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-61284-305-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "International Conference on Communication Technology Proceedings, ICCT"
      },
      "publication_date": "2011-09-25",
      "selected": null,
      "title": "A key hiding based software encryption protection scheme",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84863283543&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6157970"
      ]
    },
    {
      "abstract": "Together with the massive expansion of smartphones, tablets, and other smart devices, we can notice a\u00a0growing number of malware threats targeting these platforms. Software security companies are not prepared for such diversity of target platforms and there are...",
      "authors": [
        "\u010eurfina, Luk\u00e1\u0161",
        "K\u0159oustek, Jakub",
        "Zemek, Petr",
        "Kol\u00e1\u0159, Du\u0161an",
        "Hru\u0161ka, Tom\u00e1\u0161",
        "Masa\u0159\u00edk, Karel",
        "Meduna, Alexander"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-23141-4_8",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "72-86",
      "publication": {
        "category": "Book",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": "9789811399411",
        "issn": "18650929",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.194,
        "snip": 0.241,
        "subject_areas": [
          "Computer Science (all)",
          "Mathematics (all)"
        ],
        "title": "International Conference of Pioneering Computer Scientists, Engineers and Educators"
      },
      "publication_date": "2011-09-07",
      "selected": null,
      "title": "Design of a\u00a0Retargetable Decompiler for a\u00a0Static Platform-Independent Malware Analysis",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=80052329933&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-642-23141-4_8.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Book",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": "9789811399411",
        "issn": "18650929",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.194,
        "snip": 0.241,
        "subject_areas": [
          "Computer Science (all)",
          "Mathematics (all)"
        ],
        "title": "International Conference of Pioneering Computer Scientists, Engineers and Educators"
      },
      "publication_date": "2011-09-07",
      "selected": null,
      "title": "Information Security and Assurance - International Conference, ISA 2011, Proceedings",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=80052330748&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Rosenblum N."
      ],
      "categories": null,
      "citations": 55,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/2001420.2001433",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "100-110",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450305624",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2011 International Symposium on Software Testing and Analysis, ISSTA 2011 - Proceedings"
      },
      "publication_date": "2011-08-26",
      "selected": null,
      "title": "Recovering the toolchain provenance of binary code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=80051948738&origin=inward"
      ]
    },
    {
      "abstract": "Unlike other sciences such as Mathematics and Biology, for example, computation is presented to students at a later learning stage. Even though they are able to establish sets of procedures, it is alleged that in their first years of elementary school, children do not yet present cognitive structures capable of representing symbolically, through existing computer programming languages, the algorithms associated with such procedures. Within this context, there has appeared recently a robotic kit named Topobo, capable of capturing manual movements carried out in their blocks. This article presents th first result associated with the use of Topobo as a language of manual programming. The study will lead to a decompiler able to furnish, with its control flux and its structure of adequate data, the program which results from the manual manipulation of the system by the child. In a more precise form, this work anticipates the utilization of fuzzy concepts for the representation of knowledge generated from the registers of manual programming of the Topobo elements. The utilization of the fuzzy formalism will allow a qualitative and diffuse description of the knowledge, in a manner very similar to the \"intuitive\" and \"little precise\" way which human beings handle information (mainly children), leading to an adequate structure and representation of the data which are being manipulated. In addition to the formalism adopted, the article presents a 3D interface which will be helpful in the performance of the experiments. In possession of the decompiled programs, we intend to evaluate the structure of data and control fluxes which will emerge in order to identify the mental structures utilized in the construction of algorithms through manual programming by children.",
      "authors": [
        "Mateus Madail Santin",
        "Silvia da Silva Costa Botelho",
        "Gracaliz Pereira Dimuro",
        "Celso Luiz Lopes Rodrigues"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WEIT.2011.30",
      "keywords": [
        "skill programming",
        "learning environment",
        "Topobo",
        "logic fuzzy"
      ],
      "number_of_pages": 7,
      "pages": "67-73",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4673-0225-8",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2011 Workshop-School on Theoretical Computer Science, WEIT 2011"
      },
      "publication_date": "2011-08-24",
      "selected": null,
      "title": "Hand Skill Programming: Using Fuzzy Sets to Program Topobo Kinectis Memory Devices",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84856195774&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6114783"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Hu C."
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 9,
      "pages": "1455-1463",
      "publication": {
        "category": "Journal",
        "cite_score": 2.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10001239",
        "publisher": "Science Press",
        "sjr": 0.312,
        "snip": 0.745,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Jisuanji Yanjiu yu Fazhan/Computer Research and Development"
      },
      "publication_date": "2011-08-01",
      "selected": null,
      "title": "Detecting the vulnerability pattern of writing tainted value to tainted address",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=80052664982&origin=inward"
      ]
    },
    {
      "abstract": "Detecting a given algorithm in a program without access to its source code can be valuable in many tasks ranging from intellectual property management to verifying the program's security properties. Unfortunately, approaches based on decompiling or reverse-engineering the program suffer from prohibitive costlyness as well as theoretical limitations. Instead we base our work on examining the program's internal dynamic behavior and trying to find in it tell-tale signs of the given algorithm using various pattern matching and statistical analysis techniques.",
      "authors": [
        "Kenneth Oksanen"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/2002951.2002953",
      "keywords": [
        "intellectual property",
        "pattern matching",
        "security",
        "program traces"
      ],
      "number_of_pages": 6,
      "pages": "1-6",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450308113",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "9th International Workshop on Dynamic Analysis, WODA 2011 - Proceedings"
      },
      "publication_date": "2011-07-18",
      "selected": null,
      "title": "Detecting algorithms using dynamic analysis",
      "urls": [
        "https://dl.acm.org/doi/10.1145/2002951.2002953",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=80051926358&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Jethi M."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 8,
      "pages": "313-320",
      "publication": {
        "category": "Journal",
        "cite_score": 0.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09717544",
        "publisher": "National Institute of Science Communication and Information Resources (NISCAIR)",
        "sjr": 0.192,
        "snip": 0.511,
        "subject_areas": [
          "Law"
        ],
        "title": "Journal of Intellectual Property Rights"
      },
      "publication_date": "2011-07-01",
      "selected": null,
      "title": "Dealing 'fairly' with software in India",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79960880755&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wu W."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.3724/SP.J.1016.2011.00738",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "738-747",
      "publication": {
        "category": "Journal",
        "cite_score": 2.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "02544164",
        "publisher": "Science Press",
        "sjr": 0.29,
        "snip": 0.741,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Computer Graphics and Computer-Aided Design",
          "Software"
        ],
        "title": "Jisuanji Xuebao/Chinese Journal of Computers"
      },
      "publication_date": "2011-04-01",
      "selected": null,
      "title": "Study of user and library functions distinguishing technology in decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79956222648&origin=inward"
      ]
    },
    {
      "abstract": "We study the correspondence between a concurrent lambda-calculus in administrative, continuation passing style and a pi-calculus and we derive a termination result for the latter.",
      "authors": [
        "Amadio, Roberto"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2011-02-11",
      "selected": null,
      "title": "A decompilation of the pi-calculus and its application to termination",
      "urls": [
        "http://arxiv.org/pdf/1102.2339.pdf",
        "http://arxiv.org/abs/1102.2339v1",
        "http://arxiv.org/pdf/1102.2339v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sobania J.A."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 14,
      "pages": "1-14",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9783869561295",
        "issn": "21911665",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Technische Berichte des Hasso-Plattner-Instituts fur Softwaresystemtechnik an der Universitat Potsdam"
      },
      "publication_date": "2011-01-01",
      "selected": null,
      "title": "Towards a Truly Retargetable Decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85160680923&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Enck W."
      ],
      "categories": null,
      "citations": 686,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 16,
      "pages": "315-330",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781931971874",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 20th USENIX Security Symposium"
      },
      "publication_date": "2011-01-01",
      "selected": null,
      "title": "A study of android application security",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85025700509&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9783869561295",
        "issn": "21911665",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Technische Berichte des Hasso-Plattner-Instituts fur Softwaresystemtechnik an der Universitat Potsdam"
      },
      "publication_date": "2011-01-01",
      "selected": null,
      "title": "Proceedings of the 5th Ph.D. Retreat of the HPI Research School on Service-Oriented Systems Engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85160711528&origin=inward"
      ]
    },
    {
      "abstract": "Aiming at the problem of control structure nesting relation that has not been resolved in existing control structure recovery algorithms, a novel method to recover high-level control structure based on control tree is presented. Firstly, the method structures control flow graph based on existing control flow graph structuring algorithms. Secondly, the method constructs control tree in reverse post order based on the information of control structure gained via structuring algorithm, and finally high-level control structure is able to be recovered by traversing control tree in post order. Experimental results show that the method can recover high-level control structure truly and effectively to provide exact information of control structure for high-level language code generation afterwards and improve veracity of decompilation results.",
      "authors": [
        "Qing Yin",
        "Xuying Liu",
        "Liehui Jiang",
        "Jinfen Liu",
        "Yong Liu"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICIECS.2010.5678251",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "1-4",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-7939-9",
        "issn": "2156-7379",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2nd International Conference on Information Engineering and Computer Science - Proceedings, ICIECS 2010"
      },
      "publication_date": "2010-12-25",
      "selected": null,
      "title": "Research on High-Level Control Structure Recovery Based on Control Tree",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79951622621&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5678251"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769541785",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 10th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2010"
      },
      "publication_date": "2010-12-01",
      "selected": null,
      "title": "Proceedings - 10th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2010",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78649407883&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wang Y."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 7,
      "pages": "10-16",
      "publication": {
        "category": "Journal",
        "cite_score": 7.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16735447",
        "publisher": "China Institute of Communication",
        "sjr": 1.328,
        "snip": 1.349,
        "subject_areas": [
          "Computer Networks and Communications",
          "Electrical and Electronic Engineering"
        ],
        "title": "China Communications"
      },
      "publication_date": "2010-12-01",
      "selected": null,
      "title": "RICB: Integer overflow vulnerability dynamic analysis via buffer overflow",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=80051996545&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cesare S."
      ],
      "categories": null,
      "citations": 80,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 10,
      "pages": "61-70",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781921770258",
        "issn": "14451336",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Conferences in Research and Practice in Information Technology Series"
      },
      "publication_date": "2010-12-01",
      "selected": null,
      "title": "Classification of malware using structured control flow",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84869003423&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Vall\u00e9e-Rai R."
      ],
      "categories": null,
      "citations": 218,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1925805.1925818",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "214-224",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of CASCON - 1st Decade High Impact Papers"
      },
      "publication_date": "2010-12-01",
      "selected": null,
      "title": "Soot - A Java bytecode optimization framework",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79952157802&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2010-12-01",
      "selected": null,
      "title": "Proceedings - 17th Working Conference on Reverse Engineering, WCRE 2010",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78650649526&origin=inward"
      ]
    },
    {
      "abstract": "With the rapid development of Internet and softwareindustry, software security and piracy has become a veryimportant issue.",
      "authors": [
        "J. Chen",
        "C. Wang",
        "Q. Shi",
        "G. Lv"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.2316/P.2010.726-026",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "542-547",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780889868786",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the IASTED International Conference on Communication and Information Security, CIS 2010"
      },
      "publication_date": "2010-12-01",
      "selected": null,
      "title": "Implementation of Bytecode-based Software Watermarking for Java Programs",
      "urls": [
        "http://actapress.com/pdfviewer.aspx?paperID=41725",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84862293052&origin=inward"
      ]
    },
    {
      "abstract": "Methods of improving the decompilation quality, that is, the reconstruction of a program in a high-level language from a given program in a low-level language, are considered. Decompilation is considered as a reverse engineering problem; problems of decompilation quality are examined, and metrics for assessing this quality are proposed.",
      "authors": [
        "Troshina, E. N.",
        "Chernov, A. V."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1134/S0361768810060046",
      "keywords": [],
      "number_of_pages": 20,
      "pages": "343-362",
      "publication": {
        "category": "Journal",
        "cite_score": 1.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0361-7688",
        "publisher": "Pleiades Publishing",
        "sjr": 0.232,
        "snip": 0.474,
        "subject_areas": [
          "Software"
        ],
        "title": "Programming and Computer Software"
      },
      "publication_date": "2010-11-01",
      "selected": null,
      "title": "Using information obtained in the course of program execution for improving the quality of data type reconstruction in decompilation",
      "urls": [
        "https://dl.acm.org/doi/10.1134/S0361768810060046",
        "https://link.springer.com/content/pdf/10.1134/S0361768810060046.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78649816842&origin=inward"
      ]
    },
    {
      "abstract": "With the rapidly development of virus technology, the number of malicious code has continued to increase. So it is imperative to optimize the traditional manual analysis method by automatic maliciousness decision system. Motivated by the inference technique for detecting viruses, and a recent successful classification method, we explore Radux-an automatic software maliciousness decision system. It rests on artificial neural network based on behavior hidden in malicious code. Decompile technique is applied to characterize behavioral and structural properties of binary code, which creates more abstract descriptions of malware. Experiment shows that this system can decision software maliciousness efficiently.",
      "authors": [
        "Zhang Yichi",
        "Pang Jianmin",
        "Zhao Rongcai",
        "Guo Zhichang"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICICISYS.2010.5658423",
      "keywords": [
        "maliciousness decision",
        "software behavior",
        "artificial neural network"
      ],
      "number_of_pages": 4,
      "pages": "622-625",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-6584-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2010 IEEE International Conference on Intelligent Computing and Intelligent Systems, ICIS 2010"
      },
      "publication_date": "2010-10-29",
      "selected": null,
      "title": "Artificial neural network for decision of software maliciousness",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5658423",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78651289580&origin=inward"
      ]
    },
    {
      "abstract": "The current commercial anti-virus software detects a virus only after the virus has appeared and caused damage. Motivated by the inference technique for detecting viruses, and a recent successful classification method, we explore a system (Radux: Reverse Analysis for Detecting Unsafe eXecutables) for automatically detecting malicious code using the collected dataset of the benign and malicious code. Our system rests on fuzzy inference based on behavior hidden in malicious code. Decompile technique is applied to characterize behavioral and structural properties of binary code, which creates more abstract descriptions of malware. The proposed method can acquire the fuzzy subsets and its membership function in an automatic way with the GD-FNN learning algorithm. The experimental data give support to the validity of this method. Moreover, our system is resilient to common obfuscations used by hackers.",
      "authors": [
        "Yichi Zhang",
        "Jianmin Pang",
        "Feng Yue",
        "Jinxian Cui"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ISDEA.2010.314",
      "keywords": [
        "program behavior",
        "malware detection",
        "GD-FNN",
        "fuzzy inference",
        "fuzzy neural network"
      ],
      "number_of_pages": 4,
      "pages": "780-783",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-8333-4",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2010 International Conference on Intelligent System Design and Engineering Application, ISDEA 2010"
      },
      "publication_date": "2010-10-13",
      "selected": null,
      "title": "Fuzzy Neural Network for Malware Detect",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79955777626&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5743295"
      ]
    },
    {
      "abstract": "As a key part of reverse engineering, decompilation plays a very important role in software security and maintenance. Unfortunately, most existing decompilation tools suffer from the low accuracy in identifying variables, functions and composite structures, which results in poor readability. To address these limitations, we present a practical decompiler called C-Decompiler for Windows C programs that (1) uses a shadow stack to perform refined data flow analysis, and (2) adopts inter-basic-block register propagation to reduce redundant variables. Our experimental results illustrate that on average C-Decompiler has the highest total percentage reduction of 55.91%, lowest variable expansion rate of 55.79% in the three tools, and the same Cyclomatic Complexity as the original source code for each test application. Furthermore, in our experiment, C-Decompiler is able to recognize functions with lower false positive and false negative rate. In the studies, we show that C-Decompiler is a practical tool to produce highly readable C code.",
      "authors": [
        "Gengbiao Chen",
        "Zhuo Wang",
        "Ruoyu Zhang",
        "Kan Zhou",
        "Shiqiu Huang",
        "Kangqi Ni",
        "Zhengwei Qi",
        "Kai Chen",
        "Haibing Guan"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2010.24",
      "keywords": [
        "Reverse Engineering",
        "Decompilation"
      ],
      "number_of_pages": 5,
      "pages": "150-154",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769541235",
        "issn": "1095-1350",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2010 17th Working Conference on Reverse Engineering"
      },
      "publication_date": "2010-10-13",
      "selected": null,
      "title": "A Refined Decompiler to Generate C Code with High Readability",
      "urls": [
        "https://dl.acm.org/doi/10.1109/WCRE.2010.24",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78650638745&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5645445"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhang J."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.4304/jsw.5.10.1084-1090",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "1084-1090",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "1796217X",
        "publisher": "Academy Publisher",
        "sjr": 0.149,
        "snip": 0.473,
        "subject_areas": [
          "Human-Computer Interaction",
          "Artificial Intelligence",
          "Software"
        ],
        "title": "Journal of Software"
      },
      "publication_date": "2010-10-01",
      "selected": null,
      "title": "Cross-platform transplant of embedded smart devices",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78651585638&origin=inward"
      ]
    },
    {
      "abstract": "This paper presents a method for deriving an expression from the low-level code compiled from an expression in a high-level language. The input is the low-level code represented as blocks of code connected by goto statements, i.e., a control flow graph (CFG). The...",
      "authors": [
        "Barnett, Mike",
        "Leino, K. Rustan M."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-15057-9_11",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "157-168",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2010-09-30",
      "selected": null,
      "title": "To Goto Where No Statement Has Gone Before",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77957088318&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-642-15057-9_11.pdf"
      ]
    },
    {
      "abstract": "Fighting against computer malware require a mandatory step of reverse engineering. As soon as the code has been disassemblied/decompiled (including a dynamic analysis step), there is a hope to understand what the malware actually does and to implement a detection mean. This also applies to protection of software whenever one wishes to analyze them. In this paper, we show how to amour code in such a way that reserse engineering techniques (static and dymanic) are absolutely impossible by combining malicious cryptography techniques developped in our laboratory and new types of programming (k-ary codes). Suitable encryption algorithms combined with new cryptanalytic approaches to ease the protection of (malicious or not) binaries, enable to provide both total code armouring and large scale polymorphic features at the same time. A simple 400 Kb of executable code enables to produce a binary code and around $2^{140}$ mutated forms natively while going far beyond the old concept of decryptor.",
      "authors": [
        "Filiol, Eric"
      ],
      "categories": null,
      "citations": null,
      "comments": "17 pages, 2 figures, accepted for presentation at H2HC'10",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2010-09-21",
      "selected": null,
      "title": "Malicious cryptography techniques for unreversable (malicious or not) binaries",
      "urls": [
        "http://arxiv.org/pdf/1009.4000.pdf",
        "http://arxiv.org/pdf/1009.4000v1",
        "http://arxiv.org/abs/1009.4000v1"
      ]
    },
    {
      "abstract": "Decompilation is reconstruction of a program in a high-level language from a program in a low-level language. This paper presents a method for automatic reconstruction of composite types (structures, arrays and combinations of them)in a high-level program during decompilation. Assembly code is obtained by disassembling a binary code or traces collected by a simulator. The proposed method is based on expressing memory access operations as pairs base offset, then building equivalence classes for the bases used in the program and accumulating offsets for each equivalence class. For Strictly conforming C programs our approach is substantiated by the C language semantics as defined in the international standard. However, experimental results have revealed that it is applicable for real-world programs also. Experimental results are obtained for a number of open-source programs as well as for traces collected from them. The method is an essential part of the tool for program decompilation TyDec being developed by the authors. Decompiler TyDec can be used as a standalone tool or as a plug-in for Interactive Trace Explorer TrEx being developed in Institute for System Programming, Russian Academy of Sciences.",
      "authors": [
        "Katerina Troshina",
        "Yegor Derevenets",
        "Alexander Chernov"
      ],
      "categories": null,
      "citations": 16,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2010.24",
      "keywords": [
        "data type reconstruction",
        "reverse engineering",
        "decompilation"
      ],
      "number_of_pages": 10,
      "pages": "179-188",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769541785",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 10th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2010"
      },
      "publication_date": "2010-09-12",
      "selected": null,
      "title": "Reconstruction of Composite Types for Decompilation",
      "urls": [
        "https://dl.acm.org/doi/10.1109/SCAM.2010.24",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5601851",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78649428042&origin=inward"
      ]
    },
    {
      "abstract": "Intermediate representation techniques are positive for resolving generalness of decompilation. Focus on non-generalness of intermediate language, a binary reverse intermediate language BRIL which is independent of machine instructions and contains code dataflow information is proposed. It has high level language characteristics and eliminates the side effects of complex addressing manner and instruction semantics, besides introduces \u03c6-function denotation in SSA. It can reflect behaviors of object code and express semantics of code completely, and can be used in decompilation of object code on different platforms. So it makes it easy to process code transformation, and helps to develop general decompiler greatly.",
      "authors": [
        "Xuying Liu",
        "Wenjian Yin",
        "Qing Yin",
        "Liehui Jiang"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CMCE.2010.5609916",
      "keywords": [
        "SSA",
        "BRIL",
        "Binary Reverse Intermediate Language",
        "Decompilation",
        "Intermediate Language"
      ],
      "number_of_pages": 4,
      "pages": "98-101",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-7955-9",
        "issn": "2159-6034",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2010 International Conference on Computer, Mechatronics, Control and Electronic Engineering, CMCE 2010"
      },
      "publication_date": "2010-08-24",
      "selected": null,
      "title": "A SSA-based intermediate representation technique",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78650015006&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5609916"
      ]
    },
    {
      "abstract": "The authors of this paper recently researched the possibility of developing programming language implementation, that is neither compiler, nor interpreter. The concept is based on keeping the complete program in native machine code, but the specialized editor can 'on the fly' decompile the machine code and display it as high level language. The displayed code can be edited and saved again as pure machine code. This paper reviews the possibility of optimizing generated code, while still retaining the possibility of decompilation. We found many important code sequences which can be replaced with shorter ones while keeping the code in decompilable executable format.",
      "authors": [
        "Samir Ribic",
        "Adnan Salihbegovic"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICSEA.2010.21",
      "keywords": [
        "programming languages",
        "compilation",
        "decompilation"
      ],
      "number_of_pages": 6,
      "pages": "88-93",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769541440",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2010 Fifth International Conference on Software Engineering Advances"
      },
      "publication_date": "2010-08-22",
      "selected": null,
      "title": "Adding Optimization to the Decompilable Code Editor",
      "urls": [
        "https://dl.acm.org/doi/10.1109/ICSEA.2010.21",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78649810409&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5614983"
      ]
    },
    {
      "abstract": "State of the art analyzers in the Logic Programming (LP) paradigm are nowadays mature and sophisticated. They allow inferring a wide variety of global properties including termination, bounds on resource consumption, etc. The aim of this work is to automatically...",
      "authors": [
        "Albert, Elvira",
        "G\u00f3mez-Zamalloa, Miguel",
        "Hubert, Laurent",
        "Puebla, Germ\u00e1n"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": "10.1007/978-3-540-69611-7_8",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "978-3-540-69611-7",
        "issn": "1611-3349",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Programming Languages",
          "Theoretical Computer Science"
        ],
        "title": "The International Symposium on Practical Aspects of Declarative\n  Languages 4354 (2007) 124-139"
      },
      "publication_date": "2010-07-19",
      "selected": null,
      "title": "Verification of Java Bytecode Using Analysis and Transformation of Logic Programs",
      "urls": [
        "http://arxiv.org/abs/1007.3250v1",
        "http://arxiv.org/pdf/1007.3250v1",
        "http://dx.doi.org/10.1007/978-3-540-69611-7_8",
        "https://link.springer.com/content/pdf/10.1007/978-3-540-69611-7_8.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wang Y."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 9,
      "pages": "1933-1941",
      "publication": {
        "category": "Journal",
        "cite_score": 0.6,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "15539105",
        "publisher": "Binary Information Press",
        "sjr": 0.113,
        "snip": 0.186,
        "subject_areas": [
          "Information Systems",
          "Computer Science Applications"
        ],
        "title": "Journal of Computational Information Systems"
      },
      "publication_date": "2010-06-01",
      "selected": null,
      "title": "RICF: Dynamic analysis of integer arithmetic overflow vulnerability via finite state machine",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77957154351&origin=inward"
      ]
    },
    {
      "abstract": "Software piracy, the illegal using, copying, and resale of applications is a major concern for anyone develops software. Software developers also worry about their applications being reverse engineered by extracting data structures and algorithms from an application and incorporated into competitor's code. A defense against software piracy is watermarking, a process that embeds a secret message in a cover software. Watermarking is a method that does not aim to stop piracy copying, but to prove ownership of the software and possibly even the data structures and algorithms used in the software. The language Java was designed to be compiled into a platform independent bytecode format. Much of the information contained in the source code remains in the bytecode, which means that decompilation is easier than with traditional native codes. In this thesis, we present a technique for watermarking Java programs by using a never-executed dummy method (Monden et.al., 2000) combined with opaque predicates (Collberg et.al., 1998; Arboit, 2002) and improved with dynamically opaque predicates (Palsberg et.al., 2000). This work presents a method to construct a dynamic opaque predicates by grouping two or more opaque predicates according to predefined rules. Any software watermarking technique will exhibit a trade-off between resilience, data rate, cost, and stealth. To evaluate the quality of a watermarking scheme we must also know how well it stands up to different types of attacks. Ideally, we would like our watermarks to survive translation (compilation, decompilation, and binary translation), optimization, and obfuscation. Add a single watermark will increasing source code approximate 3.854 bytes with dummy method that cover up to 15 characters, two dynamic data structures, two threads and two opaque predicates. Application loading-time increase approximate 6108 milliseconds.",
      "authors": [
        "Akbar, Zaenal"
      ],
      "categories": null,
      "citations": null,
      "comments": "95 pages, In Indonesia, Master Thesis, Sepuluh November Institute of\n  Technology, Indonesia, February 2004",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2010-04-19",
      "selected": null,
      "title": "Watermarking Java Programs using Dummy Methods with Dynamically Opaque Predicates",
      "urls": [
        "http://arxiv.org/pdf/1004.3250.pdf",
        "http://arxiv.org/pdf/1004.3250v1",
        "http://arxiv.org/abs/1004.3250v1"
      ]
    },
    {
      "abstract": "This paper defines a family of terms of System F which is a decompiler-normalizer for an image of System F by some injective interpretation in System F. We clarify the relationship among these terms, normalization by evaluation, and beta-eta-complete models of F.",
      "authors": [
        "Berardi, Stefano",
        "Tatsuta, Makoto"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-12251-4_16",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "207-223",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "3642122507",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2010-04-19",
      "selected": null,
      "title": "Internal Normalization, Compilation and Decompilation for System ${\\mathcal F}_{\\beta\\eta}$",
      "urls": [
        "https://dl.acm.org/doi/10.1007/978-3-642-12251-4_16",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=78651233359&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-642-12251-4_16.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sourjko S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 2,
      "pages": "41-42",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01921541",
        "publisher": "CMP Media LLC",
        "sjr": 0.104,
        "snip": 0.0,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Business, Management and Accounting (all)"
        ],
        "title": "Electronic Engineering Times"
      },
      "publication_date": "2010-03-08",
      "selected": null,
      "title": "Decompiling the ARM architecture code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77952942210&origin=inward"
      ]
    },
    {
      "abstract": "Legacy System is difficult to be maintained and refactored for lack of necessary documents and source codes. How to generate some valuable information from system runtime behaviors is a big challenge to systems reengineering. In this paper, we attempt to reconstruct class diagram and sequence diagram from the binary bytecode of Java program by reflection and bytecode decompilation. The pattern of Aspect-Oriented Programming is applied to resolve the intricate codes of Interface and Dependency Injection pattern through weaving aspect codes into binary bytecodes during runtime to trace the system behaviors. The experiments show our approach can exactly generate the class diagram and sequence diagram from legacy Java System.",
      "authors": [
        "Liangyu Chen",
        "Jianlin Wang",
        "Ming Xu",
        "Zhenbing Zeng"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ETCS.2010.298",
      "keywords": [
        "Aspect-Oriented Programming",
        "Java Legacy System",
        "component",
        "Reengineering",
        "Runtime Behavior"
      ],
      "number_of_pages": 4,
      "pages": "220-223",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-6388-6",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2nd International Workshop on Education Technology and Computer Science, ETCS 2010"
      },
      "publication_date": "2010-03-06",
      "selected": null,
      "title": "Reengineering of Java Legacy System Based on Aspect-Oriented Programming",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77953062591&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5459990"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Fokin A."
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/CSMR.2010.43",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "240-243",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769543215",
        "issn": "15345351",
        "publisher": "IEEE Computer Society",
        "sjr": 0.358,
        "snip": 1.904,
        "subject_areas": [
          "Software"
        ],
        "title": "Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR"
      },
      "publication_date": "2010-01-01",
      "selected": null,
      "title": "Reconstruction of class hierarchies for decompilation of C++ programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79952646573&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Hou T.W."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1080/02533839.2010.9671615",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "251-262",
      "publication": {
        "category": "Journal",
        "cite_score": 2.3,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "02533839",
        "publisher": "Taylor and Francis Ltd.",
        "sjr": 0.265,
        "snip": 0.522,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Journal of the Chinese Institute of Engineers, Transactions of the Chinese Institute of Engineers,Series A/Chung-kuo Kung Ch'eng Hsuch K'an"
      },
      "publication_date": "2010-01-01",
      "selected": null,
      "title": "Toward robustly protecting data of a dominant path in a java method",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77950849321&origin=inward"
      ]
    },
    {
      "abstract": "The first step of decompilation and other reverse analysis for binary codes is constructing control flow graph of program. Due to the loss of structure in compiled code, extracting a control flow graph from an executable is not simply a matter. The usual way which scans the branch instructions in the disassembly file and creates the CFG can not suitable for multiply architecture and file format. This paper analyzes the structure of assembly program and designs a data information description language based on XML-reverse meta language, which is to describe structured disassembling information and then brings forward the control flow graph reconstruction algorithm. This method abstracts disassembly representations and supports multiple architectures. The testing result shows that this method can reconstruct control flow graph of binaries effectively.",
      "authors": [
        "Wenjian Yin",
        "Liehui Jiang",
        "Qing Yin",
        "Lina Zhou",
        "Jizhong Li"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IFCSTA.2009.176",
      "keywords": [
        "XML",
        "Reverse Meta Language",
        "Control Flow Graph",
        "Decompilation"
      ],
      "number_of_pages": 4,
      "pages": "226-229",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-0-7695-3930-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IFCSTA 2009 Proceedings - 2009 International Forum on Computer Science-Technology and Applications"
      },
      "publication_date": "2009-12-25",
      "selected": null,
      "title": "A Control Flow Graph Reconstruction Method from Binaries Based on XML",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77949797676&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5384599"
      ]
    },
    {
      "abstract": "Library function identification plays a significant part in decompilation process. Based on studying recent achievements on static library functions, combining with the binary coding formats of ARM and Thumb assemble codes, a method for dynamically obtaining library functions' characteristic files on binary level is described, which deals with applications working on ARM processor. Firstly function modules are extracted from applications, then recognized functions in applications will be matched with dynamic signatures of library functions by hashing. This paper makes deep study on obtaining and matching function modules in ARM static library functions identification and presents with strategy on dynamic signature's generating and static matching, which solves the problem of massive library files and matching efficiency. The results prove effective through testing.",
      "authors": [
        "Huang Fei",
        "Yin Qing",
        "Jiang Liehui",
        "Yu Xian"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IFCSTA.2009.234",
      "keywords": [
        "Thumb",
        "ARM",
        "characteristic signature",
        "library function",
        "pattern matching"
      ],
      "number_of_pages": 4,
      "pages": "456-459",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-0-7695-3930-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IFCSTA 2009 Proceedings - 2009 International Forum on Computer Science-Technology and Applications"
      },
      "publication_date": "2009-12-25",
      "selected": null,
      "title": "Technical Study of ARM Library Identification Based on Dynamic Signature",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77949863122&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5384667"
      ]
    },
    {
      "abstract": "Type analysis is an important part of decompilation, which has a great impact on the readability and the veracity of the output of decompilation. In this paper we discussed a method of type analysis which was based on dataflow analysis .We inference the type of data during the calculating of the dataflow equations, by constructing the type of multiplicate kinds data of the hierarchical structure for the type lattice and designing dataflow equations which have type-related information.",
      "authors": [
        "Lina Zhou",
        "Yin Qing",
        "Liehui Jiang",
        "Wenjian Yin",
        "Tieming Liu"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CISE.2009.5362985",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "1-4",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-4507-3",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2009 International Conference on Computational Intelligence and Software Engineering, CiSE 2009"
      },
      "publication_date": "2009-12-11",
      "selected": null,
      "title": "A Method of Type Inference Based on Dataflow Analysis for Decompilation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5362985",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77949738011&origin=inward"
      ]
    },
    {
      "abstract": "A new approach to attack on obfuscated code is proposed using the join-point model and the bytecode instrument mechanism provided by AOP. All operations are implemented on bytecode level without acquiring the source code of target program, which makes obfuscation useless. As for attackers, they can modify the behavior of target code without decompiling and recompiling it. As experiment is shown, this approach to attack on obfuscated code is very straightforward and simple to be implemented.",
      "authors": [
        "Yuan-yuan Li"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CIS.2009.134",
      "keywords": [
        "attack",
        "decompile",
        "join-point",
        "AOP",
        "obfuscation"
      ],
      "number_of_pages": 4,
      "pages": "238-241",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769539317",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2009 International Conference on Computational Intelligence and Security - Volume 02"
      },
      "publication_date": "2009-12-11",
      "selected": null,
      "title": "AOP-Based Attack on Obfuscated Java Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77949289529&origin=inward",
        "https://dl.acm.org/doi/10.1109/CIS.2009.134",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5376044"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhang J."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/FITME.2009.44",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "155-158",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769538808",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "2009 2nd International Conference on Future Information Technology and Management Engineering, FITME 2009"
      },
      "publication_date": "2009-12-01",
      "selected": null,
      "title": "A high-level control structure recovery method based on propositional calculus",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77950880386&origin=inward"
      ]
    },
    {
      "abstract": "Recognizing cryptographic algorithm from the binary codes plays an important role in checking the malicious codes and protecting the security of computer systems. This paper firstly introduces the current situation about the algorithm recognition and...",
      "authors": [
        "Liu, Tie-Ming",
        "Jiang, Lie-hui",
        "He, Hong-qi",
        "Li, Ji-zhong",
        "Yu, Xian"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-10847-1_18",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "140-147",
      "publication": {
        "category": "Book",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": "9789811399411",
        "issn": "18650929",
        "publisher": "Springer Science and Business Media Deutschland GmbH",
        "sjr": 0.194,
        "snip": 0.241,
        "subject_areas": [
          "Computer Science (all)",
          "Mathematics (all)"
        ],
        "title": "International Conference of Pioneering Computer Scientists, Engineers and Educators"
      },
      "publication_date": "2009-12-01",
      "selected": null,
      "title": "Researching on Cryptographic Algorithm Recognition Based on Static Characteristic-Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=73349137282&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-642-10847-1_18.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Kumar N."
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1509239.1509266",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "197-206",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781605584423",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 8th ACM International Conference on Aspect-Oriented Software Development, AOSD'09"
      },
      "publication_date": "2009-11-30",
      "selected": null,
      "title": "Enabling the adoption of aspects - Testing aspects: A risk model, fault model and patterns",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70450253591&origin=inward"
      ]
    },
    {
      "abstract": "In recent years, there has been a growing need for analyst to explore inside the binary executables for the reasons of decompilation, security analysis, reverse engineering, etc. It is very helpful to recovery the high-level control structure information, such as loops and conditionals, from arbitrary control-flow of low-level code. This paper presents a novel approach to structure control-flow graphs in binary executables, which are normally represented by unconditional or conditional jumps. We firstly formalize control flow information of the instructions into expressions of propositional calculus. Then the control flow information can be propagated along the execution path. At last, high-level control structures are identified and recovered through the result of calculation. We have implemented our method in RADUX, a statical malicious code detector based on semantic analysis. Our experimental result shows that this method can recognize and recovery loops and conditionals effectively, and have the ability of analyzing the predicated instructions.",
      "authors": [
        "Jingbo Zhang",
        "Rongcai Zhao",
        "Jianmin Pang",
        "Wen Fu"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IITA.2009.474",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "592-595",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-0-7695-3859-4",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "3rd International Symposium on Intelligent Information Technology Application, IITA 2009"
      },
      "publication_date": "2009-11-21",
      "selected": null,
      "title": "Decompiling High-level Control Structures with Propositions",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5370155",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77649283268&origin=inward"
      ]
    },
    {
      "abstract": "Reasoning about Java bytecode (JBC) is complicated due to its unstructured control-flow, the use of three-address code combined with the use of an operand stack, etc. Therefore, many static analyzers and model checkers for JBC first convert the code into a higher-level representation. In contrast to traditional decompilation, such representation is often not Java source, but rather some intermediate language which is a good input for the subsequent phases of the tool. Interpretive decompilation consists in partially evaluating an interpreter for the compiled language (in this case JBC) written in a high-level language with respect to the code to be decompiled. There have been proofs-of-concept that interpretive decompilation is feasible, but there remain important open issues when it comes to decompile a real language such as JBC. This paper presents, to the best of our knowledge, the first modular scheme to enable interpretive decompilation of a realistic programming language to a high-level representation, namely of JBC to Prolog. We introduce two notions of optimality which together require that decompilation does not generate code more than once for each program point. We demonstrate the impact of our modular approach and optimality issues on a series of realistic benchmarks. Decompilation times and decompiled program sizes are linear with the size of the input bytecode program. This demonstrates empirically the scalability of modular decompilation of JBC by partial evaluation.",
      "authors": [
        "Miguel G\u00f3mez-Zamalloa",
        "Elvira Albert",
        "Germ\u00e1n Puebla"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1016/j.infsof.2009.04.010",
      "keywords": [
        "Java bytecode",
        "Program transformation",
        "Logic programming",
        "Partial evaluation",
        "Decompilation",
        "Interpreters"
      ],
      "number_of_pages": 19,
      "pages": "1409-1427",
      "publication": {
        "category": "Journal",
        "cite_score": 9.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0950-5849",
        "publisher": "Elsevier B.V.",
        "sjr": 1.182,
        "snip": 2.209,
        "subject_areas": [
          "Information Systems",
          "Computer Science Applications",
          "Software"
        ],
        "title": "Information and Software Technology"
      },
      "publication_date": "2009-10-01",
      "selected": null,
      "title": "Decompilation of Java bytecode to Prolog by partial evaluation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=67650146078&origin=inward",
        "https://dl.acm.org/doi/10.1016/j.infsof.2009.04.010"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sivadasan P."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1517303.1517318",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781605584768",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2nd Bangalore Annual Compute Conference, COMPUTE'09"
      },
      "publication_date": "2009-09-21",
      "selected": null,
      "title": "JDATATRANS for array obfuscation in Java source codes to defeat reverse engineering from decompiled codes",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70349126599&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation of Java bytecode is the act of transforming Java bytecode to Java source code. Although easier than that of decompilation of machine code, problems still arise in Java bytecode decompilation. These include type inference of local variables and exception-handling. Since the last such evaluation (2003) several new commercial, free and open-source Java decompilers have appeared and some of the older ones have been updated. In this paper, we evaluate the currently available Java bytecode decompilers using an extension of the criteria that were used in the original study. Although there has been a slight improvement since this study, it was found that none passed all the tests, each of which were designed to target different problem areas. We give reasons for this lack of success and suggest methods by which future Java bytecode decompilers could be improved.",
      "authors": [
        "James Hamilton",
        "Sebastian Danicic"
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2009.24",
      "keywords": [
        "bytecode",
        "decompilation",
        "java"
      ],
      "number_of_pages": 8,
      "pages": "129-136",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769537931",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation"
      },
      "publication_date": "2009-09-20",
      "selected": null,
      "title": "An Evaluation of Current Java Bytecode Decompilers",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5279917",
        "https://dl.acm.org/doi/10.1109/SCAM.2009.24",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=72349098968&origin=inward"
      ]
    },
    {
      "abstract": "Based on the technique of code obfuscation in software protection, a new obfuscation scheme in constructing opaque predicates was proposed, which increased the complexity by employing the pseudo-random sequence and a group of Diophantine equations\u2019 solutions to construct a family of parameterized opaque predicates. To protect the output of the opaque predicates, the data chain list was dynamically generated. Pseudo-random sequence was also used to disturb the attackers\u2019 tracking debug. The complication of decompile was increased through block cryptosystems that convert the output of the opaque predicates into the corresponding judge conditions.",
      "authors": [
        "Ding Yi"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCSE.2009.402",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "379-382",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769535708",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2009 WRI World Congress on Software Engineering - Volume 04"
      },
      "publication_date": "2009-05-19",
      "selected": null,
      "title": "A New Obfuscation Scheme in Constructing Fuzzy Predicates",
      "urls": [
        "https://dl.acm.org/doi/10.1109/WCSE.2009.402",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5319576",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=72849110895&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation is reconstruction of a program in a high-level language from a program in a low-level language. In most cases static decompilation is unable to completely reconstruct high-level data types due to loss of typing information during compilation. We present several profile-based techniques that help to recover high-level types. The techniques include pointer/integer determination by value profiling and composite type identification by heap profiling.",
      "authors": [
        "K. Troshina",
        "A. Chernov",
        "A. Fokin"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICPC.2009.5090054",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "263-267",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-2601-2",
        "issn": "1092-8138",
        "publisher": "IEEE Computer Society",
        "sjr": 0.39,
        "snip": 0.978,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "15th IEEE International Conference on Program Comprehension (ICPC '07)"
      },
      "publication_date": "2009-05-17",
      "selected": null,
      "title": "Profile-based type reconstruction for decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70349989053&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5090054"
      ]
    },
    {
      "abstract": "SVG (Scalable Vector Graphics) is a kind of vector image which based on XML. It has many advantages such as high quality of image, flexibility of file format, less occupation of resource and supporting dynamic interaction. SVG is compatible with XML, HTML4, XHTML languages and it accords with the criterions including CSS, XSL and DOM. In this paper we first use decompile technology to analyze suspicious code and detect suspicious behavior. The adopt SVG for annotating suspicious behavior, finally the result is presented in graphical format. The relevant experiment shows that our method is easy to be understand and effective.",
      "authors": [
        "Wang Qiang",
        "Pang Jianmin",
        "Fu Wen",
        "Yue Feng"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/IFITA.2009.191",
      "keywords": [
        "XML",
        "SVG",
        "suspicious behaviors",
        "graphical annotation"
      ],
      "number_of_pages": 3,
      "pages": "504-506",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769536002",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2009 International Forum on Information Technology and Applications - Volume 03"
      },
      "publication_date": "2009-05-15",
      "selected": null,
      "title": "Graphical Annotation of Suspicious Behaviors",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70350537590&origin=inward",
        "https://dl.acm.org/doi/10.1109/IFITA.2009.191",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5232171"
      ]
    },
    {
      "abstract": " Software obfuscation or obscuring a software is an approach to defeat the practice of reverse engineering a software for using its functionality illegally in the development of another software. Java applications are more amenable to reverse engineering and re-engineering attacks through methods such as decompilation because Java class files store the program in a semi complied form called byte codes. The existing obfuscation systems obfuscate the Java class files. Obfuscated source code produce obfuscated byte codes and hence two level obfuscation (source code and byte code level) of the program makes it more resilient to reverse engineering attacks . But source code obfuscation is much more difficult due to richer set of programming constructs and the scope of the different variables used in the program and only very little progress has been made on this front. We in this paper are proposing a framework named JConstHide for hiding constants, especially integers in the java source codes, to defeat reverse engineering through decompilation. To the best of our knowledge, no data hiding software are available for java source code constant hiding.",
      "authors": [
        "Sivadasan, Praveen",
        "Lal, P Sojan"
      ],
      "categories": null,
      "citations": null,
      "comments": null,
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2009-04-22",
      "selected": null,
      "title": "JConstHide: A Framework for Java Source Code Constant Hiding",
      "urls": [
        "http://arxiv.org/pdf/0904.3458v1",
        "http://arxiv.org/abs/0904.3458v1",
        "http://arxiv.org/pdf/0904.3458.pdf"
      ]
    },
    {
      "abstract": "We employ existing partial evaluation (PE) techniques developed for Constraint Logic Programming (CLP) in order to automatically generate test-case generators for glass-box testing of bytecode. Our approach consists of two independent CLP PE phases. (1) First, the...",
      "authors": [
        "Albert, Elvira",
        "G\u00f3mez-Zamalloa, Miguel",
        "Puebla, Germ\u00e1n"
      ],
      "categories": null,
      "citations": 10,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-642-00515-2_2",
      "keywords": [],
      "number_of_pages": 20,
      "pages": "4-23",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2009-04-06",
      "selected": null,
      "title": "Test Data Generation of Bytecode by CLP Partial Evaluation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=63449113617&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-642-00515-2_2.pdf"
      ]
    },
    {
      "abstract": " In recent work, we have proposed an approach to Test Data Generation (TDG) of imperative bytecode by partial evaluation (PE) of CLP which consists in two phases: (1) the bytecode program is first transformed into an equivalent CLP program by means of interpretive compilation by PE, (2) a second PE is performed in order to supervise the generation of test-cases by execution of the CLP decompiled program. The main advantages of TDG by PE include flexibility to handle new coverage criteria, the possibility to obtain test-case generators and its simplicity to be implemented. The approach in principle can be directly applied for TDG of any imperative language. However, when one tries to apply it to a declarative language like Prolog, we have found as a main difficulty the generation of test-cases which cover the more complex control flow of Prolog. Essentially, the problem is that an intrinsic feature of PE is that it only computes non-failing derivations while in TDG for Prolog it is essential to generate test-cases associated to failing computations. Basically, we propose to transform the original Prolog program into an equivalent Prolog program with explicit failure by partially evaluating a Prolog interpreter which captures failing derivations w.r.t. the input program. Another issue that we discuss in the paper is that, while in the case of bytecode the underlying constraint domain only manipulates integers, in Prolog it should properly handle the symbolic data manipulated by the program. The resulting scheme is of interest for bringing the advantages which are inherent in TDG by PE to the field of logic programming.",
      "authors": [
        "Gomez-Zamalloa, Miguel",
        "Albert, Elvira",
        "Puebla, German"
      ],
      "categories": null,
      "citations": null,
      "comments": "Paper presented at the 18th Workshop on Logic-based Methods in\n  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted\n  by a co-editor of the Workshop proceedings",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2009-03-12",
      "selected": null,
      "title": "On the Generation of Test Data for Prolog by Partial Evaluation",
      "urls": [
        "http://arxiv.org/abs/0903.2199v1",
        "http://arxiv.org/pdf/0903.2199v1",
        "http://arxiv.org/pdf/0903.2199.pdf"
      ]
    },
    {
      "abstract": "An algorithm for the automatic reconstruction of data types from the assembler code produced by a C compiler is described. The types of the variables that are placed on the stack and in the static memory are reconstructed using an iterative algorithm that uses a lattice over the properties of the data types. The derived data types are reconstructed by constructing the set of possible offsets of the elements of these types (fields in the case of structures and array elements in the case of arrays). This algorithm is used in the tool for decompiling assembler codes into C that is currently developed by the authors.",
      "authors": [
        "Dolgova, E. N.",
        "Chernov, A. V."
      ],
      "categories": null,
      "citations": 15,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1134/S0361768809020066",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "105-119",
      "publication": {
        "category": "Journal",
        "cite_score": 1.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0361-7688",
        "publisher": "Pleiades Publishing",
        "sjr": 0.232,
        "snip": 0.474,
        "subject_areas": [
          "Software"
        ],
        "title": "Programming and Computer Software"
      },
      "publication_date": "2009-03-01",
      "selected": null,
      "title": "Automatic reconstruction of data types in the decompilation problem",
      "urls": [
        "https://link.springer.com/content/pdf/10.1134/S0361768809020066.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=63849101995&origin=inward",
        "https://dl.acm.org/doi/10.1134/S0361768809020066"
      ]
    },
    {
      "abstract": "Computer viruses have become the main threat of the safety and security of industry. Unfortunately, no mature products of anti-virus can protect computers effectively. This paper presents an approach of virus detection which is based on analysis and distilling of representative behavior characteristic and systemic description of the suspicious behaviors indicated by the sequences of APIs which called under Windows. Based on decompilation analysis, according to the determinant of Bayes Algorithm, and by the validation of abundant sample space, the technique implements the virus detection by suspicious behavior identification.",
      "authors": [
        "Cheng Wang",
        "Jianmin Pang",
        "Rongcai Zhao",
        "Xiaoxian Liu"
      ],
      "categories": null,
      "citations": 26,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICCSN.2009.60",
      "keywords": [
        "Suspicious Behavior",
        "API Sequence",
        "Bayes Algorithm"
      ],
      "number_of_pages": 5,
      "pages": "544-548",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769535227",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2009 International Conference on Communication Software and Networks, ICCSN 2009"
      },
      "publication_date": "2009-02-27",
      "selected": null,
      "title": "Using API Sequence and Bayes Algorithm to Detect Suspicious Behavior",
      "urls": [
        "https://dl.acm.org/doi/10.1109/ICCSN.2009.60",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70349518917&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5076911"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Hartgerink M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 5,
      "pages": "2922-2926",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781615672363",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "71st European Association of Geoscientists and Engineers Conference and Exhibition 2009: Balancing Global Resources. Incorporating SPE EUROPEC 2009"
      },
      "publication_date": "2009-01-01",
      "selected": null,
      "title": "Protection of intellectual property",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77049114544&origin=inward"
      ]
    },
    {
      "abstract": "High level synthesis (HLS) is the field of transforming a high level programming language, such as C, into a register transfer level(RTL) description of the design. In HLS, binary synthesis is a method for synthesizing existing compiled applications for which the source code is not available. One of the advantages of FPGAs over software is the availability of multiple memory banks. Until now, binary synthesis systems have not made use of the multiple memory banks on FPGAs. In our work, we decompile the binary executable into an intermediate representation, and we target architectures with multiple memory banks and multiple memory ports. We present methods for detecting memory regions and synthesis of the decompiled code. The proposed methods accelerate the execution time of applications which use multiple memory regions concurrently.",
      "authors": [
        "Yosi Ben Asher",
        "Nadav Rotem"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/FPL.2009.5272381",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "600-603",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-3892-1",
        "issn": "1946-1488",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "FPL 09: 19th International Conference on Field Programmable Logic and Applications"
      },
      "publication_date": "2009-01-01",
      "selected": null,
      "title": "Binary Synthesis with multiple memory banks targeting array references",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70450043206&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5272381"
      ]
    },
    {
      "abstract": "This article had a formalizing description to the structure of logic compound sentences (LCS) in the course of decompilation. It applied the Logic diagram to the recognition of LCS which belongs to graph theory. The recognition arithmetic overcame the shortcomings of some typical current approaches. Furthermore, this article introduced logical correlation matrices in the solution to the Logic diagrams, and a dynamic pruning policy was executed in this course by which the novel arithmetic was greatly predigested. In the end of the article, it offered a specific instance and had the complexity analyses, which proved the validity and sophistication of the new arithmetic separately.",
      "authors": [
        "Zhang Longjie",
        "Xie Xiaofang",
        "Yuan Shengzhi",
        "Tang Jiang"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ISCSCT.2008.130",
      "keywords": [
        "logic diagram",
        "software reuse",
        "software reverse engineering",
        "decompilation",
        "logical correlation matrices",
        "logic compound condition sentences"
      ],
      "number_of_pages": 5,
      "pages": "442-446",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-3746-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - International Symposium on Computer Science and Computational Technology, ISCSCT 2008"
      },
      "publication_date": "2008-12-20",
      "selected": null,
      "title": "Research on the Composite Arithmetic of Logic Compound Sentences in Decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=62349105371&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4731463"
      ]
    },
    {
      "abstract": "Semantics-based malware detection is a considerable technique to find out the semantically equivalent malicious codes with different layout. This paper presents an abstraction of instructions from lower-level program form to an intermediate representation which describes the program semantics. This abstraction is depended on decompilation technology. We detect malicious code based on patterns, which are obtained by previous experience of malware analysis, and build on top of the abstraction above. At last, we evaluate our method informally, and the result shows that our method is more resilient to detect obfuscated malicious code transformed by several obfuscation policies.",
      "authors": [
        "Jingbo Zhang",
        "Rongcai Zhao",
        "Jianmin Pang",
        "Wen Fu"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CSSE.2008.990",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "350-353",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769533360",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2008 International Conference on Computer Science and Software Engineering - Volume 02"
      },
      "publication_date": "2008-12-12",
      "selected": null,
      "title": "Formal Abstraction of Semantics for Detecting Malicious Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79951544788&origin=inward",
        "https://dl.acm.org/doi/10.1109/CSSE.2008.990",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4722068"
      ]
    },
    {
      "abstract": "In recent years, there has been a growing need for analyst to explore inside the binary executables for the reasons of decompilation, security analysis, reverse engineering, etc. It is very helpful to recover the high-level control structure information, such as loops and conditionals, from arbitrary control-flow of low-level code.This paper presents a novel approach to structure control-flow graphs in binary executables, which are normally represented by unconditional or conditional jumps. We firstly formalize control flow information of the instructions into expressions of propositional calculus. Then the control flow information can be propagated along the execution path. At last, high-level control structures are identified and recovered through the result of calculation.",
      "authors": [
        "Jingbo Zhang",
        "Wen Fu",
        "Jianmin Pang",
        "Rongcai Zhao"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CSSE.2008.991",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "338-341",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-0-7695-3336-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2008 International Conference on Computer Science and Software Engineering - Volume 02"
      },
      "publication_date": "2008-12-12",
      "selected": null,
      "title": "Using Propositional Calculas to Accurately Structure Control-Flow from Binary Executables",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4722065",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=79951543314&origin=inward"
      ]
    },
    {
      "abstract": "Developers turn ideas, designs and patterns into source code, then compile the source code into executables. Decompiling turns executables back into source code, and deprogramming turns code back into designs and patterns. In this paper we introduce DeP, a tool for deprogramming software systems. DeP abstracts code into a dependency graph and mines this graph for patterns. It also gives programmers visual means for manipulating the program. We describe DeP's use in several software engineering tasks: design pattern identification, source code refactoring, copy-paste detection, automated code documentation, and programmer fingerprint recognition.",
      "authors": [
        "Yohann Coppel",
        "George Candea"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1855556.1855559",
      "keywords": [],
      "number_of_pages": 1,
      "pages": "3",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "USENIX Association",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the Fourth conference on Hot topics in system dependability"
      },
      "publication_date": "2008-12-07",
      "selected": null,
      "title": "Deprogramming large software systems",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1855556.1855559"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Vahid F."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/B978-012370522-8.50034-0",
      "keywords": [],
      "number_of_pages": 22,
      "pages": "539-560",
      "publication": {
        "category": "Book",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780123705228",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Reconfigurable Computing"
      },
      "publication_date": "2008-12-01",
      "selected": null,
      "title": "Hardware/Software Partitioning",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=70350578986&origin=inward"
      ]
    },
    {
      "abstract": "Realistic formal specifications of machine languages for commercial processors consist of thousands of lines of definitions. Current methods support trustworthy proofs of the correctness of programs for one such specification. However, these methods provide little or no support for reusing proofs of the same algorithm implemented in different machine languages. We describe an approach, based on proof-producing decompilation, which both makes machine-code verification tractable and supports proof reuse between different languages. We briefly present examples based on detailed models of machine code for ARM, PowerPC and x86. The theories and tools have been implemented in the HOL4 system.",
      "authors": [
        "Magnus O. Myreen",
        "Michael J. C. Gordon",
        "Konrad Slind"
      ],
      "categories": null,
      "citations": 50,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/FMCAD.2008.ECP.24",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "1-8",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4244-2736-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2008 International Conference on Formal Methods in Computer-Aided Design, FMCAD"
      },
      "publication_date": "2008-11-17",
      "selected": null,
      "title": "Machine-Code Verification for Multiple Architectures - An Application of Decompilation into Logic",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4689183",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=58049135249&origin=inward"
      ]
    },
    {
      "abstract": "Realistic formal specifications of machine languages for commercial processors consist of thousands of lines of definitions. Current methods support trustworthy proofs of the correctness of programs for one such specification. However, these methods provide little or no support for reusing proofs of the same algorithm implemented in different machine languages. We describe an approach, based on proof-producing decompilation, which both makes machine-code verification tractable and supports proof reuse between different languages. We briefly present examples based on detailed models of machine code for ARM, PowerPC and x86. The theories and tools have been implemented in the HOL4 system.",
      "authors": [
        "Magnus O. Myreen",
        "Michael J. C. Gordon",
        "Konrad Slind"
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1517424.1517444",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "1-8",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781424427352",
        "issn": null,
        "publisher": "IEEE Press",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2008 International Conference on Formal Methods in Computer-Aided Design, FMCAD"
      },
      "publication_date": "2008-11-17",
      "selected": null,
      "title": "Machine-code verification for multiple architectures: an application of decompilation into logic",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1517424.1517444"
      ]
    },
    {
      "abstract": "We also discuss in detail how we handle primitive types, which is a difficult issue due to the discrepancy in their treatment between Java bytecode and Java source. For the application to decompilation, however, it is very important to handle this correctly.",
      "authors": [
        "Ben Bellamy",
        "Pavel Avgustinov",
        "Oege de Moor",
        "Damien Sereni"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/1449764.1449802",
      "keywords": [
        "type inference",
        "program analysis"
      ],
      "number_of_pages": 18,
      "pages": "475-492",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781605582153",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications"
      },
      "publication_date": "2008-10-19",
      "selected": null,
      "title": "Efficient local type inference",
      "urls": [
        "https://dl.acm.org/doi/10.1145/1449764.1449802",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=63549141229&origin=inward"
      ]
    },
    {
      "abstract": "This paper presents an algorithm for automatic type reconstruction from target assembly code compiled by a C compiler. The primitive language types are recovered by an iterative algorithm, which operates over the lattice of primitive types' properties. Layout of composite types is reconstructed by building set of accessible offsets for each composite type. The algorithm is the essential part of a tool for program decompilation being developed by the authors.",
      "authors": [
        "K. Dolgova",
        "A. Chernov"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2008.20",
      "keywords": [
        "reverse engineering",
        "decompilation",
        "type reconstruction"
      ],
      "number_of_pages": 5,
      "pages": "202-206",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769534299",
        "issn": "2375-5369",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2008 15th Working Conference on Reverse Engineering"
      },
      "publication_date": "2008-10-15",
      "selected": null,
      "title": "Automatic Type Reconstruction in Disassembled C Programs",
      "urls": [
        "https://dl.acm.org/doi/10.1109/WCRE.2008.20",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4656411",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=57749185672&origin=inward"
      ]
    },
    {
      "abstract": "Decompiling low-level code to a high-level intermediate representation facilitates the development of analyzers, model checkers, etc. which reason about properties of the low-level code (e.g., bytecode, .NET). Interpretive decompilation consists in partially evaluating an interpreter for the low-level language (written in the high-level language) w.r.t. the code to be decompiled. There have been proofs-of-concept that interpretive decompilation is feasible, butt here remain important open issues when it comes to decompile a real language: does the approach scale up? is the quality of decompiled programs comparable to that obtained by ad-hoc decompilers? do decompiled programs preserve the structure of the original programs?\u00a0\u00a0This paper addresses these issues by presenting, to the best of our knowledge, the first modular scheme to enable interpretive decompilation of low-level code to a high-level representation, namely, we decompile bytecode into Prolog. We introduce two notions of optimality. The first one requires that each method/block is decompiled just once. The second one requires that each program point is traversed at most once during decompilation. We demonstrate the impact of our modular approach and optimality issues on a series of realistic benchmarks.\u00a0\u00a0Decompilation times and decompiled program sizes are linear with the size of the input bytecode program. This demostrates empirically the scalability of modular decompilation of low-level code by partial evaluation.",
      "authors": [
        "Miguel G\u00f3mez-Zamalloa",
        "Elvira Albert",
        "Germ\u00e1n Puebla"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2008.35",
      "keywords": [
        "partial evaluation",
        "bytecode",
        "decompilation"
      ],
      "number_of_pages": 10,
      "pages": "239-248",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-0-7695-3353-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 8th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2008"
      },
      "publication_date": "2008-09-28",
      "selected": null,
      "title": "Modular Decompilation of Low-Level Code by Partial Evaluation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4637556",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=56349108986&origin=inward"
      ]
    },
    {
      "abstract": " Software obfuscation or obscuring a software is an approach to defeat the practice of reverse engineering a software for using its functionality illegally in the development of another software. Java applications are more amenable to reverse engineering and re-engineering attacks through methods such as decompilation because Java class files store the program in a semi complied form called 'byte' codes. The existing obfuscation systems obfuscate the Java class files. Obfuscated source code produce obfuscated byte codes and hence two level obfuscation (source code and byte code level) of the program makes it more resilient to reverse engineering attacks. But source code obfuscation is much more difficult due to richer set of programming constructs and the scope of the different variables used in the program and only very little progress has been made on this front. Hence programmers resort to adhoc manual ways of obscuring their program which makes it difficult for its maintenance and usability. To address this issue partially, we developed a user friendly tool JDATATRANS to obfuscate Java source code by obscuring the array usages. Using various array restructuring techniques such as 'array splitting', 'array folding' and 'array flattening', in addition to constant hiding, our system obfuscate the input Java source code and produce an obfuscated Java source code that is functionally equivalent to the input program. We also perform a number of experiments to measure the potency, resilience and cost incurred by our tool.",
      "authors": [
        "Sivadasan, Praveen",
        "Lal, P Sojan",
        "Sivadasan, Naveen"
      ],
      "categories": null,
      "citations": null,
      "comments": "Manuscript submitted to ACM COMPUTE 2009 Conference,Bangalore",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": null,
      "publication_date": "2008-09-20",
      "selected": null,
      "title": "JDATATRANS for Array Obfuscation in Java Source Code to Defeat Reverse Engineering from Decompiled Codes",
      "urls": [
        "http://arxiv.org/pdf/0809.3503v1",
        "http://arxiv.org/pdf/0809.3503.pdf",
        "http://arxiv.org/abs/0809.3503v1"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Miao W."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ICIS.2008.16",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "539-544",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9780769531311",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 7th IEEE/ACIS International Conference on Computer and Information Science, IEEE/ACIS ICIS 2008, In conjunction with 2nd IEEE/ACIS Int. Workshop on e-Activity, IEEE/ACIS IWEA 2008"
      },
      "publication_date": "2008-09-15",
      "selected": null,
      "title": "Reconstructing control flow in modulo scheduled loops",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=51349093887&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "M\u00e4yr\u00e4 H."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/ITNG.2008.73",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "432-437",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769530990",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - International Conference on Information Technology: New Generations, ITNG 2008"
      },
      "publication_date": "2008-05-27",
      "selected": null,
      "title": "Reverse engineering functional classes: A middleware case study",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=44049095311&origin=inward"
      ]
    },
    {
      "abstract": "This poster presents an in-depth analysis of the Xilinx bitstream file format. This theoretical analysis is backed by a simple and efficient implementation of a reverse-engineering tool for Xilinx bitstreams. The development process followed these lines. First, publicly available documentation from Xilinx has been analyzed; then some custom assumptions about the bitstream format have been made. This information allowed a suitable algorithm to be run on well-chosen bitstreams. The output from this automated analysis step is a database which relates raw bitstream data to low-level netlist elements. This database is subsequently used as input to an efficient bitstream compiler which can either generate a bitstream from a low-level (XDL) description of the netlist, or conversely decompile any given bitstream to its low-level netlist elements. This work has been validated for the spartan3, virtex2, virtex4 and virtex5 FPGA lines from Xilinx. Decompiling a bitstream is very fast; it is two orders of magnitude faster than the reverse operation of compilation with Xilinx' bitgen. This work aims to raise awareness about security issues for users of FPGAs. It also makes custom compilation and low-level tinkering with bitstreams - \u00e0 la JBits - possible",
      "authors": [
        "Jean-Baptiste Note",
        "\u00c9ric Rannaud"
      ],
      "categories": null,
      "citations": 109,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.1145/1344671.1344729",
      "keywords": [
        "bitstream format",
        "reverse-engineering",
        "FPGA"
      ],
      "number_of_pages": 1,
      "pages": "264",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781595939340",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 16th international ACM/SIGDA symposium on Field programmable gate arrays"
      },
      "publication_date": "2008-02-24",
      "selected": null,
      "title": "From the bitstream to the netlist",
      "urls": [
        "https://dl.acm.org/doi/10.1145/1344671.1344729"
      ]
    },
    {
      "abstract": " We have developed the Model Master (MM) language for describing spreadsheets, and tools for converting MM programs to and from spreadsheets. The MM decompiler translates a spreadsheet into an MM program which gives a concise summary of its calculations, layout, and styling. This is valuable when trying to understand spreadsheets one has not seen before, and when checking for errors. The MM compiler goes the other way, translating an MM program into a spreadsheet. This makes possible a new style of development, in which spreadsheets are generated from textual specifications. This can reduce error rates compared to working directly with the raw spreadsheet, and gives important facilities for code reuse. MM programs also offer advantages over Excel files for the interchange of spreadsheets.",
      "authors": [
        "Paine, Jocelyn"
      ],
      "categories": null,
      "citations": null,
      "comments": "15 pages; substantive references; code examples",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Human-Computer Interaction",
          "Programming Languages"
        ],
        "title": "Proc. European Spreadsheet Risks Int. Grp. 2001 17-38 ISBN:1 86166\n  179 7"
      },
      "publication_date": "2008-01-24",
      "selected": null,
      "title": "Ensuring Spreadsheet Integrity with Model Master",
      "urls": [
        "http://arxiv.org/abs/0801.3690v1",
        "http://arxiv.org/pdf/0801.3690v1",
        "http://arxiv.org/pdf/0801.3690.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Bellamy B."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1449955.1449802",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "475-491",
      "publication": {
        "category": "Journal",
        "cite_score": 4.9,
        "is_potentially_predatory": false,
        "isbn": "9781450335492",
        "issn": "15232867",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.962,
        "snip": 1.749,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Conference Record of the Annual ACM Symposium on Principles of Programming Languages"
      },
      "publication_date": "2008-01-01",
      "selected": null,
      "title": "Efficient local type Inference",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=67650085027&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wei T."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 7,
      "pages": "37-43",
      "publication": {
        "category": "Journal",
        "cite_score": 1.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "04798023",
        "publisher": "Peking University",
        "sjr": 0.171,
        "snip": 0.312,
        "subject_areas": [
          "Multidisciplinary"
        ],
        "title": "Beijing Daxue Xuebao (Ziran Kexue Ban)/Acta Scientiarum Naturalium Universitatis Pekinensis"
      },
      "publication_date": "2008-01-01",
      "selected": null,
      "title": "Novel compound conditions recognition algorithm in decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=39749099901&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Coppel Y."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 4th Workshop on Hot Topics in System Dependability, HotDep 2008"
      },
      "publication_date": "2008-01-01",
      "selected": null,
      "title": "Deprogramming large software systems",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85044260711&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Tao W."
      ],
      "categories": null,
      "citations": 17,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 14,
      "pages": "170-183",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2007-12-01",
      "selected": null,
      "title": "A new algorithm for identifying loops in decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=38149044194&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Albert E."
      ],
      "categories": null,
      "citations": 41,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-540-69611-7-8",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "124-139",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2007-12-01",
      "selected": null,
      "title": "Verification of java bytecode using analysis and transformation of logic programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=59249106512&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Jacob M."
      ],
      "categories": null,
      "citations": 33,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1288869.1288887",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "129-140",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781595938572",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "MM and Sec'07 - Proceedings of the Multimedia and Security Workshop 2007"
      },
      "publication_date": "2007-12-01",
      "selected": null,
      "title": "Towards integral binary execution: Implementing oblivious hashing using overlapped instruction encodings",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=38849121919&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mittal G."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/TVLSI.2007.904095",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "1177-1190",
      "publication": {
        "category": "Journal",
        "cite_score": 6.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10638210",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.94,
        "snip": 1.663,
        "subject_areas": [
          "Hardware and Architecture",
          "Electrical and Electronic Engineering",
          "Software"
        ],
        "title": "IEEE Transactions on Very Large Scale Integration (VLSI) Systems"
      },
      "publication_date": "2007-11-01",
      "selected": null,
      "title": "An overview of a compiler for mapping software binaries to hardware",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=35448934818&origin=inward"
      ]
    },
    {
      "abstract": " In this paper, we present a software compilation approach for microprocessor/FPGA platforms that partitions a software binary onto custom hardware implemented in the FPGA. Our approach imposes less restrictions on software tool flow than previous compiler approaches, allowing software designers to use any software language and compiler. Our approach uses a back-end partitioning tool that utilizes decompilation techniques to recover important high-level information, resulting in performance comparable to high-level compiler-based approaches.",
      "authors": [
        "Stitt, Greg",
        "Vahid, Frank"
      ],
      "categories": null,
      "citations": null,
      "comments": "Submitted on behalf of EDAA (http://www.edaa.com/)",
      "databases": [
        "arXiv"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [
          "Software Engineering"
        ],
        "title": "Dans Design, Automation and Test in Europe - DATE'05, Munich :\n  Allemagne (2005)"
      },
      "publication_date": "2007-10-25",
      "selected": null,
      "title": "A Decompilation Approach to Partitioning Software for Microprocessor/FPGA Platforms",
      "urls": [
        "http://arxiv.org/abs/0710.4700v1",
        "http://arxiv.org/pdf/0710.4700v1",
        "http://arxiv.org/pdf/0710.4700.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ohori A."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1286821.1286827",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 3.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01640925",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.749,
        "snip": 0.936,
        "subject_areas": [
          "Software"
        ],
        "title": "ACM Transactions on Programming Languages and Systems (TOPLAS)"
      },
      "publication_date": "2007-10-01",
      "selected": null,
      "title": "A proof theory for machine code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=36048966264&origin=inward"
      ]
    },
    {
      "abstract": "We present a formal treatment of normalization by evaluation in type theory. The involved semantics of simply-typed \u03bb-calculus is exactly the simply typed fragment of the type theory. This means we have constructed and proved correct a decompilation function which recovers the syntax of a program, provided it belongs to the simply typed fragment. The development runs and is checked in Coq. Possible applications include the formal treatment of languages with binders.",
      "authors": [
        "Fran\u00e7ois Garillot",
        "Benjamin Werner"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1792233.1792260",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "368-382",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "3540745904",
        "issn": null,
        "publisher": "Springer-Verlag",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 20th international conference on Theorem proving in higher order logics"
      },
      "publication_date": "2007-09-10",
      "selected": null,
      "title": "Simple types in type theory: deep and shallow encodings",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1792233.1792260"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zhao C."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1229384.1229389",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "23-27",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "ACM International Conference Proceeding Series"
      },
      "publication_date": "2007-09-03",
      "selected": null,
      "title": "Testing aspect-oriented programs as object-oriented programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34548223123&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "He H."
      ],
      "categories": null,
      "citations": 11,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/CGO.2007.3l",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "283-295",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769527647",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "International Symposium on Code Generation and Optimization, CGO 2007"
      },
      "publication_date": "2007-08-13",
      "selected": null,
      "title": "Code compaction of an operating system kernel",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34547684384&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Stitt G."
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1255456.1255471",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 3.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10844309",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.482,
        "snip": 0.831,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Computer Science Applications",
          "Computer Graphics and Computer-Aided Design"
        ],
        "title": "ACM Transactions on Design Automation of Electronic Systems"
      },
      "publication_date": "2007-08-01",
      "selected": null,
      "title": "Binary synthesis",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34548204342&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "M\u00e9ndez M."
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/j.entcs.2007.02.060",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "51-66",
      "publication": {
        "category": "Journal",
        "cite_score": 2.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "15710661",
        "publisher": "Elsevier B.V.",
        "sjr": 0.341,
        "snip": 0.958,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Electronic Notes in Theoretical Computer Science"
      },
      "publication_date": "2007-07-31",
      "selected": null,
      "title": "An Efficient, Parametric Fixpoint Algorithm for Analysis of Java Bytecode",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34547434156&origin=inward"
      ]
    },
    {
      "abstract": "One of the major challenges of control flow analysis in decompilation is to structure 2-way branches into conditionals, loop conditionals and switches. In this paper, we propose a graph-based method to formally describe structures of 2-way branches via the introduction of concepts called \"compound branch subgraph\" and \"cascade branch subgraph\". We then present novel structuring algorithms based on such concepts. Compared with previous works, our algorithms are deterministic rather than heuristic, and they do not use complicated data structures such as Interval/DSG. We show that in theory our algorithm is more accurate and efficient than typical current approaches; furthermore, we have applied the algorithm to several real-world binary executables, and experimental results validate such theoretical analysis.",
      "authors": [
        "Tao Wei",
        "Jian Mao",
        "Wei Zou",
        "Yu Chen"
      ],
      "categories": null,
      "citations": 10,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/COMPSAC.2007.203",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "115-118",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": "0-7695-2870-8",
        "issn": "0730-3157",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.302,
        "snip": 0.683,
        "subject_areas": [
          "Computer Science Applications",
          "Software"
        ],
        "title": "Proceedings 24th Annual International Computer Software and Applications Conference. COMPSAC2000"
      },
      "publication_date": "2007-07-24",
      "selected": null,
      "title": "Structuring 2-way Branches in Binary Executables",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=37349047729&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4290993"
      ]
    },
    {
      "abstract": "The recovery of parameter and return-value plays an important role in decompilation, reverse engineering, binary translation and software maintenance etc. Furthermore, related approaches are very useful to inter- procedural analyzing and slicing of binary executable. However, the operations on parameters and return- values always appear obscure after the optimizing phases of a compiler, which will make the recovery hard to realize. In this paper, we present a flow-insensitive but context-sensitive algorithm based on data dependence analysis to get back parameters and return- values. In addition, we discuss our experimental results obtained by applying our techniques to a static binary translation framework. Evidence shows that our method performs well in analyzing the parameters and return-values of executables. We use an IA-64 executable for demonstration, but our techniques are not limited to any particular architecture.",
      "authors": [
        "Jingbo Zhang",
        "Rongcai Zhao",
        "Jianmin Pang"
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/COMPSAC.2007.163",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "501-508",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": "0-7695-2870-8",
        "issn": "0730-3157",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.302,
        "snip": 0.683,
        "subject_areas": [
          "Computer Science Applications",
          "Software"
        ],
        "title": "Proceedings 24th Annual International Computer Software and Applications Conference. COMPSAC2000"
      },
      "publication_date": "2007-07-24",
      "selected": null,
      "title": "Parameter and Return-value Analysis of Binary Executables",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4291043",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=37349005790&origin=inward"
      ]
    },
    {
      "abstract": "The interpretative approach to compilation allows compiling programs by partially evaluating an interpreter w.r.t. a source program. This approach, though very attractive in principle, has not been widely applied in practice mainly because of the difficulty in finding a partial evaluation strategy which always obtain ''quality'' compiled programs. In spite of this, in recent work we have performed a proof of concept of that, at least for some examples, this approach can be applied to decompile Java bytecode into Prolog. This allows applying existing advanced tools for analysis of logic programs in order to verify Java bytecode. However, successful partial evaluation of an interpreter for (a realistic subset of) Java bytecode is a rather challenging problem. The aim of this work is to improve the performance of the decompilation process above in two respects. First, we would like to obtain quality decompiled programs, i.e., simple and small. We refer to this as the effectiveness of the decompilation. Second, we would like the decompilation process to be as efficient as possible, both in terms of time and memory usage, in order to scale up in practice. We refer to this as the efficiency of the decompilation. With this aim, we propose several techniques for improving the partial evaluation strategy. We argue that our experimental results show that we are able to improve significantly the efficiency and effectiveness of the decompilation process.",
      "authors": [
        "Miguel G\u00f3mez-Zamalloa",
        "Elvira Albert",
        "Germ\u00e1n Puebla"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1016/j.entcs.2007.02.062",
      "keywords": [
        "partial evaluation",
        "Java bytecode",
        "decompilation"
      ],
      "number_of_pages": 17,
      "pages": "85-101",
      "publication": {
        "category": "Journal",
        "cite_score": 2.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1571-0661",
        "publisher": "Elsevier B.V.",
        "sjr": 0.341,
        "snip": 0.958,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Electronic Notes in Theoretical Computer Science"
      },
      "publication_date": "2007-07-01",
      "selected": null,
      "title": "Improving the Decompilation of Java Bytecode to Prolog by Partial Evaluation",
      "urls": [
        "https://dl.acm.org/doi/10.1016/j.entcs.2007.02.062",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34547217389&origin=inward"
      ]
    },
    {
      "abstract": "Java developers often use decompilers to aid reverse engineering and obfuscators to prevent it. Decompilers translate low-level class files to Java source and can produce \"good\" output. Obfuscators transform class files into semantically-equivalent versions that are either: (1) difficult to decompile, or (2) decompilable, but result in \"hard- to-understand\" Java source. We present a set of metrics developed to quantify the effectiveness of decompilers and obfuscators. The metrics include some selective size and counting metrics and an expression complexity metric. We have applied these metrics to evaluate a collection of decompilers and obfuscators. By quantitatively comparing original Java source against decompiled and obfuscated code respectively, we show which decompilers produce \"good\" code and whether obfuscations result in \"hard-to-understand\" code.",
      "authors": [
        "Nomair A. Naeem",
        "Michael Batchelder",
        "Laurie Hendren"
      ],
      "categories": null,
      "citations": 16,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICPC.2007.27",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "253-258",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769528600",
        "issn": "1092-8138",
        "publisher": "IEEE Computer Society",
        "sjr": 0.39,
        "snip": 0.978,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Proceedings of the 15th IEEE International Conference on Program Comprehension"
      },
      "publication_date": "2007-06-26",
      "selected": null,
      "title": "Metrics for Measuring the Effectiveness of Decompilers and Obfuscators",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34948844614&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4268259",
        "https://dl.acm.org/doi/10.1109/ICPC.2007.27"
      ]
    },
    {
      "abstract": "High level programming languages are usually implemented as compilers, interpreters, pseudo compilers, just in time compilers and compact form interpreters. All of the mentioned approaches have their advantages and disadvantages. The approach proposed in this paper eliminates need for source code as physical entity, making the native machine code the only file that exists and is archived, while the special viewer/editor shows and edits it in a form understandable as a high level language. The viewer/editor acts as integrated all-in-one editor, decompiler and incremental compiler.",
      "authors": [
        "Samir Ribic",
        "Adnan Salihbegovic"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ITI.2007.4283870",
      "keywords": [
        "programming languages",
        "Compiling",
        "decompiling",
        "reverse engineering"
      ],
      "number_of_pages": 6,
      "pages": "777-782",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "953-7138-10-0",
        "issn": "1330-1012",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the International Conference on Information Technology Interfaces, ITI"
      },
      "publication_date": "2007-06-25",
      "selected": null,
      "title": "High Level Language Translator with Machine Code as Representation of the Source Code",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=48349146440&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4283870"
      ]
    },
    {
      "abstract": "Bytecode, Java's binary form, is relatively high-level and therefore susceptible to decompilation attacks. An obfuscator transforms code such that it becomes more complex and therefore harder to reverse engineer. We develop bytecode obfuscations that are complex to reverse engineer but also do not significantly degrade performance. We present three kinds of techniques that: (1) obscure intent at the operational level; (2) complicate control flow and object-oriented design (i.e. program structure); and (3) exploit the semantic gap between what is legal in source code and what is legal in bytecode. Obfuscations are applied to a benchmark suite to examine their affect on runtime performance, control flow graph complexity and decompilation. These results show that most of the obfuscations have only minor negative performance impacts and many increase complexity. In almost all cases, tested decompilers fail to produce legal source code or crash completely. Those obfuscations that are decompilable greatly reduce the readability of output source.",
      "authors": [
        "Michael Batchelder",
        "Laurie Hendren"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1759937.1759946",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "96-110",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9783540712282",
        "issn": null,
        "publisher": "Springer-Verlag",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 16th international conference on Compiler construction"
      },
      "publication_date": "2007-03-26",
      "selected": null,
      "title": "Obfuscating Java: the most pain for the least gain",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1759937.1759946"
      ]
    },
    {
      "abstract": "General-purpose operating systems, such as Linux, are increasingly being used in embedded systems. Computational resources are usually limited, and embedded processors often have a limited amount of memory. This makes code size especially important. This paper describes techniques for automatically reducing the memory footprint of general-purpose operating systems on embedded platforms. The problem is complicated by the fact that kernel code tends to be quite different from ordinary application code, including the presence of a significant amount of hand-written assembly code, multiple entry points, implicit control flow paths involving interrupt handlers, and frequent indirect control flow via function pointers. We use a novel \"approximate decompilation\" technique to apply source-level program analysis to hand-written assembly code. A prototype implementation of our ideas on an Intel x86 platform, applied to a Linux kernel that has been configured to exclude unnecessary code, obtains a code size reduction of close to 24%",
      "authors": [
        "Haifeng He",
        "John Trimble",
        "Somu Perianayagam",
        "Saumya Debray",
        "Gregory Andrews"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/CGO.2007.3",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "283-298",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-2764-7",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "International Symposium on Code Generation and Optimization (CGO'07)"
      },
      "publication_date": "2007-03-11",
      "selected": null,
      "title": "Code Compaction of an Operating System Kernel",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4145122"
      ]
    },
    {
      "abstract": "Bytecode, Java\u2019s binary form, is relatively high-level and therefore susceptible to decompilation attacks. An obfuscator transforms code such that it becomes more complex and therefore harder to reverse engineer. We develop bytecode obfuscations that are...",
      "authors": [
        "Batchelder, Michael",
        "Hendren, Laurie"
      ],
      "categories": null,
      "citations": 19,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-540-71229-9_7",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "96-110",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2007-01-01",
      "selected": null,
      "title": "Obfuscating Java: The Most Pain for the Least Gain",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-540-71229-9_7.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34948902663&origin=inward"
      ]
    },
    {
      "abstract": "We present a formal treatment of normalization by evaluation in type theory. The involved semantics of simply-typed \u03bb-calculus is exactly the simply typed fragment of the type theory. This means we have constructed and proved correct a decompilation function...",
      "authors": [
        "Garillot, Fran\u00e7ois",
        "Werner, Benjamin"
      ],
      "categories": null,
      "citations": 12,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-540-74591-4_27",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "368-382",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2007-01-01",
      "selected": null,
      "title": "Simple Types in Type Theory: Deep and Shallow Encodings",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=38049010882&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/978-3-540-74591-4_27.pdf"
      ]
    },
    {
      "abstract": "The ubiquitous game platform implemented by our team is composed of a C++ compiler, a java translator, and a virtual machine. The EVM (Embedded Virtual Machine) is a stack-based solution that supports object-oriented languages such as C++ and java. It uses the SIL...",
      "authors": [
        "Lee, YangSun",
        "Kim, YoungKeun",
        "Kwon, HyeokJu"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-540-77368-9_50",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "511-521",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2007-01-01",
      "selected": null,
      "title": "Design and Implementation of the Decompiler for Virtual Machine Code of the C++ Compiler in the Ubiquitous Game Platform",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-540-77368-9_50.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=38549094033&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Darrah, Marjorie",
        "Taylor, Brian J."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/0-387-29485-6_8",
      "keywords": [],
      "number_of_pages": 29,
      "pages": "199-227",
      "publication": {
        "category": "Book",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0387282882",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Methods and Procedures for the Verification and Validation of Artificial Neural Networks"
      },
      "publication_date": "2006-12-01",
      "selected": null,
      "title": "Rule Extraction as a Formal Method",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84892356355&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/0-387-29485-6_8.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Liu H."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 6,
      "pages": "41-46",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781604235821",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the ISCA 15th International Conference on Software Engineering and Data Engineering, SEDE 2006"
      },
      "publication_date": "2006-12-01",
      "selected": null,
      "title": "A prototype decompiler for 32-bit x86 executables",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84883544626&origin=inward"
      ]
    },
    {
      "abstract": "The ubiquitous game platform implemented by our team is composed of a C++ compiler, a java translator, and a virtual machine. The EVM (Embedded Virtual Machine) is a stack-based solution that supports object-oriented languages such as C++ and java. It uses the SIL (Standard Intermediate Language) as an intermediate language, which consists of an operation code set for procedural and object-oriented languages. The existing C++ compilers are used to execute programs after translating them into a target machine code. The downside of this method is its low practicality, along with its platform-dependency. To resolve this matter, we developed a C++ compiler that generates virtual machine codes based on platform-independent stacks that are not target machine codes. This paper presents a decompiler system that converts a C++ compiler generated intermediate language, namely SIL, to a representation of a C++ program. This method optimizes the simulation needed for the generation of exacted SIL code, and a solution that can verify the SIL code generation through a C++ program represented in the decompiler. Furthermore, the ease of extracting the meaning of a program, as opposed to assembly-structured SIL codes, allows much more convenience in changing the software structure and correcting it to improve performance.",
      "authors": [
        "YangSun Lee",
        "YoungKeun Kim",
        "HyeokJu Kwon"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1782654.1782709",
      "keywords": [
        "decompiler",
        "C++ compiler",
        "virtual machine code"
      ],
      "number_of_pages": 11,
      "pages": "511-521",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "3540773673",
        "issn": null,
        "publisher": "Springer-Verlag",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1st international conference on Advances in hybrid information technology"
      },
      "publication_date": "2006-11-09",
      "selected": null,
      "title": "Design and implementation of the decompiler for virtual machine code of the C++ compiler in the ubiquitous game platform",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1782654.1782709"
      ]
    },
    {
      "abstract": "In this thesis it will be investigated the possibility of developing the programming language translator, heavily based on decompilation. Instead of keeping program in source code, it will be kept in native machine code, but it will be transparently visible as high level language program, with the help of the specialized editor.",
      "authors": [
        "Samir Ribic"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2006.20",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "307-308",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769527191",
        "issn": "2375-5369",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 13th Working Conference on Reverse Engineering"
      },
      "publication_date": "2006-10-23",
      "selected": null,
      "title": "Concept and implementation of the programming language and translator, for embedded systems, based on machine code decompilation and equivalence between source and executable code",
      "urls": [
        "https://dl.acm.org/doi/10.1109/WCRE.2006.20",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4024006",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34948904797&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lysecky R."
      ],
      "categories": null,
      "citations": 126,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1142980.1142986",
      "keywords": [],
      "number_of_pages": 23,
      "pages": "659-681",
      "publication": {
        "category": "Journal",
        "cite_score": 3.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10844309",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.482,
        "snip": 0.831,
        "subject_areas": [
          "Electrical and Electronic Engineering",
          "Computer Science Applications",
          "Computer Graphics and Computer-Aided Design"
        ],
        "title": "ACM Transactions on Design Automation of Electronic Systems"
      },
      "publication_date": "2006-09-13",
      "selected": null,
      "title": "Warp processors",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33748420512&origin=inward"
      ]
    },
    {
      "abstract": "Analysis or verification of low-level code is useful for minimizing the disconnect between what is verified and what is actually executed and is necessary when source code is unavailable or is, say, intermingled with inline assembly. We present a modular framework...",
      "authors": [
        "Chang, Bor-Yuh Evan",
        "Harren, Matthew",
        "Necula, George C."
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/11823230_21",
      "keywords": [],
      "number_of_pages": 18,
      "pages": "318-335",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "3540377565",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2006-08-29",
      "selected": null,
      "title": "Analysis of Low-Level Code Using Cooperating Decompilers",
      "urls": [
        "https://dl.acm.org/doi/10.1007/11823230_21",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33749847859&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/11823230_21.pdf"
      ]
    },
    {
      "abstract": "Three novel control computation (control flow) obfuscation methods are described for protecting Java class files. They are basic block fission obfuscation, intersecting loop obfuscation and replacing goto obfuscation. The basic block fission obfuscation splits some chosen basic block(s) into more basic blocks, in which opaque predicates and goto instructions are inserted to make decompiling unsuccessful. The intersecting loop obfuscation intersects two loops and then adds this pattern into programs. The intersecting loop structure should not appear in a Java source program or a class file. The replacing goto obfuscation replaces goto instructions with conditional branch instructions. The new methods were tested against 16 decompilers. The study also implemented multi-level exit obfuscation and single-level exit obfuscation for comparison. Both the intersecting loop obfuscation and the replacing goto obfuscation successfully defeated all the decompilers.",
      "authors": [
        "T.W. Hou",
        "H.Y. Chen",
        "M.H. Tsai"
      ],
      "categories": null,
      "citations": 34,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1049/ip-sen:20050010",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "80-86",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "14625970",
        "publisher": "Institute of Electrical Engineers",
        "sjr": 0.341,
        "snip": 0.958,
        "subject_areas": [
          "Computer Graphics and Computer-Aided Design",
          "Software"
        ],
        "title": "IEE Proceedings - Software"
      },
      "publication_date": "2006-07-20",
      "selected": null,
      "title": "Three control flow obfuscation methods for Java software",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33745945511&origin=inward"
      ]
    },
    {
      "abstract": "Java decompilers convert Java class files to Java source. Java class files may be created by a number of different tools including standard Java compilers, compilers for other languages such as AspectJ, or other tools such as optimizers or obfuscators. There are two kinds of Java decompilers, Javac-specific decompilers that assume that the class file was created by a standard Javac compiler and tool-independent decompilers that can decompile arbitrary class files, independent of the tool that created the class files. Typically Javac-specific decompilers produce more readable code, but they fail to decompile many class files produced by other tools. This paper tackles the problem of how to make a tool-independent decompiler, Dava, produce Java source code that is programmer-friendly. In past work it has been shown that Dava can decompile arbitrary class files, but often the output, although correct, is very different from what a programmer would write and is hard to understand. Furthermore, tools like obfuscators intentionally confuse the class files and this also leads to confusing decompiled source files. Given that Dava already produces correct Java abstract syntax trees (ASTs) for arbitrary class files, we provide a new back-end for Dava. The back-end rewrites the ASTs to semantically equivalent ASTs that correspond to code that is easier for programmers to understand. Our new back-end includes a new AST traversal framework, a set of simple pattern-based transformations, a structure-based data flow analysis framework and a collection of more advanced AST transformations that use flow analysis information. We include several illustrative examples including the use of advanced transformations to clean up obfuscated code",
      "authors": [
        "Nomair A. Naeem",
        "Laurie Hendren"
      ],
      "categories": null,
      "citations": 12,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICPC.2006.40",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "327-336",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769526012",
        "issn": "1092-8138",
        "publisher": "IEEE Computer Society",
        "sjr": 0.39,
        "snip": 0.978,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "Proceedings of the 14th IEEE International Conference on Program Comprehension"
      },
      "publication_date": "2006-06-14",
      "selected": null,
      "title": "Programmer-friendly Decompiled Java",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33845384543&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1631140",
        "https://dl.acm.org/doi/10.1109/ICPC.2006.40"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sangeetha M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 6,
      "pages": "308-313",
      "publication": {
        "category": "Journal",
        "cite_score": 0.4,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "11099445",
        "publisher": "World Scientific and Engineering Academy and Society",
        "sjr": 0.109,
        "snip": 0.205,
        "subject_areas": [
          "Electrical and Electronic Engineering"
        ],
        "title": "WSEAS Transactions on Electronics"
      },
      "publication_date": "2006-05-01",
      "selected": null,
      "title": "A dataflow extraction technique for hardware/software partitioning of software binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33746912324&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Rosenblueth D.A."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 31,
      "pages": "219-249",
      "publication": {
        "category": "Journal",
        "cite_score": 3.2,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01692968",
        "publisher": "IOS Press BV",
        "sjr": 0.338,
        "snip": 0.688,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Theoretical Computer Science",
          "Information Systems",
          "Algebra and Number Theory"
        ],
        "title": "Fundamenta Informaticae"
      },
      "publication_date": "2006-03-08",
      "selected": null,
      "title": "A multiple-clause folding rule using instantiation and generalization",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33644612911&origin=inward"
      ]
    },
    {
      "abstract": "When interfacing Java with other systems such as databases, programmers must often program in special interface languages like SQL. Code written in these languages often needs to be embedded in strings where they cannot be error-checked at compile-time, or the Java...",
      "authors": [
        "Iu, Ming-Yee",
        "Zwaenepoel, Willy"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/11925071_11",
      "keywords": [],
      "number_of_pages": 18,
      "pages": "201-218",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2006-01-01",
      "selected": null,
      "title": "Queryll: Java Database Queries Through Bytecode Rewriting",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/11925071_11.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33845947497&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Sun G."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 4,
      "pages": "177-180",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10002472",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Hunan Daxue Xuebao/Journal of Hunan University Natural Sciences"
      },
      "publication_date": "2005-12-01",
      "selected": null,
      "title": "Software protection technique based on software watermark and obfuscation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33344459869&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zheng J."
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1082948.1082957",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 7.0,
        "is_potentially_predatory": false,
        "isbn": "9781728108698",
        "issn": "02705257",
        "publisher": "IEEE Computer Society",
        "sjr": 1.235,
        "snip": 1.945,
        "subject_areas": [
          "Software"
        ],
        "title": "Proceedings - International Conference on Software Engineering"
      },
      "publication_date": "2005-12-01",
      "selected": null,
      "title": "A process for identifying changes when source code is not available",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=77954463601&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Chen H.Y."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 5,
      "pages": "48-52",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0889864853",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the IASTED International Conference on Web Technologies, Applications, and Services, WTAS 2005"
      },
      "publication_date": "2005-12-01",
      "selected": null,
      "title": "Two control computation transformation methods for obfuscating Java soft software",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33644510098&origin=inward"
      ]
    },
    {
      "abstract": "Existing ASIPs (application-specific instruction-set processors) and compiler-based co-processor synthesis approaches meet the increasing performance requirements of embedded applications while consuming less power than high-performance gigahertz microprocessors. However, existing approaches place restrictions on software languages and compilers. Binary-level co-processor generation has previously been proposed as a complementary approach to reduce impact on tool restrictions, supporting all languages and compilers, at the cost of some decrease in performance. In a binary-level approach, decompilation recovers much of the high-level information, like loops and arrays, needed for effective synthesis, and in many cases yields hardware similar to that of a compiler-based approach. However, previous binary-level approaches have not considered the effects of software compiler optimizations on the resulting hardware. In this paper, we introduce two new decompilation techniques, strength promotion and loop rerolling, and show that they are necessary to synthesize an efficient custom hardware coprocessor from a binary in the presence of software compiler optimizations. In addition, unlike previous approaches, we show the robustness of binary-level co-processor generation by achieving order of magnitude speedups for binaries generated for three different instruction sets, MIPS, ARM, and MicroBlaze, using two different levels of compiler optimizations.",
      "authors": [
        "G. Stiff",
        "F. Vahid"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICCAD.2005.1560127",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "547-554",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7803-9254-X",
        "issn": "1558-2434",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE/ACM International Conference on Computer-Aided Design, Digest of Technical Papers, ICCAD"
      },
      "publication_date": "2005-11-06",
      "selected": null,
      "title": "New decompilation techniques for binary-level co-processor generation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33751423594&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1560127"
      ]
    },
    {
      "abstract": "Decompilation is the process of translating object code to source code and is usually the first step towards the reverse-engineering of an application. Many obfuscation techniques and tools have been developed, with the aim of modifying a program, such that its functionalities are preserved, while its understandability is compromised for a human reader or the decompilation is made unsuccessful. Some approaches rely on malicious identifiers renaming, i.e., on the modification of the program identifiers in order to introduce confusion and possibly prevent the decompilation of the code. In this work we introduce a new technique to overcome the obfuscation of Java programs by identifier renaming. Such a technique relies on the intelligent modification of identifiers in Java bytecode. We present a new software tool which implements our technique and allows the processing of an obfuscated program in order to rename the identifiers as required by our technique. Moreover, we show how to use the existing tools to provide a partial implementation of the technique we propose. Finally, we discuss the feasibility of our approach by showing how to contrast the obfuscation techniques based on malicious identifier renaming recently presented in literature.",
      "authors": [
        "S. Cimato",
        "A. De Santis",
        "U. Ferraro Petrillo"
      ],
      "categories": null,
      "citations": 24,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1016/j.jss.2004.11.019",
      "keywords": [
        "Decompilation",
        "Java obfuscation",
        "Program protection"
      ],
      "number_of_pages": 13,
      "pages": "60-72",
      "publication": {
        "category": "Journal",
        "cite_score": 9.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0164-1212",
        "publisher": "Elsevier Inc.",
        "sjr": 1.126,
        "snip": 2.032,
        "subject_areas": [
          "Hardware and Architecture",
          "Information Systems",
          "Software"
        ],
        "title": "Journal of Systems and Software"
      },
      "publication_date": "2005-10-01",
      "selected": null,
      "title": "Overcoming the obfuscation of Java programs by identifier renaming",
      "urls": [
        "https://dl.acm.org/doi/10.1016/j.jss.2004.11.019",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=19744376924&origin=inward"
      ]
    },
    {
      "abstract": "Existing ASIPs (application-specific instruction-set processors) and compiler-based co-processor synthesis approaches meet the increasing performance requirements of embedded applications while consuming less power than high-performance gigahertz microprocessors. However, existing approaches place restrictions on software languages and compilers. Binary-level co-processor generation has previously been proposed as a complementary approach to reduce impact on tool restrictions, supporting all languages and compilers, at the cost of some decrease in performance. In a binary-level approach, decompilation recovers much of the high-level information, like loops and arrays, needed for effective synthesis, and in many cases yields hardware similar to that of a compiler-based approach. However, previous binary-level approaches have not considered the effects of software compiler optimizations on the resulting hardware. In this paper, we introduce two new decompilation techniques, strength promotion and loop rerolling, and show that they are necessary to synthesize an efficient custom hardware coprocessor from a binary in the presence of software compiler optimizations. In addition, unlike previous approaches, we show the robustness of binary-level co-processor generation by achieving order of magnitude speedups for binaries generated for three different instruction sets, MIPS, ARM, and MicroBlaze, using two different levels of compiler optimizations.",
      "authors": [
        "G. Stiff",
        "F. Vahid"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1129601.1129679",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "547-554",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "078039254X",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2005 IEEE/ACM International conference on Computer-aided design"
      },
      "publication_date": "2005-05-31",
      "selected": null,
      "title": "New decompilation techniques for binary-level co-processor generation",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1129601.1129679"
      ]
    },
    {
      "abstract": "Field proven Root Cause Analysis (RCA) from the industrial sector can assist the terrorism community in decompiling terrorist acts to further understand the mentalities that trigger such events to escalate. RCA is a disciplined thought process that is not specific to...",
      "authors": [
        "Latino, Robert J."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/11427995_62",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "579-589",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "3540259996",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2005-05-19",
      "selected": null,
      "title": "The Application of PROACT\u00ae RCA to Terrorism/Counter Terrorism Related Events",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=24944490557&origin=inward",
        "https://dl.acm.org/doi/10.1007/11427995_62",
        "https://link.springer.com/content/pdf/10.1007/11427995_62.pdf"
      ]
    },
    {
      "abstract": "In this paper, we present a software compilation approach for microprocessor/FPGA platforms that partitions a software binary onto custom hardware implemented in the FPGA. Our approach imposes less restrictions on software tool flow than previous compiler approaches, allowing software designers to use any software language and compiler. Our approach uses a back-end partitioning tool that utilizes decompilation techniques to recover important high-level information, resulting in performance comparable to high-level compiler-based approaches.",
      "authors": [
        "Greg Stitt",
        "Frank Vahid"
      ],
      "categories": null,
      "citations": 12,
      "comments": null,
      "databases": [
        "ACM",
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/DATE.2005.9",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "396-397 Vol. 1",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769522882",
        "issn": "1558-1101",
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the conference on Design, Automation and Test in Europe - Volume 1"
      },
      "publication_date": "2005-03-07",
      "selected": null,
      "title": "A Decompilation Approach to Partitioning Software for Microprocessor/FPGA Platforms",
      "urls": [
        "https://dl.acm.org/doi/10.1109/DATE.2005.9",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=33646917777&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1395592"
      ]
    },
    {
      "abstract": "Recent works demonstrate several benefits of synthesizing software binaries onto FPGA hardware, including incorporating hardware design into established software tool flows with minimal impact, porting existing binaries to FPGAs, and even dynamically synthesizing software kernels to faster FPGA coprocessors. Those works showed that standard binary decompilation methods can recover enough high-level control information to result in reasonably-efficient hardware. However, recent synthesis methods for FPGAs utilize advanced memory structures, such as a \"smart buffer,\" that require recovery of additional high-level information, specifically information about loops and arrays. We incorporate decompilation techniques into an existing binary synthesis tool flow to recover loops and arrays in order to take advantage of advanced memory structures when performing synthesis from a binary. We demonstrate through experiments on six benchmarks that our methods improve binary synthesis performance by 53%, by making effective use of smart buffers. Furthermore, we compare the binary results using smart buffers with results of synthesis directly from the original C code for the benchmarks, and show that our methods achieved almost identical performance results with only 10% area overhead.",
      "authors": [
        "Greg Stitt",
        "Zhi Guo",
        "Walid Najjar",
        "Frank Vahid"
      ],
      "categories": null,
      "citations": 17,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/1046192.1046208",
      "keywords": [
        "smart buffers",
        "FPGA",
        "synthesis",
        "embedded systems",
        "decompilation",
        "binaries"
      ],
      "number_of_pages": 7,
      "pages": "118-124",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "1595930299",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 2005 ACM/SIGDA 13th international symposium on Field-programmable gate arrays"
      },
      "publication_date": "2005-02-20",
      "selected": null,
      "title": "Techniques for synthesizing binaries to an advanced register/memory structure",
      "urls": [
        "https://dl.acm.org/doi/10.1145/1046192.1046208",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=20344375498&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Wiener R."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.5381/jot.2005.4.4.c6",
      "keywords": [],
      "number_of_pages": 20,
      "pages": "73-92",
      "publication": {
        "category": "Journal",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "16601769",
        "publisher": "Journal of Object Technology",
        "sjr": 0.418,
        "snip": 0.756,
        "subject_areas": [
          "Software"
        ],
        "title": "Journal of Object Technology"
      },
      "publication_date": "2005-01-01",
      "selected": null,
      "title": "Obfuscation and .NET",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=22944487635&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ahamed S."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 6,
      "pages": "689-694",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": true,
        "isbn": null,
        "issn": "10272658",
        "publisher": "Acta Press",
        "sjr": 0.101,
        "snip": 0.133,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Proceedings of the IASTED International Conference on Parallel and Distributed Computing and Systems"
      },
      "publication_date": "2004-12-01",
      "selected": null,
      "title": "An integrated approach to customize binary components",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=11844280414&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2004-12-01",
      "selected": null,
      "title": "Proceedings 11<sup>th</sup> Working Conference on Reverse Engineering, WCRE 2004",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=18144380348&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lakhotia A."
      ],
      "categories": null,
      "citations": 20,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2004.2",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "17-28",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769521444",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Fourth IEEE International Workshop on Source Code Analysis and Manipulation"
      },
      "publication_date": "2004-12-01",
      "selected": null,
      "title": "Abstracting stack to detect obfuscated calls in binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=14344257909&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Su B."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 10,
      "pages": "7-16",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769521444",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Fourth IEEE International Workshop on Source Code Analysis and Manipulation"
      },
      "publication_date": "2004-12-01",
      "selected": null,
      "title": "Software de-pipelining technique",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=14344250062&origin=inward"
      ]
    },
    {
      "abstract": "Despite their 40 year history, native executable decompilers have found very limited practical application in commercial projects. The success of Java decompilers is well known, and a few decompilers perform well by recognising patterns from specific compilers. This work describes the experience gained from applying a native executable decompiler, assisted by a commercial disassembler and hand editing, to a real-world Windows-based application. The clients had source code for a prototype version of the program, and an executable that performed better, for which the source code was not available. The project was to recover the algorithm at the core of the program, and if time permitted, the recovery of other pieces of source code. Despite the difficulties, the core algorithm was successfully decompiled, and a portion of the rest of the program as well. There were surprises, including the ability to recover almost all original class names, and the complete class hierarchy.",
      "authors": [
        "M.V. Emmerik",
        "T. Waddington"
      ],
      "categories": null,
      "citations": 44,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2004.42",
      "keywords": [
        "Reverse engineering",
        "source code recovery",
        "decompilation",
        "native executable file",
        "experience"
      ],
      "number_of_pages": 10,
      "pages": "27-36",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4577-1948-6",
        "issn": "1095-1350",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2004-11-08",
      "selected": null,
      "title": "Using a decompiler for real-world source recovery",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=18144399312&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1374303"
      ]
    },
    {
      "abstract": "The following topics are dealt with: decompilation; program slicing; restructuring; aspect-oriented programming; software maintenance; and source code.",
      "authors": [],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/SCAM.2004.10",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-2144-4",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Source Code Analysis and Manipulation, Fourth IEEE International Workshop on"
      },
      "publication_date": "2004-09-16",
      "selected": null,
      "title": "Fourth IEEE International Workshop on Source Code Analysis and Manipulation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1386146"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Curran D."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 2,
      "pages": "569-570",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0780384822",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 2004 International Conference on Information and Communication Technologies: From Theory to Applications, ICTTA 2004"
      },
      "publication_date": "2004-06-28",
      "selected": null,
      "title": "Dependency in software watermarking",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=2942676732&origin=inward"
      ]
    },
    {
      "abstract": "The advent of bytecode languages such as Java and advances in decompilation tools has made it easier to infringe the copyright of software. This presents a serious challenge to the software industry, as modern Internet software is highly distributed and the potential for software piracy is immense. Software watermarking has been proposed as one means of protecting the intellectual property in software. The strategy is to embed secret ownership information (i.e., a 'watermark') in a program that cannot be easily removed by unauthorized parties but that can be reliably extracted by an authorized decoder. We investigate a practical implementation of dynamic graph watermarking, focusing particularly on embedding stealthy watermark generating code in the program's text. Our scheme is based on the premise that watermarking code should not be distinguishable from ordinary program code. This is because one strategy for an attacker whose goal is to destroy the watermark is to attempt to directly locate the watermark generating code within the program text and remove or alter it.",
      "authors": [
        "D. Curran",
        "M.O. Cinneide",
        "N.J. Hurley",
        "G.C.M. Silvestre"
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/ICTTA.2004.1307890",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "569-570",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7803-8482-2",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings. 2004 International Conference on Information and Communication Technologies: From Theory to Applications, 2004."
      },
      "publication_date": "2004-04-23",
      "selected": null,
      "title": "Dependency in software watermarking",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1307890"
      ]
    },
    {
      "abstract": "In this paper we explore the application of the QP watermarking algorithm proposed by G. Qu and M. Potkonjak to software watermarking. The algorithm was originally proposed as a\u00a0technique for watermarking the graph coloring problem which can be applied to...",
      "authors": [
        "Myles, Ginger",
        "Collberg, Christian"
      ],
      "categories": null,
      "citations": 42,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/978-3-540-24691-6_21",
      "keywords": [],
      "number_of_pages": 20,
      "pages": "274-293",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2004-01-01",
      "selected": null,
      "title": "Software Watermarking Through Register Allocation: Implementation, Analysis, and Attacks",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/978-3-540-24691-6_21.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=24944554182&origin=inward"
      ]
    },
    {
      "abstract": "Advanced computer architectures rely mainly on compiler optimizations for parallelization, vectorization, and pipelining. Efficient-code generation is based on a control dependence analysis to find the basic blocks and to determine the regions of control. However, unstructured branch statements, such as jumps and goto's, render the control flow analysis difficult, time-consuming, and result in poor code generation. Branches are part of many programming languages and occur in legacy and maintenance code as well as in assembler, intermediate languages, and byte code. A simple and effective technique is presented to convert unstructured branches into hammock graph control structures. Using three basic transformations, an equivalent program is obtained in which all control statements have a well-defined scope. In the interest of predication and branch prediction, the number of control variables has been minimized, thereby allowing a limited code replication. The correctness of the transformations has been proven using an axiomatic proof rule system. With respect to previous work, the algorithm is simpler and the branch conditions are less complex, making the program more readable and the code generation more efficient. Additionally, hammock graphs define single entry single exit regions and therefore allow localized optimizations. The restructuring method has been implemented into the parallelizing compiler FPT and allows to extract parallelism in unstructured programs. The use of hammock graph transformations in other application areas such as vectorization, decompilation, and assembly program restructuring is also demonstrated.",
      "authors": [
        "F. Zhang",
        "E.H. D'Hollander"
      ],
      "categories": null,
      "citations": 45,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/TSE.2004.1274043",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "231-245",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "2326-3881",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE Transactions on Software Engineering"
      },
      "publication_date": "2004-01-01",
      "selected": null,
      "title": "Using hammock graphs to structure programs",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1274043",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=1942500450&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mittal G."
      ],
      "categories": null,
      "citations": 24,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/996566.996678",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "389-394",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0738100X",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Design Automation Conference"
      },
      "publication_date": "2004-01-01",
      "selected": null,
      "title": "Automatic translation of software binaries onto FPGAs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=4444269458&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Vinciguerra L."
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1109/WCRE.2003.1287233",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "14-23",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2003-12-24",
      "selected": null,
      "title": "An Experimentation Framework for Evaluating Disassembly and Decompilation Tools for C++ and Java",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84944602623&origin=inward",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0348042980&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2003-12-24",
      "selected": null,
      "title": "Proceedings 10th Working Conference on Reverse Engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0348041808&origin=inward"
      ]
    },
    {
      "abstract": "A great deal of software is distributed in the form of executable code. The ability to reverse engineer such executables can create opportunities for theft of intellectual property via software piracy, as well as security breaches by allowing attackers to discover vulnerabilities in an application. The process of reverse engineering an executable program typically begins with disassembly, which translates machine code to assembly code. This is then followed by various decompilation steps that aim to recover higher-level abstractions from the assembly code. Most of the work to date on code obfuscation has focused on disrupting or confusing the decompilation phase. This paper, by contrast, focuses on the initial disassembly phase. Our goal is to disrupt the static disassembly process so as to make programs harder to disassemble correctly. We describe two widely used static disassembly algorithms, and discuss techniques to thwart each of them. Experimental results indicate that significant portions of executables that have been obfuscated using our techniques are disassembled incorrectly, thereby showing the efficacy of our methods.",
      "authors": [
        "Cullen Linn",
        "Saumya Debray"
      ],
      "categories": null,
      "citations": 483,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/948109.948149",
      "keywords": [
        "disassembly",
        "code obfuscation"
      ],
      "number_of_pages": 10,
      "pages": "290-299",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "1581137389",
        "issn": "15437221",
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 10th ACM conference on Computer and communications security"
      },
      "publication_date": "2003-10-27",
      "selected": null,
      "title": "Obfuscation of executable code to improve resistance to static disassembly",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=14344262813&origin=inward",
        "https://dl.acm.org/doi/10.1145/948109.948149"
      ]
    },
    {
      "abstract": "Partitioning an application among software running on a microprocessor and hardware co-processor in on-chip configurable logic has been shown to improve performance and energy consumption in embedded systems. Meanwhile, dynamic software optimization methods have shown the usefulness and feasibility of runtime program optimization, but those optimizations do not achieve as much as partitioning. We introduce a first approach to dynamic hardware/software partitioning. We describe our system architecture and initial on-chip tools, including profiler, decompiler, synthesis, and placement and routing tools for a simplified configurable logic fabric, able to perform dynamic partitioning of real benchmarks. We show speedups averaging 2.6 for five benchmarks taken from Powerstone, Netbench and our own benchmarks.",
      "authors": [
        "G. Stitt",
        "R. Lysecky",
        "F. Vahid"
      ],
      "categories": null,
      "citations": 54,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1145/775832.775896",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "250-255",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "1-58113-688-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings 2003. Design Automation Conference (IEEE Cat. No.03CH37451)"
      },
      "publication_date": "2003-06-02",
      "selected": null,
      "title": "Dynamic hardware/software partitioning: a first approach",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1219003"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Stitt G."
      ],
      "categories": null,
      "citations": 120,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/775832",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "250-255",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0738100X",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Design Automation Conference"
      },
      "publication_date": "2003-01-01",
      "selected": null,
      "title": "Dynamic hardware/software partitioning: A first approach",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84876830013&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Stitt G."
      ],
      "categories": null,
      "citations": 45,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/774572.774596",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "164-170",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 4.1,
        "is_potentially_predatory": false,
        "isbn": "078039254X",
        "issn": "10923152",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.732,
        "snip": 1.019,
        "subject_areas": [
          "Computer Graphics and Computer-Aided Design",
          "Computer Science Applications",
          "Software"
        ],
        "title": "IEEE/ACM International Conference on Computer-Aided Design, Digest of Technical Papers, ICCAD"
      },
      "publication_date": "2002-12-01",
      "selected": null,
      "title": "Hardware/software partitioning of software binaries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0036911691&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Chen K.M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 1,
      "pages": "1173",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10001220",
        "publisher": "Zhongguo Kexueyuan - Chinese Academy of Sciences",
        "sjr": 0.104,
        "snip": 0.133,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Xiaoxing Weixing Jisuanji Xitong/Mini-Micro Systems"
      },
      "publication_date": "2002-10-01",
      "selected": null,
      "title": "Design and implement of user-oriented intermediate language in decompilation system",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0036810910&origin=inward"
      ]
    },
    {
      "abstract": "Java virtual machines execute Java bytecode instructions. Since this bytecode is a higher level representation than traditional object code, it is possible to decompile it back to Java source. Many such decompilers have been developed and the conventional wisdom is that decompiling Java bytecode is relatively simple. This may be true when decompiling bytecode produced directly from a specific compiler, most often Sun's javac compiler. In this case it is really a matter of inverting a known compilation strategy. However, there are many problems, traps and pitfalls when decompiling arbitrary verifiable Java bytecode. Such bytecode could be produced by other Java compilers, Java byte-code optimizers or Java bytecode obfuscators. Java bytecode can also be produced by compilers for other languages, including Haskell, Eiffel, ML, Ada and Fortran. These compilers often use very different code generation strategies from javac.This paper outlines the problems and solutions we have found in our development of Dava, a decompiler for arbitrary Java bytecode. We first outline the problems in assigning types to variables and literals, and the problems due to expression evaluation on the Java stack. Then, we look at finding structured control flow with a particular emphasis on issues related to Java exceptions and synchronized blocks. Throughout the paper we provide small examples which are not properly decompiled by commonly used decompilers.",
      "authors": [
        "Jerome Miecznikowski",
        "Laurie J. Hendren"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/647478.727938",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "111-127",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "3540433694",
        "issn": null,
        "publisher": "Springer-Verlag",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 11th International Conference on Compiler Construction"
      },
      "publication_date": "2002-04-08",
      "selected": null,
      "title": "Decompiling Java Bytecode: Problems, Traps and Pitfalls",
      "urls": [
        "https://dl.acm.org/doi/10.5555/647478.727938"
      ]
    },
    {
      "abstract": "Just as an interpreter for a source language can be turned into a compiler from the source language to a target language, we observe that an interpreter for a target language can be turned into a compiler from the target language to a source language. In both cases,...",
      "authors": [
        "Sig Ager, Mads",
        "Danvy, Olivier",
        "Goldberg, Mayer"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-36377-7_14",
      "keywords": [],
      "number_of_pages": 36,
      "pages": "296-331",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2002-01-01",
      "selected": null,
      "title": "A Symmetric Approach to Compilation and Decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84887882231&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/3-540-36377-7_14.pdf"
      ]
    },
    {
      "abstract": "Java virtual machines execute Java bytecode instructions. Since this bytecode is a higher level representation than traditional object code, it is possible to decompile it back to Java source. Many such decompilers have been developed and the conventional wisdom is...",
      "authors": [
        "Miecznikowski, Jerome",
        "Hendren, Laurie"
      ],
      "categories": null,
      "citations": 45,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-45937-5_10",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "111-127",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "2002-01-01",
      "selected": null,
      "title": "Decompiling Java Bytecode: Problems, Traps and Pitfalls",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84959039621&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/3-540-45937-5_10.pdf"
      ]
    },
    {
      "abstract": "The authors propose a formal model and a platform to deal with distributed multi-language software analysis. These provide a graph representation of the software codes (source codes and byte-codes), a change propagation process based on graph rewriting, and an automatic profiling tool to measure the contribution of any component to the global performance of the software. The program codes are structured by a multi-graph in which the nodes represent the software components linked by edges representing the meaningful relationships. The software components and their relationships are extracted from the byte-code files, using the mocha decompiler tool, and from the source codes files, using the Javacc tool. Javacc allows one to generate parsers, based on grammar specification files, which include features to produce an XML (eXtensible Markup Language) representation of the software components. Furthermore, a graph of the software components is constructed on the top of the XML files, providing program analysis. This is implemented by an integrated platform including the mocha decompiler, a multi-language parsing tool, a software change management module, and a profiling tool.",
      "authors": [
        "L. Deruelle",
        "N. Melab",
        "M. Bouneffa",
        "H. Basson"
      ],
      "categories": null,
      "citations": 16,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/SCAM.2001.972665",
      "keywords": [],
      "number_of_pages": 12,
      "pages": "43-54",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-1387-5",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings First IEEE International Workshop on Source Code Analysis and Manipulation"
      },
      "publication_date": "2001-11-10",
      "selected": null,
      "title": "Analysis and manipulation of distributed multi-language software code",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=972665",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84963863727&origin=inward"
      ]
    },
    {
      "abstract": "The paper presents an approach to program structuring for use in decompiling Java bytecode to Java source. The structuring approach uses three intermediate representations: (1) a list of typed, aggregated statements with an associated exception table, (2) a control flow graph, and (3) a structure encapsulation tree. The approach works in six distinct stages, with each stage focusing on a specific family of Java constructs, and each stage contributing more detail to the structure encapsulation tree. After completion of all stages the structure encapsulation tree contains enough information to allow a simple extraction of a structured Java program. The approach targets general Java bytecode including bytecode that may be the result of front-ends for languages other than Java, and also bytecode that has been produced by a bytecode optimizer. Thus, the techniques have been designed to work for bytecode that may not exhibit the typical structured patterns of bytecode produced by a standard Java compiler. The structuring techniques have been implemented as part of the Dava decompiler which has been built using the Soot framework.",
      "authors": [
        "J. Miecznikowski",
        "L. Hendren"
      ],
      "categories": null,
      "citations": 15,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/WCRE.2001.957845",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "368-374",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4577-1948-6",
        "issn": "1095-1350",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-10-02",
      "selected": null,
      "title": "Decompiling Java using staged encapsulation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=957845"
      ]
    },
    {
      "abstract": "In the past couple of years interest in decompilation has widened from its initial concentration on reconstruction of control flow into well-founded-in-theory methods to reconstruct type information. A. Mycroft (1999) described Type-Based Decompilation and S. Katsumata and A. Ohori (2001) described Proof-Directed Decompilation. The article summarises the two approaches and identifies their commonality, strengths and weaknesses; it concludes by suggesting how they may be integrated.",
      "authors": [
        "A. Mycroft",
        "A. Ohori",
        "S. Katsumata"
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/WCRE.2001.957844",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "362-367",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4577-1948-6",
        "issn": "1095-1350",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-10-02",
      "selected": null,
      "title": "Comparing type-based and proof-directed decompilation",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=957844"
      ]
    },
    {
      "abstract": "This paper describes a type system used in a disassembler program to produce enhanced disassembly output The type system described in this paper is capable of representing C language types. It operates using the following methodology. First, the type information is collected from the standard C headers and is stored in type library files. The stored information is then used to comment and enhance the disassembly. A simple propagation algorithm for function arguments is described as an illustration of the functionality of the system. The power of the type system presented is that a decompiler can be constructed using a disassembler augmented by this system.",
      "authors": [
        "I. Guilfanov"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/WCRE.2001.957843",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "357-361",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "978-1-4577-1948-6",
        "issn": "1095-1350",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-10-02",
      "selected": null,
      "title": "Simple type system for program reengineering",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=957843"
      ]
    },
    {
      "abstract": "This paper presents an approach to program structuring for use in decompiling Java bytecode to Java source. The structuring approach uses three intermediate representations: (1) a list of typed, aggregated statements with an associated exception table, (2) a control flow graph, and (3) a structure encapsulation tree.The approach works in six distinct stages, with each stage focusing on a specific family of Java constructs, and each stage contributing more detail to the structure encapsulation tree. After completion of all stages the structure encapsulation tree contains enough information to allow a simple extraction of a structured Java program.The approach targets general Java bytecode including bytecode that may be the result of front-ends for languages other than Java, and also bytecode that has been produced by a bytecode optimizer. Thus, the techniques have been designed to work for bytecode that may not exhibit the typical structured patterns of bytecode produced by a standard Java compiler.The structuring techniques have been implemented as part of the Dava decompiler which has been built using the Soot framework.",
      "authors": [
        "Jerome Miecznikowski",
        "Laurie Hendren"
      ],
      "categories": null,
      "citations": 8,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/832308.837159",
      "keywords": [
        "Java Decompile Soot Dava \"Staged Encapsulation\" Sable"
      ],
      "number_of_pages": null,
      "pages": "368",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769513034",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the Eighth Working Conference on Reverse Engineering (WCRE'01)"
      },
      "publication_date": "2001-10-02",
      "selected": null,
      "title": "Decompiling Java using staged encapsulation",
      "urls": [
        "https://dl.acm.org/doi/10.5555/832308.837159"
      ]
    },
    {
      "abstract": "In the past couple of years interest in decompilation has widened from its initial concentration on reconstruction of control flow into well-founded-in-theory methods to reconstruct type information. Mycroft described Type-Based Decompilation and Katsumata and Ohori described Proof-Directed Decompilation. This note summarises the two approaches and identifies their commonality, strengths and weaknesses; it concludes by suggesting how they may be integrated.",
      "authors": [
        "Alan Mycroft",
        "Atsushi Ohori",
        "Shin-ya Katsumata"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/832308.837156",
      "keywords": [],
      "number_of_pages": null,
      "pages": "362",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769513034",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the Eighth Working Conference on Reverse Engineering (WCRE'01)"
      },
      "publication_date": "2001-10-02",
      "selected": null,
      "title": "Comparing Type-Based and Proof-Directed Decompilation",
      "urls": [
        "https://dl.acm.org/doi/10.5555/832308.837156"
      ]
    },
    {
      "abstract": "This paper describes a type system used in a disassembler program to produce enhanced disassembly output. The type system described herein is capable of representing C language types. It operates using the following methodology. First, the type information is collected from the standard C headers and is stored in type library files. The stored information is then used to comment and enhance the disassembly. A simple propagation algorithm for function arguments is described as an illustration of the functionality of the system. The power of the type system presented is that a decompiler can be constructed using a disassembler augmented by this system.",
      "authors": [
        "I. Guilfanov"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/832308.837158",
      "keywords": [
        "type system",
        "disassembly",
        "decompilation"
      ],
      "number_of_pages": null,
      "pages": "357",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0769513034",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the Eighth Working Conference on Reverse Engineering (WCRE'01)"
      },
      "publication_date": "2001-10-02",
      "selected": null,
      "title": "A Simple Type System for Program Reengineering",
      "urls": [
        "https://dl.acm.org/doi/10.5555/832308.837158"
      ]
    },
    {
      "abstract": "New algorithms for the structuring of arbitrary control-flow graphs are presented. As they minimize the use of Gotos, these algorithms are adequate for the control-flow analysis needed in the process of decompilation: loops are properly identified even when nested loops share the some header node, and complex compound Boolean conditions are completely handled. With the described algorithms, the generated high level language code results are easier to understand, which eases the maintenance of legacy code. The presented techniques have been implemented and have proved successful in their aim of structuring decompiled graphs from a variety of industrial real time embedded software on diverse architectures.",
      "authors": [
        "E. Moretti",
        "G. Chanteperdrix",
        "A. Osorio"
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/CSMR.2001.914984",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "184-187",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-1028-0",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR"
      },
      "publication_date": "2001-03-14",
      "selected": null,
      "title": "New algorithms for control-flow graph structuring",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0035784361&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=914984"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Guilfanov I."
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 5,
      "pages": "357-361",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "A simple type system for program reengineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034770426&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cifuentes C."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "Messages from the workshop chairs: Workshop on decompilation techniques",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034780853&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "Eighth working conference on reverse engineering",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034781157&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mycroft A."
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 6,
      "pages": "362-367",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "Comparing type-based and proof-directed decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034775346&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Miecznikowski J."
      ],
      "categories": null,
      "citations": 22,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 7,
      "pages": "368-374",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "Decompiling Java using staged encapsulation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034775347&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cifuentes C."
      ],
      "categories": null,
      "citations": 10,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 6,
      "pages": "375-380",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "Computer security analysis through decompilation and high-level debugging",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034770594&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Kumar R."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/609761.609765",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "26-36",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "03621340",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.104,
        "snip": 0.133,
        "subject_areas": [
          "Computer Graphics and Computer-Aided Design",
          "Software"
        ],
        "title": "SIGPLAN Notices (ACM Special Interest Group on Programming Languages)"
      },
      "publication_date": "2001-01-01",
      "selected": null,
      "title": "A neural net compiler system for hierarchical organization",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=17144411884&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Miecznikowski J."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/367845.368004",
      "keywords": [],
      "number_of_pages": 2,
      "pages": "111-112",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "1581133073",
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, OOPSLA"
      },
      "publication_date": "2000-12-01",
      "selected": null,
      "title": "Decompile Java class files with soot!",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84885200691&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Monden A."
      ],
      "categories": null,
      "citations": 79,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 7,
      "pages": "191-197",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": "9780769528700",
        "issn": "07303157",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.302,
        "snip": 0.683,
        "subject_areas": [
          "Computer Science Applications",
          "Software"
        ],
        "title": "Proceedings - IEEE Computer Society's International Computer Software and Applications Conference"
      },
      "publication_date": "2000-12-01",
      "selected": null,
      "title": "Practical method for watermarking Java programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0034504466&origin=inward"
      ]
    },
    {
      "abstract": "Java programs distributed through the Internet are now suffering from program theft. This is because Java programs can be easily decomposed into reusable class files and even decompiled into source code by program users. We propose a practical method that discourages program theft by embedding Java programs with a digital watermark. Embedding a program developer's copyright notation as a watermark in Java class files will ensure the legal ownership of class files. Our embedding method is indiscernible by program users, yet enables us to identify an illegal program that contains stolen class files. The result of the experiment to evaluate our method showed most of the watermarks (20 out of 23) embedded in class files survived two kinds of attacks that attempt to erase watermarks: an obfuscactor attack, and a decompile-recompile attack.",
      "authors": [
        "A. Monden",
        "H. Iida",
        "K. Matsumoto",
        "K. Inoue",
        "K. Torii"
      ],
      "categories": null,
      "citations": 42,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/CMPSAC.2000.884716",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "191-197",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": "0-7695-2870-8",
        "issn": "0730-3157",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.302,
        "snip": 0.683,
        "subject_areas": [
          "Computer Science Applications",
          "Software"
        ],
        "title": "Proceedings 24th Annual International Computer Software and Applications Conference. COMPSAC2000"
      },
      "publication_date": "2000-10-25",
      "selected": null,
      "title": "A practical method for watermarking Java programs",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=884716"
      ]
    },
    {
      "abstract": "Undoubtedly, Java/sup TM/ has become a very popular choice of Internet programming language for developing many Web applications. However, few engineers or researchers questioned Java security problems due to its informative classfiles in which hackers can easily use most available decompilers to reverse-engineer targeted applications. We investigate an interesting proposal of the innovative combination of class decompilers and obfuscators as a feedback-and-control system to secure Java applications. Unlike ordinary obfuscation techniques which always require prior knowledge about the Java source files, our approach can start from the compiled Java classfiles, especially useful when the original source is partially or completely lost. Moreover, the obfuscated codes can also use back the class decompiler as a tester to check if the final product is sufficiently secured. In general, our contribution is two-fold. First, our proposal demonstrated the first constructive use of class decompilers to facilitate the security of Java applications. Decompilers are combined with visualization techniques to deduce useful information for obfuscation. More importantly, with component-based approach, our implemented system can actually be extended as a centralized Web-based testing center with a library of obfuscators to secure most real-life Java applications against a collection of class decompilers.",
      "authors": [
        "V. Tam",
        "R.K. Gupta"
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/WISE.2000.882387",
      "keywords": [],
      "number_of_pages": 6,
      "pages": "153-158 vol.1",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-0577-5",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1st International Conference on Web Information Systems Engineering, WISE 2000"
      },
      "publication_date": "2000-06-19",
      "selected": null,
      "title": "Using class decompilers to facilitate the security of Java applications!",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84968764306&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=882387"
      ]
    },
    {
      "abstract": "Undoubtedly, Java TM has become a very popular choice of Internet programming languages for developing many Web applications nowadays. However, few engineers or researchers questioned about Java security problems due to its informative class files in which hackers can easily use most available class decompilers to reverse-engineer targeted Java applications. In this paper, we investigate an interesting proposal of the innovative combination of class decompilers and obfuscators as a feedback-and-control system to secure Java applications. Unlike ordinary obfuscation techniques, which always require prior knowledge about the Java source files, our approach can start from the compiled Java class files, especially useful when the original source is partially or completely lost. Moreover, the obfuscated codes can also use back the class decompiler as a tester to check if the final product is sufficiently secured.In general, our contribution is two-folded. First, our proposal demonstrated the first constructive use of class decompilers to facilitate the security of Java applications. Decompilers are combined with visualization techniques to deduce useful information for obfuscation. More importantly, with component-based approach, our implemented system can actually be extended as a centralized Web-based testing center with a library of obfuscators to secure most real-life Java applications against a collection of class decompilers. Up to our knowledge, our prototype system (REVEAL) represents the first on-line and multi-threaded Java class decompiler and obfuscator available on the Web. Clearly, there are many interesting directions such as incremental decompilation and obfuscation for large-scale Java applications, and the integration of more sophisticated visualization techniques for future exploration.",
      "authors": [
        "Vincent Tam",
        "Rakesh K. Gupta"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/882511.885359",
      "keywords": [
        "Reverse Engineering in Java",
        "Java Applications",
        "Obfuscation"
      ],
      "number_of_pages": null,
      "pages": "153",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "07695057751",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the First International Conference on Web Information Systems Engineering (WISE'00)-Volume 1 - Volume 1"
      },
      "publication_date": "2000-06-19",
      "selected": null,
      "title": "Using Class Decompilers to Facilitate the Security of Java Applications",
      "urls": [
        "https://dl.acm.org/doi/10.5555/882511.885359"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Freedman C.D."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1093/ijlit/8.1.25",
      "keywords": [],
      "number_of_pages": 23,
      "pages": "25-47",
      "publication": {
        "category": "Journal",
        "cite_score": 4.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09670769",
        "publisher": "Oxford University Press",
        "sjr": 0.544,
        "snip": 1.193,
        "subject_areas": [
          "Library and Information Sciences",
          "Law"
        ],
        "title": "International Journal of Law and Information Technology"
      },
      "publication_date": "2000-01-01",
      "selected": null,
      "title": "The protection of computer software in copyright and the law of confidence: Improper decompilation and employee-poaching",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0344029054&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cifuentes C."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 11,
      "pages": "66-76",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781479929313",
        "issn": "10951350",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - Working Conference on Reverse Engineering, WCRE"
      },
      "publication_date": "1999-12-01",
      "selected": null,
      "title": "Impact of copyright on the development of cutting edge binary reverse engineering technology",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0033362417&origin=inward"
      ]
    },
    {
      "abstract": "Reverse engineering of executable code is a growing area of software engineering research and technology development due to a variety of reasons, including the porting of programs to newer and faster machines. In this paper we discuss three core object code reverse engineering technologies: emulation, decompilation, and binary translation, and present their uses in the last decades. These uses point at an economic need for such techniques to the benefit of users of the technology. We then present the extent of copyright protection for binary code and its implications on the development of binary code manipulation tools. Further, we argue that copyright laws should not hinder the development of computer and software technology at a time when hardware is developing at increasingly fast rates and software needs to be made available on such new machines; i.e. economic considerations need to be taken into account.",
      "authors": [
        "C. Cifuentes"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/WCRE.1999.806948",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "66-76",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-7695-0303-9",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Sixth Working Conference on Reverse Engineering (Cat. No.PR00303)"
      },
      "publication_date": "1999-10-08",
      "selected": null,
      "title": "The impact of copyright on the development of cutting edge binary reverse engineering technology",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=806948"
      ]
    },
    {
      "abstract": "Java&#x2019;s stack&#x2010;based intermediate representation (IR) is typically coerced to execute on register&#x2010;based architectures. Unoptimized compiled code dutifully replicates transient variable usage designated by the programmer and common optimization practices tend to introduce further usage (i.e., CSE, Loop&#x2010;invariant Code Motion, etc.). On register based machines, often transient variables are cached within registers (when available) saving the expense of actually accessing memory. Unfortunately, in stack&#x2010;based environments because of the need to push and pop the transient values, further performance improvement is possible. This paper presents Transient Variable Caching (TVC), a technique for eliminating transient variable overhead whenever possible. This optimization would find a likely home in optimizers attached to the back of popular Java compilers. Side effects of the algorithm include significant instruction reordering and introduction of many stack&#x2010;manipulation operations. This combination has proven to greatly impede the ability to decompile stack&#x2010;based IR code sequences. The code that results from the transform is faster, smaller, and greatly impedes decompilation.",
      "authors": [
        "T\u00fdma, Paul"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "https://doi.org/10.1155/1999/501879",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "157-166",
      "publication": {
        "category": "Journal",
        "cite_score": 1.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1058-9244",
        "publisher": "Hindawi Limited",
        "sjr": 0.303,
        "snip": 0.581,
        "subject_areas": [
          "Computer Science Applications",
          "Software"
        ],
        "title": "Scientific Programming"
      },
      "publication_date": "1999-04-01",
      "selected": null,
      "title": "Transient Variable Caching in Java\u2019s Stack-Based Intermediate Representation",
      "urls": [
        "https://dl.acm.org/doi/10.1155/1999/501879",
        "https://downloads.hindawi.com/journals/sp/1999/501879.pdf"
      ]
    },
    {
      "abstract": "Reverse engineering-the process of looking at lower levels of abstraction to understand higher levels-is not limited to decompiling programs, as many believe. It is an excellent way to pinpoint what you need to build an interface or change a system to reflect new business goals. But unraveling someone's code opens up a legal can of worms, and as reverse engineering becomes more popular, some people are taking time out from their Y2K worries to say, \"is this legal?\" This in and of itself is not new-the law seems consistently to be an afterthought to solving technological problems-but in this case, the current preoccupation with reverse engineering may cause the two disciplines to finally stop and consider each other. The courts may realize that if we want to achieve a global electronic society, the law has to make it easier for systems to become interoperable, correct, and secure. Software and system developers may realize that long-standing legal principles can actually work for them, not tie their hands and, more important, that they can influence the laws being made. Unfortunately, we seem to be taking one step forward and two steps back in trying to make this happen. Laws in four key regions-the US, EU, Japan, and Australia-reveal foundational inconsistencies in attitudes about reverse engineering. And recent US legislation, both enacted and proposed, is conflicted.",
      "authors": [
        "C. Cifuentes",
        "A. Fitzgerald"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/6294.774940",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "42-48",
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1941-045X",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IT Professional"
      },
      "publication_date": "1999-01-01",
      "selected": null,
      "title": "Is reverse engineering always legal?",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=774940"
      ]
    },
    {
      "abstract": null,
      "authors": [],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 306,
      "pages": "1-306",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1999-01-01",
      "selected": null,
      "title": "8th European Symposium on Programming, ESOP 1999 held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 1999",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84957874997&origin=inward"
      ]
    },
    {
      "abstract": "We describe a system which decompiles (reverse engineers) C programs from target machine code by type-inference techniques. This extends recent trends in the converse process of compiling high-level languages whereby type information is preserved during compilation....",
      "authors": [
        "Mycroft, Alan"
      ],
      "categories": null,
      "citations": 38,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-49099-X_14",
      "keywords": [],
      "number_of_pages": 16,
      "pages": "208-223",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1999-01-01",
      "selected": null,
      "title": "Type-Based Decompilation (or Program Reconstruction via Type Reconstruction)",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84957893289&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/3-540-49099-X_14.pdf"
      ]
    },
    {
      "abstract": "We adopt the untyped imperative object calculus of Abadi and Cardelli as a minimal setting in which to study problems of compilation and program equivalence that arise when compiling object-oriented languages. We present both a big-step and a small-step substitution-based operational semantics for the calculus. Our first two results are theorems asserting the equivalence of our substitution-based semantics with a closure-based semantics like that given by Abadi and Cardelli. Our third result is a direct proof of the correctness of compilation to a stack-based abstract machine via a small-step decompilation algorithm. Our fourth result is that contextual equivalence of objects coincides with a form of Mason and Talcott's CIU equivalence; the latter provides a tractable means of establishing operational equivalences. Finally, we prove correct an algorithm, used in our prototype compiler, for statically resolving method offsets. This is the first study of correctness of an object-oriented abstract machine, and of operational equivalence for the imperative object calculus.",
      "authors": [
        "ANDREW D. GORDON",
        "PAUL D. HANKIN",
        "S\u00d8REN B. LASSEN"
      ],
      "categories": null,
      "citations": 7,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1017/S0956796899003482",
      "keywords": [],
      "number_of_pages": 54,
      "pages": "373-426",
      "publication": {
        "category": "Journal",
        "cite_score": 1.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09567968",
        "publisher": "Cambridge University Press",
        "sjr": 0.815,
        "snip": 1.044,
        "subject_areas": [
          "Software"
        ],
        "title": "Journal of Functional Programming"
      },
      "publication_date": "1999-01-01",
      "selected": null,
      "title": "Compilation and equivalence of imperative objects",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0033462273&origin=inward"
      ]
    },
    {
      "abstract": "To ensure platform independence, mobile programs are distributed in forms that are isomorphic to the original source code. Such codes are easy to decompile, and hence they increase the risk of malicious reverse engineering attacks. Code obfuscation is one of several techniques which has been proposed to alleviate this situation. An obfuscator is a tool which-through the application of code transformations-converts a program into an equivalent one that is more difficult to reverse engineer. In a previous paper (Collberg et al., 1998) we have described the design of a control flow obfuscator for Java. In this paper we extend the design with transformations that obfuscate data structures and abstractions. In particular we show how to obfuscate classes, arrays, procedural abstractions and built-in data types like strings, integers and booleans.",
      "authors": [
        "C. Collberg",
        "C. Thomborson",
        "D. Low"
      ],
      "categories": null,
      "citations": 114,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/ICCL.1998.674154",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "28-38",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-8186-8454-2",
        "issn": "1074-8970",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1998 International Conference on Computer Languages (Cat. No.98CB36225)"
      },
      "publication_date": "1998-05-16",
      "selected": null,
      "title": "Breaking abstractions and unstructuring data structures",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0031620963&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=674154"
      ]
    },
    {
      "abstract": "To ensure platform independence, mobile programs are distributed in forms that are isomorphic to the original source code. Such codes are easy to decompile, and hence they increase the risk of malicious reverse engineering attacks.Code obfuscation is one of several techniques which has been proposed to alleviate this situation. An obfuscator is a tool which - through the application of code transformations - converts a program into an equivalent one that is more difficult to reverse engineer.In a previous paper we have described the design of a control flow obfuscator for Java. In this paper we extend the design with transformations that obfuscate data structures and abstractions. In particular, we show how to obfuscate classes, arrays, procedural abstractions and built-in data types like strings, integers, and booleans.",
      "authors": [
        "Christian Collberg",
        "Clark Thomborson",
        "Douglas Low"
      ],
      "categories": null,
      "citations": 42,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/857172.857242",
      "keywords": [
        "code transformations.",
        "intellectual property protection",
        "obfuscation"
      ],
      "number_of_pages": null,
      "pages": "28",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0818684542",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1998 International Conference on Computer Languages"
      },
      "publication_date": "1998-05-14",
      "selected": null,
      "title": "Breaking Abstractions and Unstructuring Data Structures",
      "urls": [
        "https://dl.acm.org/doi/10.5555/857172.857242"
      ]
    },
    {
      "abstract": "The Java language is compiled into a platform independent bytecode format. Much of the information contained in the original source code remains in the bytecode, thus decompilation is easy. We will examine how code obfuscation can help protect Java bytecodes.",
      "authors": [
        "Douglas Low"
      ],
      "categories": null,
      "citations": 42,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.1145/332084.332092",
      "keywords": [],
      "number_of_pages": 3,
      "pages": "21-23",
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1528-4972",
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "XRDS"
      },
      "publication_date": "1998-04-01",
      "selected": null,
      "title": "Protecting Java code via code obfuscation",
      "urls": [
        "https://dl.acm.org/doi/10.1145/332084.332092"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Lemley M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Journal",
        "cite_score": 1.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00404411",
        "publisher": "University of Texas at Austin",
        "sjr": 0.302,
        "snip": 0.313,
        "subject_areas": [
          "Law"
        ],
        "title": "Texas Law Review"
      },
      "publication_date": "1998-03-01",
      "selected": null,
      "title": "Decompilation of collective works: When the first sale doctrine is a mirage",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0041705120&origin=inward"
      ]
    },
    {
      "abstract": "Software components are often delivered in \"black boxes\" as executable objects whose licenses forbid decompilation back to source code. Often source code can be licensed, but the cost makes doing so prohibitive. We therefore have developed a methodology for determining the quality of off-the-shelf (OTS) components using a set of black box analyses. This methodology will provide developers with information useful for choosing components and for defending themselves legally against someone else's imperfect OTS components.",
      "authors": [
        "J.M. Voas"
      ],
      "categories": null,
      "citations": 114,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/2.683008",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "53-59",
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1558-0814",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Computer"
      },
      "publication_date": "1998-01-01",
      "selected": null,
      "title": "Certifying off-the-shelf software components",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=683008"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Collberg C."
      ],
      "categories": null,
      "citations": 397,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/268946.268962",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "184-196",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 8.9,
        "is_potentially_predatory": false,
        "isbn": "9781450335492",
        "issn": "07308566",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.774,
        "snip": 4.87,
        "subject_areas": [
          "Software"
        ],
        "title": "Conference Record of the Annual ACM Symposium on Principles of Programming Languages"
      },
      "publication_date": "1998-01-01",
      "selected": null,
      "title": "Manufacturing cheap, resilient, and stealthy opaque constructs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0031649930&origin=inward"
      ]
    },
    {
      "abstract": "This paper presents our technique for automatically decompiling Java bytecode into Java source. Our technique reconstructs source-level expressions from bytecode, and reconstructs readable, high-level control statements from primitive goto-like branches. Fewer than a dozen simple code-rewriting rules reconstruct the high-level statements.",
      "authors": [
        "Todd A. Proebsting",
        "Scott A. Watterson"
      ],
      "categories": null,
      "citations": 16,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/1268028.1268042",
      "keywords": [],
      "number_of_pages": 1,
      "pages": "14",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": "USENIX Association",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 3rd conference on USENIX Conference on Object-Oriented Technologies (COOTS) - Volume 3"
      },
      "publication_date": "1997-06-16",
      "selected": null,
      "title": "Krakatoa: decompilation in java (dose bytecode reveal source?)",
      "urls": [
        "https://dl.acm.org/doi/10.5555/1268028.1268042"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Ramsey N."
      ],
      "categories": null,
      "citations": 94,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/256167.256225",
      "keywords": [],
      "number_of_pages": 33,
      "pages": "492-524",
      "publication": {
        "category": "Journal",
        "cite_score": 3.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01640925",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.749,
        "snip": 0.936,
        "subject_areas": [
          "Software"
        ],
        "title": "ACM Transactions on Programming Languages and Systems (TOPLAS)"
      },
      "publication_date": "1997-01-01",
      "selected": null,
      "title": "Specifying Representations of Machine Instructions",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0031141881&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Proebsting T.A."
      ],
      "categories": null,
      "citations": 34,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 3rd USENIX Conference on Object-Oriented Technologies, COOTS 1997"
      },
      "publication_date": "1997-01-01",
      "selected": null,
      "title": "Krakatoa: Decompilation in Java (does bytecode reveal source?)",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84944201230&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cifuentes C."
      ],
      "categories": null,
      "citations": 18,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 23,
      "pages": "77-99",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09639306",
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Journal of Programming Languages"
      },
      "publication_date": "1996-06-01",
      "selected": null,
      "title": "Interprocedural data flow decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0002364562&origin=inward"
      ]
    },
    {
      "abstract": "A structuring algorithm for arbitrary control flow graphs is presented. Graphs are structured into functional, semantical and structural equivalent graphs, without code replication or introduction of new variables. The algorithm makes use of a set of generic...",
      "authors": [
        "Cifuentes, Cristina"
      ],
      "categories": null,
      "citations": 22,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-61053-7_55",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "91-105",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1996-01-01",
      "selected": null,
      "title": "Structuring decompiled graphs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84957679457&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/3-540-61053-7_55.pdf"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Danvy O."
      ],
      "categories": null,
      "citations": 113,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/237721.237784",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "242-256",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 8.9,
        "is_potentially_predatory": false,
        "isbn": "9781450335492",
        "issn": "07308566",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.774,
        "snip": 4.87,
        "subject_areas": [
          "Software"
        ],
        "title": "Conference Record of the Annual ACM Symposium on Principles of Programming Languages"
      },
      "publication_date": "1996-01-01",
      "selected": null,
      "title": "Type-directed partial evaluation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0029706995&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Loon N."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1093/ijlit/4.1.48",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "48-64",
      "publication": {
        "category": "Journal",
        "cite_score": 4.9,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09670769",
        "publisher": "Oxford University Press",
        "sjr": 0.544,
        "snip": 1.193,
        "subject_areas": [
          "Library and Information Sciences",
          "Law"
        ],
        "title": "International Journal of Law and Information Technology"
      },
      "publication_date": "1996-01-01",
      "selected": null,
      "title": "Legitimizing reverse engineering of computer programs in copyright law - how far have we gone in singapore?",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85040428773&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Tyugu E."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/0167-739X(96)88793-0",
      "keywords": [],
      "number_of_pages": 13,
      "pages": "203-215",
      "publication": {
        "category": "Journal",
        "cite_score": 21.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0167739X",
        "publisher": "Elsevier B.V.",
        "sjr": 2.043,
        "snip": 2.584,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Future Generation Computer Systems"
      },
      "publication_date": "1996-01-01",
      "selected": null,
      "title": "Declarative reflection tools for agent shells",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0030235763&origin=inward"
      ]
    },
    {
      "abstract": "Reverse engineering of software systems has traditionally centered upon the generation of high level abstractions or specifications from high level code or databases. We report on a reverse engineering environment for low level executable code: a reverse compilation or decompilation environment that aids in the understanding of the underlying executable program. The reverse compilation process recovers high level code from executable programs at a higher representation level than that produced by disassemblers; in fact, disassembly is part of the first stage in this process. Several tools aid in the process of reverse compilation, these are: loaders, signature generators, library prototype generators, disassemblers, library bindings, and language to language translators. The integration of these tools in the whole process is presented in this paper. The results obtained by the prototype reverse compilation system dcc are encouraging: high level code is regenerated with correct use of expressions and control structures, and the complete elimination of registers and condition codes. An elimination rate of low level instructions of over 75% was reached, representing the overall improvement this decompiler system has made over previous decompilers and disassemblers (where the rate tends to be nil). A sample decompilation program is given.",
      "authors": [
        "C. Cifuentes"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "IEEE",
        "Scopus"
      ],
      "doi": "10.1109/APSEC.1995.496990",
      "keywords": [],
      "number_of_pages": 10,
      "pages": "410-419",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0-8186-7171-8",
        "issn": null,
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 1995 Asia Pacific Software Engineering Conference, APSEC 1995"
      },
      "publication_date": "1995-12-06",
      "selected": null,
      "title": "An environment for the reverse engineering of executable programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=4544350379&origin=inward",
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=496990"
      ]
    },
    {
      "abstract": "Reverse engineering of software systems has traditionally centered upon the generation of high-level abstractions or specifications from high-level code or databases. In this paper we report on a reverse engineering environment for low-level executable code: a reverse compilation or decompilation environment that aids in the understanding of the underlying executable program. The reverse compilation process recovers high-level code from executable programs at a higher representation level than that produced by disassemblers; in fact, disassembly is part of the first stage in this process. Several tools aid in the process of reverse compilation, these are: loaders, signature generators, library prototype generators, disassemblers, library bindings, and language to language translators. The integration of these tools in the whole process is presented in this paper. The results obtained by the prototype reverse compilation system dcc are encouraging: high-level code is regenerated with correct use of expressions and control structures, and the complete elimination of registers and condition codes. An elimination rate of low-level instructions of over 75% was reached, representing the overall improvement this decompiler system has made over previous decompilers and disassemblers (where the rate tends to be nil). A sample decompilation program is given.",
      "authors": [
        "Cristina Cifuentes"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.5555/785406.785420",
      "keywords": [
        "reverse compiler",
        "dos",
        "reverse engineering",
        "disassembler",
        "C language",
        "signatures",
        "i80286"
      ],
      "number_of_pages": null,
      "pages": "410",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "0818671718",
        "issn": null,
        "publisher": "IEEE Computer Society",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings - 1995 Asia Pacific Software Engineering Conference, APSEC 1995"
      },
      "publication_date": "1995-12-06",
      "selected": null,
      "title": "An Environment for the Reverse Engineering of Executable Programs",
      "urls": [
        "https://dl.acm.org/doi/10.5555/785406.785420"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Mizoguchi R."
      ],
      "categories": null,
      "citations": 27,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/0957-4174(94)00044-V",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "15-25",
      "publication": {
        "category": "Journal",
        "cite_score": 12.6,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "09574174",
        "publisher": "Elsevier Ltd.",
        "sjr": 1.873,
        "snip": 2.582,
        "subject_areas": [
          "Engineering (all)",
          "Artificial Intelligence",
          "Computer Science Applications"
        ],
        "title": "Expert Systems With Applications"
      },
      "publication_date": "1995-01-01",
      "selected": null,
      "title": "Task analysis interview based on task ontology",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0029201847&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Cifuentes C."
      ],
      "categories": null,
      "citations": 112,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/spe.4380250706",
      "keywords": [],
      "number_of_pages": 19,
      "pages": "811-829",
      "publication": {
        "category": "Journal",
        "cite_score": 6.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00380644",
        "publisher": "John Wiley and Sons Ltd",
        "sjr": 0.867,
        "snip": 1.301,
        "subject_areas": [
          "Software"
        ],
        "title": "Software - Practice and Experience"
      },
      "publication_date": "1995-01-01",
      "selected": null,
      "title": "Decompilation of binary programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0029345668&origin=inward"
      ]
    },
    {
      "abstract": "Decompiling, as a means of analysing and understanding software, has great practical value. This paper presents a kind of decompiling method offered by the authors, in which the techniques of library-function pattern recognition, intermediate language, symbolic execution, rule-based data type recovery, program transformation, and knowledge engineering are separately applied to different phases of decompiling. Then it is discussed that the techniques of developing expert systems are adopted to build a decompiling system shell independent of the knowledge of language and program running environment. The shell will become a real decompiler, as long as the new knowledge of application environment is interactively acquired.",
      "authors": [
        "Liu, Zongtian",
        "Chen, Fuan"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/BF02943578",
      "keywords": [],
      "number_of_pages": 9,
      "pages": "311-319",
      "publication": {
        "category": "Journal",
        "cite_score": 3.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "10009000",
        "publisher": "Springer New York",
        "sjr": 0.566,
        "snip": 0.936,
        "subject_areas": [
          "Computational Theory and Mathematics",
          "Theoretical Computer Science",
          "Hardware and Architecture",
          "Computer Science Applications",
          "Software"
        ],
        "title": "Journal of Computer Science and Technology"
      },
      "publication_date": "1994-10-01",
      "selected": null,
      "title": "Research on decompiling technology",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0028531046&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/BF02943578.pdf"
      ]
    },
    {
      "abstract": "This paper deals with methods and theory, together with an application of the technique. The correctness of a decompiler generated from a simple occam-like compiler specification is demonstrated.  The basic problem of enumerating the syntax trees of grammars, and then stopping, is shown to have no recursive solution, but methods of abstract interpretation can be used to guarantee the adequacy and completeness of our technique in practical instances, including the decompiler for the language presented here.",
      "authors": [
        "Peter T. Breuer",
        "Jonathan P. Bowen"
      ],
      "categories": null,
      "citations": 21,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/186025.186093",
      "keywords": [
        "logic programming",
        "reverse engineering",
        "abstract interpretation",
        "functional programming",
        "decompilation",
        "attribute grammar",
        "list comprehension"
      ],
      "number_of_pages": 35,
      "pages": "1613-1647",
      "publication": {
        "category": "Journal",
        "cite_score": 3.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0164-0925",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 0.749,
        "snip": 0.936,
        "subject_areas": [
          "Software"
        ],
        "title": "ACM Transactions on Programming Languages and Systems (TOPLAS)"
      },
      "publication_date": "1994-09-01",
      "selected": null,
      "title": "Decompilation: the enumeration of types and grammars",
      "urls": [
        "https://dl.acm.org/doi/10.1145/186025.186093",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0028510855&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Worthy J."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 2,
      "pages": "40-41",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00135127",
        "publisher": "Institution of Electrical Engineers (IEE)",
        "sjr": 0.108,
        "snip": 2.582,
        "subject_areas": [
          "Electrical and Electronic Engineering"
        ],
        "title": "IEE Review"
      },
      "publication_date": "1994-01-01",
      "selected": null,
      "title": "Logical copyright",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0028367908&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Bowen J."
      ],
      "categories": null,
      "citations": 13,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/smr.4360050403",
      "keywords": [],
      "number_of_pages": 30,
      "pages": "205-234",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1040550X",
        "publisher": "John Wiley & Sons Inc.",
        "sjr": 0.195,
        "snip": 2.582,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Journal of Software Maintenance: Research and Practice"
      },
      "publication_date": "1993-01-01",
      "selected": null,
      "title": "From programs to object code and back again using logic programming: Compilation and decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84987216695&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Schmidtchen D."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/0144-8188(93)90031-Y",
      "keywords": [],
      "number_of_pages": 17,
      "pages": "413-429",
      "publication": {
        "category": "Journal",
        "cite_score": 2.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "01448188",
        "publisher": "Elsevier Inc.",
        "sjr": 0.647,
        "snip": 1.108,
        "subject_areas": [
          "Finance",
          "Law",
          "Economics and Econometrics"
        ],
        "title": "International Review of Law and Economics"
      },
      "publication_date": "1993-01-01",
      "selected": null,
      "title": "A pacemaker that stops halfway: The decompilation rule in the EEC directive on the legal protection of computer programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=50749132149&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Guzik Z."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 1,
      "pages": "358",
      "publication": null,
      "publication_date": "1992-12-01",
      "selected": null,
      "title": "z-FORTH - a real-time multitasking Forth for process control",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0026996335&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Flor G."
      ],
      "categories": null,
      "citations": 10,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 8,
      "pages": "109-116",
      "publication": null,
      "publication_date": "1992-12-01",
      "selected": null,
      "title": "MDS-Plus: A software system for fast control and data acquisition in fusion experiments",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0026972914&origin=inward"
      ]
    },
    {
      "abstract": "The debate concerning reverse engineering, decompilation and intermediate copying of software is reviewed. The effects of the Sega Enterprises vs. Accolade court case on this debate are discussed. It is argued that if computer professionals want to ensure that they will be able to continue to work in an environment that promotes innovation and the sharing of ideas, they must demand clear and well-thought-out intellectual-property laws for software and a judicial system capable of handling complex technical cases. They must also take an active role in the development of the laws under which they must work. Representative arguments from both side of the issue are presented in the form of selected quotes.<>",
      "authors": [
        "L.F. Ackerman"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/52.168865",
      "keywords": [],
      "number_of_pages": 3,
      "pages": "100-102",
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1937-4194",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE Software"
      },
      "publication_date": "1992-01-01",
      "selected": null,
      "title": "After Accolade: time for new laws? (reverse engineering)",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=168865"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "King K.N."
      ],
      "categories": null,
      "citations": 272,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/spe.4380210704",
      "keywords": [],
      "number_of_pages": 34,
      "pages": "685-718",
      "publication": {
        "category": "Journal",
        "cite_score": 6.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00380644",
        "publisher": "John Wiley and Sons Ltd",
        "sjr": 0.867,
        "snip": 1.301,
        "subject_areas": [
          "Software"
        ],
        "title": "Software - Practice and Experience"
      },
      "publication_date": "1991-01-01",
      "selected": null,
      "title": "A fortran language system for mutation\u2010based software testing",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0026185573&origin=inward"
      ]
    },
    {
      "abstract": "We introduce context-free flowgraph grammars, which allow to replace single vertices together with their outgoing edges, thereby using the basic embedding idea of the algebraic graph grammar approach. For a naturally defined subclass of these, called the rooted...",
      "authors": [
        "Lichtblau, Ulrike"
      ],
      "categories": null,
      "citations": 4,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/BFb0017411",
      "keywords": [],
      "number_of_pages": 11,
      "pages": "538-548",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1991-01-01",
      "selected": null,
      "title": "Recognizing rooted context-free flowgraph languages in polynomial time",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/BFb0017411.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84947773626&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Maioli F."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 7,
      "pages": "74-80",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00181153",
        "publisher": "Hewlett-Packard Company",
        "sjr": 0.257,
        "snip": 0.667,
        "subject_areas": [
          "Hardware and Architecture",
          "Electrical and Electronic Engineering",
          "Instrumentation"
        ],
        "title": "Hewlett-Packard Journal"
      },
      "publication_date": "1990-12-01",
      "selected": null,
      "title": "Object-oriented message interface for testing the HP 3000 data communications and terminal controller",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0025674927&origin=inward"
      ]
    },
    {
      "abstract": "The commenter disagrees with the arguments in the above-titled article by P. Samuelson (ibid., vol.7, no.4, p.90-6, Jan. 1990) that reverse-engineering programs should be legal and that the unauthorized copies of the program created in decompilation are just 'incidental' and thus do not infringe the program's copyright. He also disagrees with Samuelson's contention that there is a trend for the courts to find copyright infringement only where the program that results from the reverse engineering is substantially similar in expression to the decompiled program. He presents a detailed argument to support his viewpoint. Samuelson presents additional information is support of her position.<>",
      "authors": [
        "V. Siber"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "IEEE"
      ],
      "doi": "10.1109/52.56445",
      "keywords": [],
      "number_of_pages": null,
      "pages": null,
      "publication": {
        "category": null,
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "1937-4194",
        "publisher": "IEEE",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "IEEE Software"
      },
      "publication_date": "1990-01-01",
      "selected": null,
      "title": "Comments, with reply, on 'Reverse-engineering someone else's software: is it legal?' by P. Samuelson",
      "urls": [
        "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=56445"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Liangliang L."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/0167-739X(90)90005-X",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "17-23",
      "publication": {
        "category": "Journal",
        "cite_score": 21.1,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0167739X",
        "publisher": "Elsevier B.V.",
        "sjr": 2.043,
        "snip": 2.584,
        "subject_areas": [
          "Hardware and Architecture",
          "Computer Networks and Communications",
          "Software"
        ],
        "title": "Future Generation Computer Systems"
      },
      "publication_date": "1990-01-01",
      "selected": null,
      "title": "Clause representations in a compiler-based prolog database",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0025449350&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Silver J.L."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 1,
      "pages": "423",
      "publication": null,
      "publication_date": "1989-01-01",
      "selected": null,
      "title": "Bach: a procedural language for specifying polyphonic music",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0026434791&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Rappaport A.T."
      ],
      "categories": null,
      "citations": 6,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/S0020-7373(88)80076-2",
      "keywords": [],
      "number_of_pages": 15,
      "pages": "733-747",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00207373",
        "publisher": "Academic Press Inc.",
        "sjr": 0.257,
        "snip": 0.667,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "International Journal of Man-Machine Studies"
      },
      "publication_date": "1988-01-01",
      "selected": null,
      "title": "Cognitive primitives",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0024138003&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Zuberek W."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 4,
      "pages": "229-232",
      "publication": null,
      "publication_date": "1987-01-01",
      "selected": null,
      "title": "CIRCUIT DECOMPILATION IN THE SPICE-PAC PACKAGE OF SIMULATION SUBROUTINES.",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0023175329&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Rappaport A."
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/S0020-7373(87)80080-9",
      "keywords": [],
      "number_of_pages": 18,
      "pages": "435-452",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00207373",
        "publisher": "Academic Press Inc.",
        "sjr": 0.257,
        "snip": 0.667,
        "subject_areas": [
          "Engineering (all)"
        ],
        "title": "International Journal of Man-Machine Studies"
      },
      "publication_date": "1987-01-01",
      "selected": null,
      "title": "Multiple-problem subspaces in the knowledge-design process",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0023329601&origin=inward"
      ]
    },
    {
      "abstract": "Serious Prolog implementations in recent years have been primarily compiler-based, nearly all of which are founded on the abstract instruction set of Warren [1983]. The performance achieved by such implementations greatly outstrips that attainable in...",
      "authors": [
        "Buettner, Kevin A."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-16492-8_116",
      "keywords": [],
      "number_of_pages": 8,
      "pages": "663-670",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1986-01-01",
      "selected": null,
      "title": "Fast decompilation of compiled Prolog clauses",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84987197200&origin=inward",
        "https://link.springer.com/content/pdf/10.1007/3-540-16492-8_116.pdf"
      ]
    },
    {
      "abstract": "The design and implementation of a relatively portable Prolog compiler achieving 12K LIPS on the standard benchmark is described. The compiler is incremental and uses decompilation to implement retract, clause, and listing, as well as support the needs of its...",
      "authors": [
        "Bowen, Kenneth A.",
        "Buettner, Kevin A.",
        "Cicekli, Ilyas",
        "Turk, Andrew K."
      ],
      "categories": null,
      "citations": 5,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-16492-8_114",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "650-656",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1986-01-01",
      "selected": null,
      "title": "The design and implementation of a high-speed incremental portable Prolog compiler",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/3-540-16492-8_114.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84987161956&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Yoo C.W."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1016/0020-0190(85)90021-3",
      "keywords": [],
      "number_of_pages": 5,
      "pages": "153-157",
      "publication": {
        "category": "Journal",
        "cite_score": 2.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00200190",
        "publisher": "Elsevier B.V.",
        "sjr": 0.388,
        "snip": 0.777,
        "subject_areas": [
          "Signal Processing",
          "Theoretical Computer Science",
          "Information Systems",
          "Computer Science Applications"
        ],
        "title": "Information Processing Letters"
      },
      "publication_date": "1985-09-05",
      "selected": null,
      "title": "An approach to the transportation of computer software",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0022419510&origin=inward"
      ]
    },
    {
      "abstract": "Decompilation denotes the translation from lower level into higher level programming languages. Here we deal with the aspect of detecting higher level control structures, including loops with any number of exits, in line-oriented programs. The detection is carried...",
      "authors": [
        "Lichtblau, Ulrike"
      ],
      "categories": null,
      "citations": 14,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/3-540-15198-2_18",
      "keywords": [],
      "number_of_pages": 14,
      "pages": "284-297",
      "publication": {
        "category": "Book",
        "cite_score": 2.2,
        "is_potentially_predatory": false,
        "isbn": "9783031459320",
        "issn": "03029743",
        "publisher": "Springer Verlag",
        "sjr": 0.32,
        "snip": 0.542,
        "subject_areas": [
          "Computer Science (all)",
          "Theoretical Computer Science"
        ],
        "title": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)"
      },
      "publication_date": "1985-01-01",
      "selected": null,
      "title": "Decompilation of control structures by means of graph transformations",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/3-540-15198-2_18.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=61849128662&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Berg K."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 2,
      "pages": "46-47",
      "publication": {
        "category": "Journal",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "07240031",
        "publisher": "Alfred Huethig Verlag",
        "sjr": 0.388,
        "snip": 0.777,
        "subject_areas": [
          "Medicine (all)"
        ],
        "title": "Computer Applications in the Laboratory"
      },
      "publication_date": "1984-01-01",
      "selected": null,
      "title": "A FORTH decompiler",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0021591462&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Dorsey L."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 10,
      "pages": "495-504",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": 2.5,
        "is_potentially_predatory": false,
        "isbn": "9780769528700",
        "issn": "07303157",
        "publisher": "Institute of Electrical and Electronics Engineers Inc.",
        "sjr": 0.302,
        "snip": 0.683,
        "subject_areas": [
          "Computer Science Applications",
          "Software"
        ],
        "title": "Proceedings - IEEE Computer Society's International Computer Software and Applications Conference"
      },
      "publication_date": "1982-12-01",
      "selected": null,
      "title": "DECOMPILATION OF COBOL-DML PROGRAMS FOR THE PURPOSE OF PROGRAM CONVERSION.",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0020256543&origin=inward"
      ]
    },
    {
      "abstract": "A \u201cdecompilation\u201d algorithm is developed to transform a program written with the procedural operations of CODASYL DML into one which interacts with a relational system via a nonprocedural query specification. An Access Path Model is introduced to interpret the semantic accesses performed by the program. Data flow analysis is used to determine how FIND operations implement semantic accesses. A sequence of these is mapped into a relational query and embedded into the original program. The class of programs for which the algorithm succeeds is characterized.",
      "authors": [
        "R. H. Katz",
        "E. Wong"
      ],
      "categories": null,
      "citations": 34,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/319682.319688",
      "keywords": [
        "decompilation",
        "semantic data models"
      ],
      "number_of_pages": 23,
      "pages": "1-23",
      "publication": {
        "category": "Journal",
        "cite_score": 5.0,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0362-5915",
        "publisher": "Association for Computing Machinery (ACM)",
        "sjr": 1.709,
        "snip": 1.547,
        "subject_areas": [
          "Information Systems"
        ],
        "title": "ACM Transactions on Database Systems (TODS)"
      },
      "publication_date": "1982-03-01",
      "selected": null,
      "title": "Decompiling CODASYL DML into retional queries",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0020100802&origin=inward",
        "https://dl.acm.org/doi/10.1145/319682.319688"
      ]
    },
    {
      "abstract": "A general definition of Polish representation is given for the class of context-free languages and the conditions allowing unique inversion of the representation are studied. Two algorithms are presented for decompiling an important subclass of Polish representations. Both left-to-right and right-to-left processing is considered.",
      "authors": [
        "Bert, M. N.",
        "Petrone, L."
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1007/BF02576191",
      "keywords": [],
      "number_of_pages": 23,
      "pages": "35-57",
      "publication": {
        "category": "Journal",
        "cite_score": 2.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00080624",
        "publisher": "Springer-Verlag Italia s.r.l.",
        "sjr": 0.79,
        "snip": 1.321,
        "subject_areas": [
          "Computational Mathematics",
          "Algebra and Number Theory"
        ],
        "title": "Calcolo"
      },
      "publication_date": "1982-03-01",
      "selected": null,
      "title": "Decompiling context-free languages from their Polish-like representations",
      "urls": [
        "https://link.springer.com/content/pdf/10.1007/BF02576191.pdf",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=51249186694&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Horspool R."
      ],
      "categories": null,
      "citations": 54,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1093/comjnl/23.3.223",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "223-229",
      "publication": {
        "category": "Journal",
        "cite_score": 3.4,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00104620",
        "publisher": "Oxford University Press",
        "sjr": 0.421,
        "snip": 0.739,
        "subject_areas": [
          "Computer Science (all)"
        ],
        "title": "Computer Journal"
      },
      "publication_date": "1980-08-01",
      "selected": null,
      "title": "An approach to the problem of detranslation of computer programs",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0019049469&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Brown P."
      ],
      "categories": null,
      "citations": 3,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1002/spe.4380070502",
      "keywords": [],
      "number_of_pages": 7,
      "pages": "545-551",
      "publication": {
        "category": "Journal",
        "cite_score": 6.7,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "00380644",
        "publisher": "John Wiley and Sons Ltd",
        "sjr": 0.867,
        "snip": 1.301,
        "subject_areas": [
          "Software"
        ],
        "title": "Software - Practice and Experience"
      },
      "publication_date": "1977-01-01",
      "selected": null,
      "title": "More on the re\u2010creation of source code from reverse polish",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0017533287&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Friedman F."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 18,
      "pages": "515-532",
      "publication": null,
      "publication_date": "1976-01-01",
      "selected": null,
      "title": "ADAPTABLE PROGRAMMING SYSTEM FOR THE TRANSFER OF ASSEMBLY-CODED SYSTEMS PROGRAMS.",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0017244804&origin=inward"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Warren J.C."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": null,
      "keywords": [],
      "number_of_pages": 4,
      "pages": "253-256",
      "publication": null,
      "publication_date": "1975-01-01",
      "selected": null,
      "title": "SOFTWARE PORTABILITY: A SURVEY OF APPROACHES AND PROBLEMS.",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=0016597356&origin=inward"
      ]
    },
    {
      "abstract": "A notation is presented for specifying the compilation and decompilation of high-level language programs. Given the decompilation grammar of a programming language, it is possible to study certain properties of that language, such as the redundancy of source language constructs that yield identical object code sequences and the ambiguity of object code generated by procedure calls.",
      "authors": [
        "Schneider, Victor",
        "Winiger, Gary"
      ],
      "categories": null,
      "citations": 2,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1007/BF01933120",
      "keywords": [
        "Code Sequence",
        "Computational Mathematic",
        "Programming Language",
        "Identical Object",
        "Language Program"
      ],
      "number_of_pages": 9,
      "pages": "78-86",
      "publication": {
        "category": "Journal",
        "cite_score": 2.8,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": "0006-3835",
        "publisher": "Springer Netherlands",
        "sjr": 0.779,
        "snip": 1.23,
        "subject_areas": [
          "Computational Mathematics",
          "Computer Networks and Communications",
          "Applied Mathematics",
          "Software"
        ],
        "title": "BIT Numerical Mathematics"
      },
      "publication_date": "1974-03-01",
      "selected": null,
      "title": "Translation grammars for compilation and decompilation",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=34250424151&origin=inward",
        "https://dl.acm.org/doi/10.1007/BF01933120",
        "https://link.springer.com/content/pdf/10.1007/BF01933120.pdf"
      ]
    },
    {
      "abstract": "Machine language decompilation is the translation of machine (assembly) language instruction sequences into statements in a high-level algebraic language such as PL/1. This process can be viewed as the inverse of compilation. Decompilation can be used as an aid for program conversion and program documentation. A general methodology for decompilation that is independent of a particular source and target language is presented. The basic approach is to map the source machine language to a high-level representation, which is relatively machine and language independent, and then translate to the chosen target language. An experimental decompiler was implemented to translate Knuth's MIXAL assembly language into PL/1.",
      "authors": [
        "Barron C. Housel",
        "Maurice H. Halstead"
      ],
      "categories": null,
      "citations": 9,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/800182.810410",
      "keywords": [
        "Machine language translation",
        "Decompiling",
        "Optimization",
        "Program documentation.",
        "Inverse translation"
      ],
      "number_of_pages": 7,
      "pages": "254-260",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450374828",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1974 Annual ACM Conference/Annual Meeting, ACM 1974"
      },
      "publication_date": "1974-01-01",
      "selected": null,
      "title": "A methodology for machine language decompilation",
      "urls": [
        "https://dl.acm.org/doi/10.1145/800182.810410",
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=84976756751&origin=inward"
      ]
    },
    {
      "abstract": "A general syntax-directed strategy is described for translating computer programs written in a machine-level source language into equivalent programs in a higher-level target language. This translation process is referred to as decompilation or inverse compilation. Work on decompilation is potentially applicable in such areas as software portability, source-level debugging and diagnostic systems, and program analysis and validation.",
      "authors": [
        "Clifford R. Hollander"
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.1145/1408800.1408926",
      "keywords": [],
      "number_of_pages": 1,
      "pages": "750",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450378505",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1974 annual ACM conference - Volume 2"
      },
      "publication_date": "1974-01-01",
      "selected": null,
      "title": "A syntax-directed approach to inverse compilation",
      "urls": [
        "https://dl.acm.org/doi/10.1145/1408800.1408926"
      ]
    },
    {
      "abstract": "The feasibility of the use of techniques of inverse compilation (decompilation) for the solution of Software Transport problems depends to a great extent upon the level of adaptability of software systems designed to automate the decompilation process. The attainment of a sufficiently high level of adaptability requires the development of very general and <u>efficient</u> techniques of program structure and variable usage analysis. However, while such techniques are necessary for the development of adaptable decompilation software, they are not by themselves sufficient. What is further needed is a highly sophisticated medium of program description that 1) is comparatively easy to map to and from assembly languages for a wide variety of machines, 2) is suitable for direct input to a program analyzer, and 3) is easily produced by a high-level language compiler.",
      "authors": [
        "Frank L. Friedman"
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "ACM"
      ],
      "doi": "10.1145/1408800.1408927",
      "keywords": [],
      "number_of_pages": 1,
      "pages": "750",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450378505",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1974 annual ACM conference - Volume 2"
      },
      "publication_date": "1974-01-01",
      "selected": null,
      "title": "Inverse compilation feasibility",
      "urls": [
        "https://dl.acm.org/doi/10.1145/1408800.1408927"
      ]
    },
    {
      "abstract": null,
      "authors": [
        "Weller M."
      ],
      "categories": null,
      "citations": 0,
      "comments": null,
      "databases": [
        "Scopus"
      ],
      "doi": "10.1145/1408800.1408930",
      "keywords": [],
      "number_of_pages": 1,
      "pages": "753",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": null,
        "issn": null,
        "publisher": null,
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "Proceedings of the 1974 Annual ACM Conference, ACM 1974"
      },
      "publication_date": "1974-01-01",
      "selected": null,
      "title": "A pragmatic look at decompilers",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85059217178&origin=inward"
      ]
    },
    {
      "abstract": "This paper concerns the development of a family of higher level languages which are to serve as the target languages in the decompiling of assembler coded modules of small computer operating systems. The main objective is the design of a machine independent language to serve as the nucleus of these higher level languages, each of which will ultimately have to possess characteristics unique to the operating system for which it was designed. The work involved in the development of the nucleus language is part of a research effort intended to show that debugged assembler coded systems programs for a specific class of byte-oriented machines can be concisely represented in a higher level language and that this higher level representation can be easily moved from one machine in this class to another. It is our primary purpose here to describe the main features of the nucleus language, and, where space permits, to suggest some of the reasons why these features were included.",
      "authors": [
        "Friedman F.L."
      ],
      "categories": null,
      "citations": 1,
      "comments": null,
      "databases": [
        "ACM",
        "Scopus"
      ],
      "doi": "10.1145/800021.808281",
      "keywords": [],
      "number_of_pages": 4,
      "pages": "60-63",
      "publication": {
        "category": "Conference Proceedings",
        "cite_score": null,
        "is_potentially_predatory": false,
        "isbn": "9781450373791",
        "issn": null,
        "publisher": "Association for Computing Machinery",
        "sjr": null,
        "snip": null,
        "subject_areas": [],
        "title": "International Conference on Architectural Support for Programming Languages and Operating Systems - ASPLOS"
      },
      "publication_date": "1973-01-01",
      "selected": null,
      "title": "A systems implementation language for small computers",
      "urls": [
        "https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&scp=85059763836&origin=inward",
        "https://dl.acm.org/doi/10.1145/800021.808281"
      ]
    }
  ],
  "processed_at": "2024-02-03 03:59:49",
  "publication_types": null,
  "query": "[decompile] OR [decompiling] OR [decompiler] OR [decompilation]",
  "since": null,
  "until": null
}